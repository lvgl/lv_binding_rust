/* automatically generated by rust-bindgen */

use cty;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const LVGL_VERSION_MAJOR: u32 = 6;
pub const LVGL_VERSION_MINOR: u32 = 1;
pub const LVGL_VERSION_PATCH: u32 = 2;
pub const LVGL_VERSION_INFO: &'static [u8; 1usize] = b"\0";
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const LV_HOR_RES_MAX: u32 = 240;
pub const LV_VER_RES_MAX: u32 = 240;
pub const LV_COLOR_DEPTH: u32 = 16;
pub const LV_COLOR_16_SWAP: u32 = 0;
pub const LV_COLOR_SCREEN_TRANSP: u32 = 0;
pub const LV_INDEXED_CHROMA: u32 = 1;
pub const LV_ANTIALIAS: u32 = 1;
pub const LV_DISP_DEF_REFR_PERIOD: u32 = 30;
pub const LV_DPI: u32 = 298;
pub const LV_MEM_CUSTOM: u32 = 0;
pub const LV_MEM_SIZE: u32 = 4096;
pub const LV_MEM_ADR: u32 = 0;
pub const LV_MEM_AUTO_DEFRAG: u32 = 1;
pub const LV_ENABLE_GC: u32 = 0;
pub const LV_INDEV_DEF_READ_PERIOD: u32 = 30;
pub const LV_INDEV_DEF_DRAG_LIMIT: u32 = 10;
pub const LV_INDEV_DEF_DRAG_THROW: u32 = 20;
pub const LV_INDEV_DEF_LONG_PRESS_TIME: u32 = 400;
pub const LV_INDEV_DEF_LONG_PRESS_REP_TIME: u32 = 100;
pub const LV_USE_ANIMATION: u32 = 1;
pub const LV_USE_SHADOW: u32 = 1;
pub const LV_USE_GROUP: u32 = 1;
pub const LV_USE_GPU: u32 = 0;
pub const LV_USE_FILESYSTEM: u32 = 0;
pub const LV_USE_USER_DATA: u32 = 1;
pub const LV_IMG_CF_INDEXED: u32 = 1;
pub const LV_IMG_CF_ALPHA: u32 = 1;
pub const LV_IMG_CACHE_DEF_SIZE: u32 = 1;
pub const LV_TICK_CUSTOM: u32 = 0;
pub const LV_USE_LOG: u32 = 0;
pub const LV_USE_DEBUG: u32 = 0;
pub const LV_THEME_LIVE_UPDATE: u32 = 0;
pub const LV_USE_THEME_TEMPL: u32 = 0;
pub const LV_USE_THEME_DEFAULT: u32 = 0;
pub const LV_USE_THEME_ALIEN: u32 = 0;
pub const LV_USE_THEME_NIGHT: u32 = 0;
pub const LV_USE_THEME_MONO: u32 = 0;
pub const LV_USE_THEME_MATERIAL: u32 = 0;
pub const LV_USE_THEME_ZEN: u32 = 0;
pub const LV_USE_THEME_NEMO: u32 = 0;
pub const LV_FONT_ROBOTO_12: u32 = 0;
pub const LV_FONT_ROBOTO_16: u32 = 0;
pub const LV_FONT_ROBOTO_22: u32 = 0;
pub const LV_FONT_ROBOTO_28: u32 = 1;
pub const LV_FONT_ROBOTO_12_SUBPX: u32 = 1;
pub const LV_FONT_ROBOTO_28_COMPRESSED: u32 = 1;
pub const LV_FONT_UNSCII_8: u32 = 0;
pub const LV_FONT_FMT_TXT_LARGE: u32 = 0;
pub const LV_FONT_SUBPX_BGR: u32 = 0;
pub const LV_TXT_BREAK_CHARS: &'static [u8; 8usize] = b" ,.;:-_\0";
pub const LV_TXT_LINE_BREAK_LONG_LEN: u32 = 12;
pub const LV_TXT_LINE_BREAK_LONG_PRE_MIN_LEN: u32 = 3;
pub const LV_TXT_LINE_BREAK_LONG_POST_MIN_LEN: u32 = 3;
pub const LV_TXT_COLOR_CMD: &'static [u8; 2usize] = b"#\0";
pub const LV_USE_BIDI: u32 = 0;
pub const LV_SPRINTF_CUSTOM: u32 = 0;
pub const LV_USE_OBJ_REALIGN: u32 = 1;
pub const LV_USE_ARC: u32 = 1;
pub const LV_USE_BAR: u32 = 1;
pub const LV_USE_BTN: u32 = 1;
pub const LV_BTN_INK_EFFECT: u32 = 0;
pub const LV_USE_BTNM: u32 = 1;
pub const LV_USE_CALENDAR: u32 = 1;
pub const LV_USE_CANVAS: u32 = 1;
pub const LV_USE_CB: u32 = 1;
pub const LV_USE_CHART: u32 = 1;
pub const LV_CHART_AXIS_TICK_LABEL_MAX_LEN: u32 = 20;
pub const LV_USE_CONT: u32 = 1;
pub const LV_USE_CPICKER: u32 = 1;
pub const LV_USE_DDLIST: u32 = 1;
pub const LV_DDLIST_DEF_ANIM_TIME: u32 = 200;
pub const LV_USE_GAUGE: u32 = 1;
pub const LV_USE_IMG: u32 = 1;
pub const LV_USE_IMGBTN: u32 = 1;
pub const LV_IMGBTN_TILED: u32 = 0;
pub const LV_USE_KB: u32 = 1;
pub const LV_USE_LABEL: u32 = 1;
pub const LV_LABEL_DEF_SCROLL_SPEED: u32 = 25;
pub const LV_LABEL_WAIT_CHAR_COUNT: u32 = 3;
pub const LV_LABEL_TEXT_SEL: u32 = 0;
pub const LV_LABEL_LONG_TXT_HINT: u32 = 0;
pub const LV_USE_LED: u32 = 1;
pub const LV_USE_LINE: u32 = 1;
pub const LV_USE_LIST: u32 = 1;
pub const LV_LIST_DEF_ANIM_TIME: u32 = 100;
pub const LV_USE_LMETER: u32 = 1;
pub const LV_USE_MBOX: u32 = 1;
pub const LV_USE_PAGE: u32 = 1;
pub const LV_PAGE_DEF_ANIM_TIME: u32 = 400;
pub const LV_USE_PRELOAD: u32 = 1;
pub const LV_PRELOAD_DEF_ARC_LENGTH: u32 = 60;
pub const LV_PRELOAD_DEF_SPIN_TIME: u32 = 1000;
pub const LV_USE_ROLLER: u32 = 1;
pub const LV_ROLLER_DEF_ANIM_TIME: u32 = 200;
pub const LV_ROLLER_INF_PAGES: u32 = 7;
pub const LV_USE_SLIDER: u32 = 1;
pub const LV_USE_SPINBOX: u32 = 1;
pub const LV_USE_SW: u32 = 1;
pub const LV_USE_TA: u32 = 1;
pub const LV_TA_DEF_CURSOR_BLINK_TIME: u32 = 400;
pub const LV_TA_DEF_PWD_SHOW_TIME: u32 = 1500;
pub const LV_USE_TABLE: u32 = 1;
pub const LV_TABLE_COL_MAX: u32 = 12;
pub const LV_USE_TABVIEW: u32 = 1;
pub const LV_TABVIEW_DEF_ANIM_TIME: u32 = 300;
pub const LV_USE_TILEVIEW: u32 = 1;
pub const LV_TILEVIEW_DEF_ANIM_TIME: u32 = 300;
pub const LV_USE_WIN: u32 = 1;
pub const LV_LOG_LEVEL_TRACE: u32 = 0;
pub const LV_LOG_LEVEL_INFO: u32 = 1;
pub const LV_LOG_LEVEL_WARN: u32 = 2;
pub const LV_LOG_LEVEL_ERROR: u32 = 3;
pub const LV_LOG_LEVEL_NONE: u32 = 4;
pub const _LV_LOG_LEVEL_NUM: u32 = 5;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const LV_TRIGO_SIN_MAX: u32 = 32767;
pub const LV_TRIGO_SHIFT: u32 = 15;
pub const LV_BEZIER_VAL_MAX: u32 = 1024;
pub const LV_BEZIER_VAL_SHIFT: u32 = 10;
pub const LV_OPA_MIN: u32 = 16;
pub const LV_OPA_MAX: u32 = 251;
pub const LV_COLOR_SIZE: u32 = 16;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const LV_INV_BUF_SIZE: u32 = 32;
pub const LV_SYMBOL_AUDIO: &'static [u8; 4usize] = b"\xEF\x80\x81\0";
pub const LV_SYMBOL_VIDEO: &'static [u8; 4usize] = b"\xEF\x80\x88\0";
pub const LV_SYMBOL_LIST: &'static [u8; 4usize] = b"\xEF\x80\x8B\0";
pub const LV_SYMBOL_OK: &'static [u8; 4usize] = b"\xEF\x80\x8C\0";
pub const LV_SYMBOL_CLOSE: &'static [u8; 4usize] = b"\xEF\x80\x8D\0";
pub const LV_SYMBOL_POWER: &'static [u8; 4usize] = b"\xEF\x80\x91\0";
pub const LV_SYMBOL_SETTINGS: &'static [u8; 4usize] = b"\xEF\x80\x93\0";
pub const LV_SYMBOL_HOME: &'static [u8; 4usize] = b"\xEF\x80\x95\0";
pub const LV_SYMBOL_DOWNLOAD: &'static [u8; 4usize] = b"\xEF\x80\x99\0";
pub const LV_SYMBOL_DRIVE: &'static [u8; 4usize] = b"\xEF\x80\x9C\0";
pub const LV_SYMBOL_REFRESH: &'static [u8; 4usize] = b"\xEF\x80\xA1\0";
pub const LV_SYMBOL_MUTE: &'static [u8; 4usize] = b"\xEF\x80\xA6\0";
pub const LV_SYMBOL_VOLUME_MID: &'static [u8; 4usize] = b"\xEF\x80\xA7\0";
pub const LV_SYMBOL_VOLUME_MAX: &'static [u8; 4usize] = b"\xEF\x80\xA8\0";
pub const LV_SYMBOL_IMAGE: &'static [u8; 4usize] = b"\xEF\x80\xBE\0";
pub const LV_SYMBOL_EDIT: &'static [u8; 4usize] = b"\xEF\x8C\x84\0";
pub const LV_SYMBOL_PREV: &'static [u8; 4usize] = b"\xEF\x81\x88\0";
pub const LV_SYMBOL_PLAY: &'static [u8; 4usize] = b"\xEF\x81\x8B\0";
pub const LV_SYMBOL_PAUSE: &'static [u8; 4usize] = b"\xEF\x81\x8C\0";
pub const LV_SYMBOL_STOP: &'static [u8; 4usize] = b"\xEF\x81\x8D\0";
pub const LV_SYMBOL_NEXT: &'static [u8; 4usize] = b"\xEF\x81\x91\0";
pub const LV_SYMBOL_EJECT: &'static [u8; 4usize] = b"\xEF\x81\x92\0";
pub const LV_SYMBOL_LEFT: &'static [u8; 4usize] = b"\xEF\x81\x93\0";
pub const LV_SYMBOL_RIGHT: &'static [u8; 4usize] = b"\xEF\x81\x94\0";
pub const LV_SYMBOL_PLUS: &'static [u8; 4usize] = b"\xEF\x81\xA7\0";
pub const LV_SYMBOL_MINUS: &'static [u8; 4usize] = b"\xEF\x81\xA8\0";
pub const LV_SYMBOL_EYE_OPEN: &'static [u8; 4usize] = b"\xEF\x81\xAE\0";
pub const LV_SYMBOL_EYE_CLOSE: &'static [u8; 4usize] = b"\xEF\x81\xB0\0";
pub const LV_SYMBOL_WARNING: &'static [u8; 4usize] = b"\xEF\x81\xB1\0";
pub const LV_SYMBOL_SHUFFLE: &'static [u8; 4usize] = b"\xEF\x81\xB4\0";
pub const LV_SYMBOL_UP: &'static [u8; 4usize] = b"\xEF\x81\xB7\0";
pub const LV_SYMBOL_DOWN: &'static [u8; 4usize] = b"\xEF\x81\xB8\0";
pub const LV_SYMBOL_LOOP: &'static [u8; 4usize] = b"\xEF\x81\xB9\0";
pub const LV_SYMBOL_DIRECTORY: &'static [u8; 4usize] = b"\xEF\x81\xBB\0";
pub const LV_SYMBOL_UPLOAD: &'static [u8; 4usize] = b"\xEF\x82\x93\0";
pub const LV_SYMBOL_CALL: &'static [u8; 4usize] = b"\xEF\x82\x95\0";
pub const LV_SYMBOL_CUT: &'static [u8; 4usize] = b"\xEF\x83\x84\0";
pub const LV_SYMBOL_COPY: &'static [u8; 4usize] = b"\xEF\x83\x85\0";
pub const LV_SYMBOL_SAVE: &'static [u8; 4usize] = b"\xEF\x83\x87\0";
pub const LV_SYMBOL_CHARGE: &'static [u8; 4usize] = b"\xEF\x83\xA7\0";
pub const LV_SYMBOL_PASTE: &'static [u8; 4usize] = b"\xEF\x83\xAA\0";
pub const LV_SYMBOL_BELL: &'static [u8; 4usize] = b"\xEF\x83\xB3\0";
pub const LV_SYMBOL_KEYBOARD: &'static [u8; 4usize] = b"\xEF\x84\x9C\0";
pub const LV_SYMBOL_GPS: &'static [u8; 4usize] = b"\xEF\x84\xA4\0";
pub const LV_SYMBOL_FILE: &'static [u8; 4usize] = b"\xEF\x85\x9B\0";
pub const LV_SYMBOL_WIFI: &'static [u8; 4usize] = b"\xEF\x87\xAB\0";
pub const LV_SYMBOL_BATTERY_FULL: &'static [u8; 4usize] = b"\xEF\x89\x80\0";
pub const LV_SYMBOL_BATTERY_3: &'static [u8; 4usize] = b"\xEF\x89\x81\0";
pub const LV_SYMBOL_BATTERY_2: &'static [u8; 4usize] = b"\xEF\x89\x82\0";
pub const LV_SYMBOL_BATTERY_1: &'static [u8; 4usize] = b"\xEF\x89\x83\0";
pub const LV_SYMBOL_BATTERY_EMPTY: &'static [u8; 4usize] = b"\xEF\x89\x84\0";
pub const LV_SYMBOL_USB: &'static [u8; 4usize] = b"\xEF\x8A\x87\0";
pub const LV_SYMBOL_BLUETOOTH: &'static [u8; 4usize] = b"\xEF\x8A\x93\0";
pub const LV_SYMBOL_TRASH: &'static [u8; 4usize] = b"\xEF\x8B\xAD\0";
pub const LV_SYMBOL_BACKSPACE: &'static [u8; 4usize] = b"\xEF\x95\x9A\0";
pub const LV_SYMBOL_SD_CARD: &'static [u8; 4usize] = b"\xEF\x9F\x82\0";
pub const LV_SYMBOL_NEW_LINE: &'static [u8; 4usize] = b"\xEF\xA2\xA2\0";
pub const LV_SYMBOL_DUMMY: &'static [u8; 4usize] = b"\xEF\xA3\xBF\0";
pub const LV_FONT_WIDTH_FRACT_DIGIT: u32 = 4;
pub const LV_FONT_KERN_POSITIVE: u32 = 0;
pub const LV_FONT_KERN_NEGATIVE: u32 = 1;
pub const LV_STYLE_DEGUG_SENTINEL_VALUE: u32 = 305419896;
pub const LV_BIDI_LRO: &'static [u8; 4usize] = b"\xE2\x80\xAD\0";
pub const LV_BIDI_RLO: &'static [u8; 4usize] = b"\xE2\x80\xAE\0";
pub const LV_MAX_ANCESTOR_NUM: u32 = 8;
pub const LV_EXT_CLICK_AREA_OFF: u32 = 0;
pub const LV_EXT_CLICK_AREA_TINY: u32 = 1;
pub const LV_EXT_CLICK_AREA_FULL: u32 = 2;
pub const __GNUC_VA_LIST: u32 = 1;
pub const LV_TXT_ENC_UTF8: u32 = 1;
pub const LV_TXT_ENC_ASCII: u32 = 2;
pub const LV_IMG_PX_SIZE_ALPHA_BYTE: u32 = 3;
pub const LV_DRAW_LABEL_NO_TXT_SEL: u32 = 65535;
pub const LV_LABEL_DOT_NUM: u32 = 3;
pub const LV_LABEL_POS_LAST: u32 = 65535;
pub const LV_LABEL_TEXT_SEL_OFF: u32 = 65535;
pub const LV_CHART_TICK_LENGTH_AUTO: u32 = 255;
pub const LV_TABLE_CELL_STYLE_CNT: u32 = 4;
pub const LV_BAR_ANIM_STATE_START: u32 = 0;
pub const LV_BAR_ANIM_STATE_END: u32 = 256;
pub const LV_BAR_ANIM_STATE_INV: i32 = -1;
pub const LV_BAR_ANIM_STATE_NORM: u32 = 8;
pub const LV_BTNM_WIDTH_MASK: u32 = 7;
pub const LV_BTNM_BTN_NONE: u32 = 65535;
pub const LV_TA_CURSOR_LAST: u32 = 32767;
pub const LV_SW_MAX_VALUE: u32 = 100;
pub const LV_SPINBOX_MAX_DIGIT_COUNT: u32 = 16;
pub type __u_char = cty::c_uchar;
pub type __u_short = cty::c_ushort;
pub type __u_int = cty::c_uint;
pub type __u_long = cty::c_ulong;
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_long;
pub type __uint64_t = cty::c_ulong;
pub type __quad_t = cty::c_long;
pub type __u_quad_t = cty::c_ulong;
pub type __intmax_t = cty::c_long;
pub type __uintmax_t = cty::c_ulong;
pub type __dev_t = cty::c_ulong;
pub type __uid_t = cty::c_uint;
pub type __gid_t = cty::c_uint;
pub type __ino_t = cty::c_ulong;
pub type __ino64_t = cty::c_ulong;
pub type __mode_t = cty::c_uint;
pub type __nlink_t = cty::c_ulong;
pub type __off_t = cty::c_long;
pub type __off64_t = cty::c_long;
pub type __pid_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [cty::c_int; 2usize],
}
pub type __clock_t = cty::c_long;
pub type __rlim_t = cty::c_ulong;
pub type __rlim64_t = cty::c_ulong;
pub type __id_t = cty::c_uint;
pub type __time_t = cty::c_long;
pub type __useconds_t = cty::c_uint;
pub type __suseconds_t = cty::c_long;
pub type __daddr_t = cty::c_int;
pub type __key_t = cty::c_int;
pub type __clockid_t = cty::c_int;
pub type __timer_t = *mut cty::c_void;
pub type __blksize_t = cty::c_long;
pub type __blkcnt_t = cty::c_long;
pub type __blkcnt64_t = cty::c_long;
pub type __fsblkcnt_t = cty::c_ulong;
pub type __fsblkcnt64_t = cty::c_ulong;
pub type __fsfilcnt_t = cty::c_ulong;
pub type __fsfilcnt64_t = cty::c_ulong;
pub type __fsword_t = cty::c_long;
pub type __ssize_t = cty::c_long;
pub type __syscall_slong_t = cty::c_long;
pub type __syscall_ulong_t = cty::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut cty::c_char;
pub type __intptr_t = cty::c_long;
pub type __socklen_t = cty::c_uint;
pub type __sig_atomic_t = cty::c_int;
pub type int_least8_t = cty::c_schar;
pub type int_least16_t = cty::c_short;
pub type int_least32_t = cty::c_int;
pub type int_least64_t = cty::c_long;
pub type uint_least8_t = cty::c_uchar;
pub type uint_least16_t = cty::c_ushort;
pub type uint_least32_t = cty::c_uint;
pub type uint_least64_t = cty::c_ulong;
pub type int_fast8_t = cty::c_schar;
pub type int_fast16_t = cty::c_long;
pub type int_fast32_t = cty::c_long;
pub type int_fast64_t = cty::c_long;
pub type uint_fast8_t = cty::c_uchar;
pub type uint_fast16_t = cty::c_ulong;
pub type uint_fast32_t = cty::c_ulong;
pub type uint_fast64_t = cty::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type lv_coord_t = i16;
pub type lv_anim_user_data_t = *mut cty::c_void;
pub type lv_group_user_data_t = *mut cty::c_void;
pub type lv_img_decoder_user_data_t = *mut cty::c_void;
pub type lv_disp_drv_user_data_t = *mut cty::c_void;
pub type lv_indev_drv_user_data_t = *mut cty::c_void;
pub type lv_font_user_data_t = *mut cty::c_void;
pub type lv_obj_user_data_t = *mut cty::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _silence_gcc_warning {
    _unused: [u8; 0],
}
pub type lv_log_level_t = i8;
pub type size_t = cty::c_ulong;
pub type wchar_t = cty::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: cty::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
pub const LV_RES_INV: _bindgen_ty_1 = 0;
pub const LV_RES_OK: _bindgen_ty_1 = 1;
#[doc = " LittlevGL error codes."]
pub type _bindgen_ty_1 = u32;
pub type lv_res_t = u8;
pub type lv_uintptr_t = u64;
#[doc = " Heap information structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_mem_monitor_t {
    #[doc = "< Total heap size"]
    pub total_size: u32,
    pub free_cnt: u32,
    #[doc = "< Size of available memory"]
    pub free_size: u32,
    pub free_biggest_size: u32,
    pub used_cnt: u32,
    #[doc = "< Percentage used"]
    pub used_pct: u8,
    #[doc = "< Amount of fragmentation"]
    pub frag_pct: u8,
}
extern "C" {
    #[doc = " Initiaize the dyn_mem module (work memory and other variables)"]
    pub fn lv_mem_init();
}
extern "C" {
    #[doc = " Clean up the memory buffer which frees all the allocated memories."]
    #[doc = " @note It work only if `LV_MEM_CUSTOM == 0`"]
    pub fn lv_mem_deinit();
}
extern "C" {
    #[doc = " Allocate a memory dynamically"]
    #[doc = " @param size size of the memory to allocate in bytes"]
    #[doc = " @return pointer to the allocated memory"]
    pub fn lv_mem_alloc(size: size_t) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Free an allocated data"]
    #[doc = " @param data pointer to an allocated memory"]
    pub fn lv_mem_free(data: *const cty::c_void);
}
extern "C" {
    #[doc = " Reallocate a memory with a new size. The old content will be kept."]
    #[doc = " @param data pointer to an allocated memory."]
    #[doc = " Its content will be copied to the new memory block and freed"]
    #[doc = " @param new_size the desired new size in byte"]
    #[doc = " @return pointer to the new memory"]
    pub fn lv_mem_realloc(data_p: *mut cty::c_void, new_size: size_t) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Join the adjacent free memory blocks"]
    pub fn lv_mem_defrag();
}
extern "C" {
    #[doc = " Give information about the work memory of dynamic allocation"]
    #[doc = " @param mon_p pointer to a dm_mon_p variable,"]
    #[doc = "              the result of the analysis will be stored here"]
    pub fn lv_mem_monitor(mon_p: *mut lv_mem_monitor_t);
}
extern "C" {
    #[doc = " Give the size of an allocated memory"]
    #[doc = " @param data pointer to an allocated memory"]
    #[doc = " @return the size of data memory in bytes"]
    pub fn lv_mem_get_size(data: *const cty::c_void) -> u32;
}
#[doc = " Dummy type to make handling easier"]
pub type lv_ll_node_t = u8;
#[doc = " Description of a linked list"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_ll_t {
    pub n_size: u32,
    pub head: *mut lv_ll_node_t,
    pub tail: *mut lv_ll_node_t,
}
extern "C" {
    #[doc = " Initialize linked list"]
    #[doc = " @param ll_dsc pointer to ll_dsc variable"]
    #[doc = " @param node_size the size of 1 node in bytes"]
    pub fn lv_ll_init(ll_p: *mut lv_ll_t, node_size: u32);
}
extern "C" {
    #[doc = " Add a new head to a linked list"]
    #[doc = " @param ll_p pointer to linked list"]
    #[doc = " @return pointer to the new head"]
    pub fn lv_ll_ins_head(ll_p: *mut lv_ll_t) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Insert a new node in front of the n_act node"]
    #[doc = " @param ll_p pointer to linked list"]
    #[doc = " @param n_act pointer a node"]
    #[doc = " @return pointer to the new head"]
    pub fn lv_ll_ins_prev(ll_p: *mut lv_ll_t, n_act: *mut cty::c_void) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Add a new tail to a linked list"]
    #[doc = " @param ll_p pointer to linked list"]
    #[doc = " @return pointer to the new tail"]
    pub fn lv_ll_ins_tail(ll_p: *mut lv_ll_t) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Remove the node 'node_p' from 'll_p' linked list."]
    #[doc = " It does not free the the memory of node."]
    #[doc = " @param ll_p pointer to the linked list of 'node_p'"]
    #[doc = " @param node_p pointer to node in 'll_p' linked list"]
    pub fn lv_ll_rem(ll_p: *mut lv_ll_t, node_p: *mut cty::c_void);
}
extern "C" {
    #[doc = " Remove and free all elements from a linked list. The list remain valid but become empty."]
    #[doc = " @param ll_p pointer to linked list"]
    pub fn lv_ll_clear(ll_p: *mut lv_ll_t);
}
extern "C" {
    #[doc = " Move a node to a new linked list"]
    #[doc = " @param ll_ori_p pointer to the original (old) linked list"]
    #[doc = " @param ll_new_p pointer to the new linked list"]
    #[doc = " @param node pointer to a node"]
    #[doc = " @param head true: be the head in the new list"]
    #[doc = "             false be the head in the new list"]
    pub fn lv_ll_chg_list(
        ll_ori_p: *mut lv_ll_t,
        ll_new_p: *mut lv_ll_t,
        node: *mut cty::c_void,
        head: bool,
    );
}
extern "C" {
    #[doc = " Return with head node of the linked list"]
    #[doc = " @param ll_p pointer to linked list"]
    #[doc = " @return pointer to the head of 'll_p'"]
    pub fn lv_ll_get_head(ll_p: *const lv_ll_t) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Return with tail node of the linked list"]
    #[doc = " @param ll_p pointer to linked list"]
    #[doc = " @return pointer to the head of 'll_p'"]
    pub fn lv_ll_get_tail(ll_p: *const lv_ll_t) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Return with the pointer of the next node after 'n_act'"]
    #[doc = " @param ll_p pointer to linked list"]
    #[doc = " @param n_act pointer a node"]
    #[doc = " @return pointer to the next node"]
    pub fn lv_ll_get_next(ll_p: *const lv_ll_t, n_act: *const cty::c_void) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Return with the pointer of the previous node after 'n_act'"]
    #[doc = " @param ll_p pointer to linked list"]
    #[doc = " @param n_act pointer a node"]
    #[doc = " @return pointer to the previous node"]
    pub fn lv_ll_get_prev(ll_p: *const lv_ll_t, n_act: *const cty::c_void) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Return the length of the linked list."]
    #[doc = " @param ll_p pointer to linked list"]
    #[doc = " @return length of the linked list"]
    pub fn lv_ll_get_len(ll_p: *const lv_ll_t) -> u32;
}
extern "C" {
    #[doc = " Move a nodw before an other node in the same linked list"]
    #[doc = " @param ll_p pointer to a linked list"]
    #[doc = " @param n_act pointer to node to move"]
    #[doc = " @param n_after pointer to a node which should be after `n_act`"]
    pub fn lv_ll_move_before(
        ll_p: *mut lv_ll_t,
        n_act: *mut cty::c_void,
        n_after: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " Check if a linked list is empty"]
    #[doc = " @param ll_p pointer to a linked list"]
    #[doc = " @return true: the linked list is empty; false: not empty"]
    pub fn lv_ll_is_empty(ll_p: *mut lv_ll_t) -> bool;
}
#[doc = " Tasks execute this type type of functions."]
pub type lv_task_cb_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_task_t)>;
pub const LV_TASK_PRIO_OFF: _bindgen_ty_2 = 0;
pub const LV_TASK_PRIO_LOWEST: _bindgen_ty_2 = 1;
pub const LV_TASK_PRIO_LOW: _bindgen_ty_2 = 2;
pub const LV_TASK_PRIO_MID: _bindgen_ty_2 = 3;
pub const LV_TASK_PRIO_HIGH: _bindgen_ty_2 = 4;
pub const LV_TASK_PRIO_HIGHEST: _bindgen_ty_2 = 5;
pub const _LV_TASK_PRIO_NUM: _bindgen_ty_2 = 6;
#[doc = " Possible priorities for lv_tasks"]
pub type _bindgen_ty_2 = u32;
pub type lv_task_prio_t = u8;
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_task_t {
    #[doc = "< How often the task should run"]
    pub period: u32,
    #[doc = "< Last time the task ran"]
    pub last_run: u32,
    #[doc = "< Task function"]
    pub task_cb: lv_task_cb_t,
    #[doc = "< Custom user data"]
    pub user_data: *mut cty::c_void,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl _lv_task_t {
    #[inline]
    pub fn prio(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_prio(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn once(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_once(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(prio: u8, once: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let prio: u8 = unsafe { ::core::mem::transmute(prio) };
            prio as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let once: u8 = unsafe { ::core::mem::transmute(once) };
            once as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_task_t = _lv_task_t;
extern "C" {
    #[doc = " Init the lv_task module"]
    pub fn lv_task_core_init();
}
extern "C" {
    #[doc = " Call it  periodically to handle lv_tasks."]
    pub fn lv_task_handler();
}
extern "C" {
    #[doc = " Create an \"empty\" task. It needs to initialzed with at least"]
    #[doc = " `lv_task_set_cb` and `lv_task_set_period`"]
    #[doc = " @return pointer to the craeted task"]
    pub fn lv_task_create_basic() -> *mut lv_task_t;
}
extern "C" {
    #[doc = " Create a new lv_task"]
    #[doc = " @param task_xcb a callback which is the task itself. It will be called periodically."]
    #[doc = "                 (the 'x' in the argument name indicates that its not a fully generic function because it not follows"]
    #[doc = "                  the `func_name(object, callback, ...)` convention)"]
    #[doc = " @param period call period in ms unit"]
    #[doc = " @param prio priority of the task (LV_TASK_PRIO_OFF means the task is stopped)"]
    #[doc = " @param user_data custom parameter"]
    #[doc = " @return pointer to the new task"]
    pub fn lv_task_create(
        task_xcb: lv_task_cb_t,
        period: u32,
        prio: lv_task_prio_t,
        user_data: *mut cty::c_void,
    ) -> *mut lv_task_t;
}
extern "C" {
    #[doc = " Delete a lv_task"]
    #[doc = " @param task pointer to task_cb created by task"]
    pub fn lv_task_del(task: *mut lv_task_t);
}
extern "C" {
    #[doc = " Set the callback the task (the function to call periodically)"]
    #[doc = " @param task pointer to a task"]
    #[doc = " @param task_cb the function to call periodically"]
    pub fn lv_task_set_cb(task: *mut lv_task_t, task_cb: lv_task_cb_t);
}
extern "C" {
    #[doc = " Set new priority for a lv_task"]
    #[doc = " @param task pointer to a lv_task"]
    #[doc = " @param prio the new priority"]
    pub fn lv_task_set_prio(task: *mut lv_task_t, prio: lv_task_prio_t);
}
extern "C" {
    #[doc = " Set new period for a lv_task"]
    #[doc = " @param task pointer to a lv_task"]
    #[doc = " @param period the new period"]
    pub fn lv_task_set_period(task: *mut lv_task_t, period: u32);
}
extern "C" {
    #[doc = " Make a lv_task ready. It will not wait its period."]
    #[doc = " @param task pointer to a lv_task."]
    pub fn lv_task_ready(task: *mut lv_task_t);
}
extern "C" {
    #[doc = " Delete the lv_task after one call"]
    #[doc = " @param task pointer to a lv_task."]
    pub fn lv_task_once(task: *mut lv_task_t);
}
extern "C" {
    #[doc = " Reset a lv_task."]
    #[doc = " It will be called the previously set period milliseconds later."]
    #[doc = " @param task pointer to a lv_task."]
    pub fn lv_task_reset(task: *mut lv_task_t);
}
extern "C" {
    #[doc = " Enable or disable the whole  lv_task handling"]
    #[doc = " @param en: true: lv_task handling is running, false: lv_task handling is suspended"]
    pub fn lv_task_enable(en: bool);
}
extern "C" {
    #[doc = " Get idle percentage"]
    #[doc = " @return the lv_task idle in percentage"]
    pub fn lv_task_get_idle() -> u8;
}
extern "C" {
    #[doc = " Return with sinus of an angle"]
    #[doc = " @param angle"]
    #[doc = " @return sinus of 'angle'. sin(-90) = -32767, sin(90) = 32767"]
    pub fn lv_trigo_sin(angle: i16) -> i16;
}
extern "C" {
    #[doc = " Calculate a value of a Cubic Bezier function."]
    #[doc = " @param t time in range of [0..LV_BEZIER_VAL_MAX]"]
    #[doc = " @param u0 start values in range of [0..LV_BEZIER_VAL_MAX]"]
    #[doc = " @param u1 control value 1 values in range of [0..LV_BEZIER_VAL_MAX]"]
    #[doc = " @param u2 control value 2 in range of [0..LV_BEZIER_VAL_MAX]"]
    #[doc = " @param u3 end values in range of [0..LV_BEZIER_VAL_MAX]"]
    #[doc = " @return the value calculated from the given parameters in range of [0..LV_BEZIER_VAL_MAX]"]
    pub fn lv_bezier3(t: u32, u0: i32, u1: i32, u2: i32, u3: i32) -> i32;
}
extern "C" {
    #[doc = " Calculate the atan2 of a vector."]
    #[doc = " @param x"]
    #[doc = " @param y"]
    #[doc = " @return the angle in degree calculated from the given parameters in range of [0..360]"]
    pub fn lv_atan2(x: cty::c_int, y: cty::c_int) -> u16;
}
extern "C" {
    #[doc = " Calculate the integer square root of a number."]
    #[doc = " @param num"]
    #[doc = " @return square root of 'num'"]
    pub fn lv_sqrt(num: u32) -> u32;
}
#[doc = " Type for async callback."]
pub type lv_async_cb_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_async_info_t {
    pub cb: lv_async_cb_t,
    pub user_data: *mut cty::c_void,
}
pub type lv_async_info_t = _lv_async_info_t;
extern "C" {
    #[doc = " Call an asynchronous function the next time lv_task_handler() is run. This function is likely to return"]
    #[doc = " **before** the call actually happens!"]
    #[doc = " @param task_xcb a callback which is the task itself."]
    #[doc = "                 (the 'x' in the argument name indicates that its not a fully generic function because it not follows"]
    #[doc = "                  the `func_name(object, callback, ...)` convention)"]
    #[doc = " @param user_data custom parameter"]
    pub fn lv_async_call(async_xcb: lv_async_cb_t, user_data: *mut cty::c_void) -> lv_res_t;
}
pub const LV_OPA_TRANSP: _bindgen_ty_3 = 0;
pub const LV_OPA_0: _bindgen_ty_3 = 0;
pub const LV_OPA_10: _bindgen_ty_3 = 25;
pub const LV_OPA_20: _bindgen_ty_3 = 51;
pub const LV_OPA_30: _bindgen_ty_3 = 76;
pub const LV_OPA_40: _bindgen_ty_3 = 102;
pub const LV_OPA_50: _bindgen_ty_3 = 127;
pub const LV_OPA_60: _bindgen_ty_3 = 153;
pub const LV_OPA_70: _bindgen_ty_3 = 178;
pub const LV_OPA_80: _bindgen_ty_3 = 204;
pub const LV_OPA_90: _bindgen_ty_3 = 229;
pub const LV_OPA_100: _bindgen_ty_3 = 255;
pub const LV_OPA_COVER: _bindgen_ty_3 = 255;
#[doc = " Opacity percentages."]
pub type _bindgen_ty_3 = u32;
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union lv_color1_t {
    pub ch: lv_color1_t__bindgen_ty_1,
    pub full: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct lv_color1_t__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl lv_color1_t__bindgen_ty_1 {
    #[inline]
    pub fn blue(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_blue(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn green(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_green(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn red(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_red(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(blue: u8, green: u8, red: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let blue: u8 = unsafe { ::core::mem::transmute(blue) };
            blue as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let green: u8 = unsafe { ::core::mem::transmute(green) };
            green as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let red: u8 = unsafe { ::core::mem::transmute(red) };
            red as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lv_color8_t {
    pub ch: lv_color8_t__bindgen_ty_1,
    pub full: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct lv_color8_t__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl lv_color8_t__bindgen_ty_1 {
    #[inline]
    pub fn blue(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_blue(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn green(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_green(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn red(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_red(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(blue: u8, green: u8, red: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let blue: u8 = unsafe { ::core::mem::transmute(blue) };
            blue as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let green: u8 = unsafe { ::core::mem::transmute(green) };
            green as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let red: u8 = unsafe { ::core::mem::transmute(red) };
            red as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lv_color16_t {
    pub ch: lv_color16_t__bindgen_ty_1,
    pub full: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct lv_color16_t__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
impl lv_color16_t__bindgen_ty_1 {
    #[inline]
    pub fn blue(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_blue(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn green(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_green(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn red(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_red(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        blue: u16,
        green: u16,
        red: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let blue: u16 = unsafe { ::core::mem::transmute(blue) };
            blue as u64
        });
        __bindgen_bitfield_unit.set(5usize, 6u8, {
            let green: u16 = unsafe { ::core::mem::transmute(green) };
            green as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let red: u16 = unsafe { ::core::mem::transmute(red) };
            red as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lv_color32_t {
    pub ch: lv_color32_t__bindgen_ty_1,
    pub full: u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_color32_t__bindgen_ty_1 {
    pub blue: u8,
    pub green: u8,
    pub red: u8,
    pub alpha: u8,
}
pub type lv_color_int_t = u16;
pub type lv_color_t = lv_color16_t;
pub type lv_opa_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_color_hsv_t {
    pub h: u16,
    pub s: u8,
    pub v: u8,
}
extern "C" {
    #[doc = " Convert a HSV color to RGB"]
    #[doc = " @param h hue [0..359]"]
    #[doc = " @param s saturation [0..100]"]
    #[doc = " @param v value [0..100]"]
    #[doc = " @return the given RGB color in RGB (with LV_COLOR_DEPTH depth)"]
    pub fn lv_color_hsv_to_rgb(h: u16, s: u8, v: u8) -> lv_color_t;
}
extern "C" {
    #[doc = " Convert a 32-bit RGB color to HSV"]
    #[doc = " @param r8 8-bit red"]
    #[doc = " @param g8 8-bit green"]
    #[doc = " @param b8 8-bit blue"]
    #[doc = " @return the given RGB color in HSV"]
    pub fn lv_color_rgb_to_hsv(r8: u8, g8: u8, b8: u8) -> lv_color_hsv_t;
}
extern "C" {
    #[doc = " Convert a color to HSV"]
    #[doc = " @param color color"]
    #[doc = " @return the given color in HSV"]
    pub fn lv_color_to_hsv(color: lv_color_t) -> lv_color_hsv_t;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut cty::c_void,
        __src: *const cty::c_void,
        __n: cty::c_ulong,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut cty::c_void,
        __src: *const cty::c_void,
        __n: cty::c_ulong,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut cty::c_void,
        __src: *const cty::c_void,
        __c: cty::c_int,
        __n: size_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memset(__s: *mut cty::c_void, __c: cty::c_int, __n: cty::c_ulong) -> *mut cty::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const cty::c_void,
        __s2: *const cty::c_void,
        __n: cty::c_ulong,
    ) -> cty::c_int;
}
extern "C" {
    pub fn memchr(__s: *const cty::c_void, __c: cty::c_int, __n: cty::c_ulong) -> *mut cty::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut cty::c_char, __src: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: cty::c_ulong,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut cty::c_char, __src: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: cty::c_ulong,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const cty::c_char, __s2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __n: cty::c_ulong,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const cty::c_char, __s2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: cty::c_ulong,
    ) -> cty::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const cty::c_ushort,
    pub __ctype_tolower: *const cty::c_int,
    pub __ctype_toupper: *const cty::c_int,
    pub __names: [*const cty::c_char; 13usize],
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __l: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strndup(__string: *const cty::c_char, __n: cty::c_ulong) -> *mut cty::c_char;
}
extern "C" {
    pub fn strchr(__s: *const cty::c_char, __c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const cty::c_char, __c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const cty::c_char, __reject: *const cty::c_char) -> cty::c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const cty::c_char, __accept: *const cty::c_char) -> cty::c_ulong;
}
extern "C" {
    pub fn strpbrk(__s: *const cty::c_char, __accept: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strstr(__haystack: *const cty::c_char, __needle: *const cty::c_char)
        -> *mut cty::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut cty::c_char, __delim: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut cty::c_char,
        __delim: *const cty::c_char,
        __save_ptr: *mut *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut cty::c_char,
        __delim: *const cty::c_char,
        __save_ptr: *mut *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strlen(__s: *const cty::c_char) -> cty::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const cty::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: cty::c_int,
        __buf: *mut cty::c_char,
        __buflen: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: cty::c_int, __l: locale_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const cty::c_void,
        __s2: *const cty::c_void,
        __n: cty::c_ulong,
    ) -> cty::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const cty::c_void, __dest: *mut cty::c_void, __n: size_t);
}
extern "C" {
    pub fn bzero(__s: *mut cty::c_void, __n: cty::c_ulong);
}
extern "C" {
    pub fn index(__s: *const cty::c_char, __c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn rindex(__s: *const cty::c_char, __c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn ffs(__i: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ffsl(__l: cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn ffsll(__ll: cty::c_longlong) -> cty::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const cty::c_char, __s2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __n: cty::c_ulong,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __loc: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut cty::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut cty::c_char,
        __delim: *const cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strsignal(__sig: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut cty::c_char, __src: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut cty::c_char, __src: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: size_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: cty::c_ulong,
    ) -> *mut cty::c_char;
}
#[doc = " Represents a point on the screen."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_point_t {
    pub x: lv_coord_t,
    pub y: lv_coord_t,
}
#[doc = " Represents an area of the screen."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_area_t {
    pub x1: lv_coord_t,
    pub y1: lv_coord_t,
    pub x2: lv_coord_t,
    pub y2: lv_coord_t,
}
extern "C" {
    #[doc = " Initialize an area"]
    #[doc = " @param area_p pointer to an area"]
    #[doc = " @param x1 left coordinate of the area"]
    #[doc = " @param y1 top coordinate of the area"]
    #[doc = " @param x2 right coordinate of the area"]
    #[doc = " @param y2 bottom coordinate of the area"]
    pub fn lv_area_set(
        area_p: *mut lv_area_t,
        x1: lv_coord_t,
        y1: lv_coord_t,
        x2: lv_coord_t,
        y2: lv_coord_t,
    );
}
extern "C" {
    #[doc = " Set the width of an area"]
    #[doc = " @param area_p pointer to an area"]
    #[doc = " @param w the new width of the area (w == 1 makes x1 == x2)"]
    pub fn lv_area_set_width(area_p: *mut lv_area_t, w: lv_coord_t);
}
extern "C" {
    #[doc = " Set the height of an area"]
    #[doc = " @param area_p pointer to an area"]
    #[doc = " @param h the new height of the area (h == 1 makes y1 == y2)"]
    pub fn lv_area_set_height(area_p: *mut lv_area_t, h: lv_coord_t);
}
extern "C" {
    #[doc = " Set the position of an area (width and height will be kept)"]
    #[doc = " @param area_p pointer to an area"]
    #[doc = " @param x the new x coordinate of the area"]
    #[doc = " @param y the new y coordinate of the area"]
    pub fn lv_area_set_pos(area_p: *mut lv_area_t, x: lv_coord_t, y: lv_coord_t);
}
extern "C" {
    #[doc = " Return with area of an area (x * y)"]
    #[doc = " @param area_p pointer to an area"]
    #[doc = " @return size of area"]
    pub fn lv_area_get_size(area_p: *const lv_area_t) -> u32;
}
extern "C" {
    #[doc = " Get the common parts of two areas"]
    #[doc = " @param res_p pointer to an area, the result will be stored her"]
    #[doc = " @param a1_p pointer to the first area"]
    #[doc = " @param a2_p pointer to the second area"]
    #[doc = " @return false: the two area has NO common parts, res_p is invalid"]
    pub fn lv_area_intersect(
        res_p: *mut lv_area_t,
        a1_p: *const lv_area_t,
        a2_p: *const lv_area_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Join two areas into a third which involves the other two"]
    #[doc = " @param res_p pointer to an area, the result will be stored here"]
    #[doc = " @param a1_p pointer to the first area"]
    #[doc = " @param a2_p pointer to the second area"]
    pub fn lv_area_join(a_res_p: *mut lv_area_t, a1_p: *const lv_area_t, a2_p: *const lv_area_t);
}
extern "C" {
    #[doc = " Check if a point is on an area"]
    #[doc = " @param a_p pointer to an area"]
    #[doc = " @param p_p pointer to a point"]
    #[doc = " @return false:the point is out of the area"]
    pub fn lv_area_is_point_on(a_p: *const lv_area_t, p_p: *const lv_point_t) -> bool;
}
extern "C" {
    #[doc = " Check if two area has common parts"]
    #[doc = " @param a1_p pointer to an area."]
    #[doc = " @param a2_p pointer to an other area"]
    #[doc = " @return false: a1_p and a2_p has no common parts"]
    pub fn lv_area_is_on(a1_p: *const lv_area_t, a2_p: *const lv_area_t) -> bool;
}
extern "C" {
    #[doc = " Check if an area is fully on an other"]
    #[doc = " @param ain_p pointer to an area which could be on aholder_p"]
    #[doc = " @param aholder pointer to an area which could involve ain_p"]
    #[doc = " @return"]
    pub fn lv_area_is_in(ain_p: *const lv_area_t, aholder_p: *const lv_area_t) -> bool;
}
extern "C" {
    #[doc = " Increment or decrement an area's size by a single amount"]
    #[doc = " @param a_p pointer to an area to grow"]
    #[doc = " @param amount amount to increment the area, or negative to decrement"]
    pub fn lv_area_increment(a_p: *mut lv_area_t, amount: lv_coord_t);
}
#[doc = " Structure for holding display buffer information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_disp_buf_t {
    #[doc = "< First display buffer."]
    pub buf1: *mut cty::c_void,
    #[doc = "< Second display buffer."]
    pub buf2: *mut cty::c_void,
    pub buf_act: *mut cty::c_void,
    pub size: u32,
    pub area: lv_area_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl lv_disp_buf_t {
    #[inline]
    pub fn flushing(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flushing(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(flushing: u32) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let flushing: u32 = unsafe { ::core::mem::transmute(flushing) };
            flushing as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Display Driver structure to be registered by HAL"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _disp_drv_t {
    #[doc = "< Horizontal resolution."]
    pub hor_res: lv_coord_t,
    #[doc = "< Vertical resolution."]
    pub ver_res: lv_coord_t,
    #[doc = " Pointer to a buffer initialized with `lv_disp_buf_init()`."]
    #[doc = " LittlevGL will use this buffer(s) to draw the screens contents"]
    pub buffer: *mut lv_disp_buf_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = " MANDATORY: Write the internal buffer (VDB) to the display. 'lv_disp_flush_ready()' has to be"]
    #[doc = " called when finished"]
    pub flush_cb: ::core::option::Option<
        unsafe extern "C" fn(
            disp_drv: *mut _disp_drv_t,
            area: *const lv_area_t,
            color_p: *mut lv_color_t,
        ),
    >,
    #[doc = " OPTIONAL: Extend the invalidated areas to match with the display drivers requirements"]
    #[doc = " E.g. round `y` to, 8, 16 ..) on a monochrome display"]
    pub rounder_cb: ::core::option::Option<
        unsafe extern "C" fn(disp_drv: *mut _disp_drv_t, area: *mut lv_area_t),
    >,
    #[doc = " OPTIONAL: Set a pixel in a buffer according to the special requirements of the display"]
    #[doc = " Can be used for color format not supported in LittelvGL. E.g. 2 bit -> 4 gray scales"]
    #[doc = " @note Much slower then drawing with supported color formats."]
    pub set_px_cb: ::core::option::Option<
        unsafe extern "C" fn(
            disp_drv: *mut _disp_drv_t,
            buf: *mut u8,
            buf_w: lv_coord_t,
            x: lv_coord_t,
            y: lv_coord_t,
            color: lv_color_t,
            opa: lv_opa_t,
        ),
    >,
    #[doc = " OPTIONAL: Called after every refresh cycle to tell the rendering and flushing time + the"]
    #[doc = " number of flushed pixels"]
    pub monitor_cb: ::core::option::Option<
        unsafe extern "C" fn(disp_drv: *mut _disp_drv_t, time: u32, px: u32),
    >,
    #[doc = " On CHROMA_KEYED images this color will be transparent."]
    #[doc = " `LV_COLOR_TRANSP` by default. (lv_conf.h)"]
    pub color_chroma_key: lv_color_t,
    #[doc = "< Custom display driver user data"]
    pub user_data: lv_disp_drv_user_data_t,
}
impl _disp_drv_t {
    #[inline]
    pub fn antialiasing(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_antialiasing(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rotated(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rotated(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        antialiasing: u32,
        rotated: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let antialiasing: u32 = unsafe { ::core::mem::transmute(antialiasing) };
            antialiasing as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rotated: u32 = unsafe { ::core::mem::transmute(rotated) };
            rotated as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_disp_drv_t = _disp_drv_t;
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _disp_t {
    pub driver: lv_disp_drv_t,
    pub refr_task: *mut lv_task_t,
    #[doc = " Screens of the display"]
    pub scr_ll: lv_ll_t,
    #[doc = "< Currently active screen on this display"]
    pub act_scr: *mut _lv_obj_t,
    #[doc = "< @see lv_disp_get_layer_top"]
    pub top_layer: *mut _lv_obj_t,
    #[doc = "< @see lv_disp_get_layer_sys"]
    pub sys_layer: *mut _lv_obj_t,
    #[doc = " Invalidated (marked to redraw) areas"]
    pub inv_areas: [lv_area_t; 32usize],
    pub inv_area_joined: [u8; 32usize],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    #[doc = "< Last time there was activity on this display"]
    pub last_activity_time: u32,
}
impl _disp_t {
    #[inline]
    pub fn inv_p(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_inv_p(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(inv_p: u32) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let inv_p: u32 = unsafe { ::core::mem::transmute(inv_p) };
            inv_p as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_disp_t = _disp_t;
extern "C" {
    #[doc = " Initialize a display driver with default values."]
    #[doc = " It is used to have known values in the fields and not junk in memory."]
    #[doc = " After it you can safely set only the fields you need."]
    #[doc = " @param driver pointer to driver variable to initialize"]
    pub fn lv_disp_drv_init(driver: *mut lv_disp_drv_t);
}
extern "C" {
    #[doc = " Initialize a display buffer"]
    #[doc = " @param disp_buf pointer `lv_disp_buf_t` variable to initialize"]
    #[doc = " @param buf1 A buffer to be used by LittlevGL to draw the image."]
    #[doc = "             Always has to specified and can't be NULL."]
    #[doc = "             Can be an array allocated by the user. E.g. `static lv_color_t disp_buf1[1024 * 10]`"]
    #[doc = "             Or a memory address e.g. in external SRAM"]
    #[doc = " @param buf2 Optionally specify a second buffer to make image rendering and image flushing"]
    #[doc = "             (sending to the display) parallel."]
    #[doc = "             In the `disp_drv->flush` you should use DMA or similar hardware to send"]
    #[doc = "             the image to the display in the background."]
    #[doc = "             It lets LittlevGL to render next frame into the other buffer while previous is being"]
    #[doc = " sent. Set to `NULL` if unused."]
    #[doc = " @param size_in_px_cnt size of the `buf1` and `buf2` in pixel count."]
    pub fn lv_disp_buf_init(
        disp_buf: *mut lv_disp_buf_t,
        buf1: *mut cty::c_void,
        buf2: *mut cty::c_void,
        size_in_px_cnt: u32,
    );
}
extern "C" {
    #[doc = " Register an initialized display driver."]
    #[doc = " Automatically set the first display as active."]
    #[doc = " @param driver pointer to an initialized 'lv_disp_drv_t' variable (can be local variable)"]
    #[doc = " @return pointer to the new display or NULL on error"]
    pub fn lv_disp_drv_register(driver: *mut lv_disp_drv_t) -> *mut lv_disp_t;
}
extern "C" {
    #[doc = " Update the driver in run time."]
    #[doc = " @param disp pointer to a display. (return value of `lv_disp_drv_register`)"]
    #[doc = " @param new_drv pointer to the new driver"]
    pub fn lv_disp_drv_update(disp: *mut lv_disp_t, new_drv: *mut lv_disp_drv_t);
}
extern "C" {
    #[doc = " Remove a display"]
    #[doc = " @param disp pointer to display"]
    pub fn lv_disp_remove(disp: *mut lv_disp_t);
}
extern "C" {
    #[doc = " Set a default screen. The new screens will be created on it by default."]
    #[doc = " @param disp pointer to a display"]
    pub fn lv_disp_set_default(disp: *mut lv_disp_t);
}
extern "C" {
    #[doc = " Get the default display"]
    #[doc = " @return pointer to the default display"]
    pub fn lv_disp_get_default() -> *mut lv_disp_t;
}
extern "C" {
    #[doc = " Get the horizontal resolution of a display"]
    #[doc = " @param disp pointer to a display (NULL to use the default display)"]
    #[doc = " @return the horizontal resolution of the display"]
    pub fn lv_disp_get_hor_res(disp: *mut lv_disp_t) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get the vertical resolution of a display"]
    #[doc = " @param disp pointer to a display (NULL to use the default display)"]
    #[doc = " @return the vertical resolution of the display"]
    pub fn lv_disp_get_ver_res(disp: *mut lv_disp_t) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get if anti-aliasing is enabled for a display or not"]
    #[doc = " @param disp pointer to a display (NULL to use the default display)"]
    #[doc = " @return true: anti-aliasing is enabled; false: disabled"]
    pub fn lv_disp_get_antialiasing(disp: *mut lv_disp_t) -> bool;
}
extern "C" {
    #[doc = " Call in the display driver's `flush_cb` function when the flushing is finished"]
    #[doc = " @param disp_drv pointer to display driver in `flush_cb` where this function is called"]
    pub fn lv_disp_flush_ready(disp_drv: *mut lv_disp_drv_t);
}
extern "C" {
    #[doc = " Get the next display."]
    #[doc = " @param disp pointer to the current display. NULL to initialize."]
    #[doc = " @return the next display or NULL if no more. Give the first display when the parameter is NULL"]
    pub fn lv_disp_get_next(disp: *mut lv_disp_t) -> *mut lv_disp_t;
}
extern "C" {
    #[doc = " Get the internal buffer of a display"]
    #[doc = " @param disp pointer to a display"]
    #[doc = " @return pointer to the internal buffers"]
    pub fn lv_disp_get_buf(disp: *mut lv_disp_t) -> *mut lv_disp_buf_t;
}
extern "C" {
    #[doc = " Get the number of areas in the buffer"]
    #[doc = " @return number of invalid areas"]
    pub fn lv_disp_get_inv_buf_size(disp: *mut lv_disp_t) -> u16;
}
extern "C" {
    #[doc = " Pop (delete) the last 'num' invalidated areas from the buffer"]
    #[doc = " @param num number of areas to delete"]
    pub fn lv_disp_pop_from_inv_buf(disp: *mut lv_disp_t, num: u16);
}
extern "C" {
    #[doc = " Check the driver configuration if it's double buffered (both `buf1` and `buf2` are set)"]
    #[doc = " @param disp pointer to to display to check"]
    #[doc = " @return true: double buffered; false: not double buffered"]
    pub fn lv_disp_is_double_buf(disp: *mut lv_disp_t) -> bool;
}
extern "C" {
    #[doc = " Check the driver configuration if it's TRUE double buffered (both `buf1` and `buf2` are set and"]
    #[doc = " `size` is screen sized)"]
    #[doc = " @param disp pointer to to display to check"]
    #[doc = " @return true: double buffered; false: not double buffered"]
    pub fn lv_disp_is_true_double_buf(disp: *mut lv_disp_t) -> bool;
}
#[doc = "< Uninitialized state"]
pub const LV_INDEV_TYPE_NONE: _bindgen_ty_4 = 0;
#[doc = "< Touch pad, mouse, external button"]
pub const LV_INDEV_TYPE_POINTER: _bindgen_ty_4 = 1;
#[doc = "< Keypad or keyboard"]
pub const LV_INDEV_TYPE_KEYPAD: _bindgen_ty_4 = 2;
#[doc = "< External (hardware button) which is assigned to a specific point of the"]
#[doc = "screen"]
pub const LV_INDEV_TYPE_BUTTON: _bindgen_ty_4 = 3;
#[doc = "< Encoder with only Left, Right turn and a Button"]
pub const LV_INDEV_TYPE_ENCODER: _bindgen_ty_4 = 4;
#[doc = " Possible input device types"]
pub type _bindgen_ty_4 = u32;
pub type lv_indev_type_t = u8;
pub const LV_INDEV_STATE_REL: _bindgen_ty_5 = 0;
pub const LV_INDEV_STATE_PR: _bindgen_ty_5 = 1;
#[doc = " States for input devices"]
pub type _bindgen_ty_5 = u32;
pub type lv_indev_state_t = u8;
#[doc = " Data structure passed to an input driver to fill"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_indev_data_t {
    #[doc = "< For LV_INDEV_TYPE_POINTER the currently pressed point"]
    pub point: lv_point_t,
    #[doc = "< For LV_INDEV_TYPE_KEYPAD the currently pressed key"]
    pub key: u32,
    #[doc = "< For LV_INDEV_TYPE_BUTTON the currently pressed button"]
    pub btn_id: u32,
    #[doc = "< For LV_INDEV_TYPE_ENCODER number of steps since the previous read"]
    pub enc_diff: i16,
    #[doc = "< LV_INDEV_STATE_REL or LV_INDEV_STATE_PR"]
    pub state: lv_indev_state_t,
}
#[doc = " Initialized by the user and registered by 'lv_indev_add()'"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_indev_drv_t {
    pub type_: lv_indev_type_t,
    pub read_cb: ::core::option::Option<
        unsafe extern "C" fn(indev_drv: *mut _lv_indev_drv_t, data: *mut lv_indev_data_t) -> bool,
    >,
    #[doc = " Called when an action happened on the input device."]
    #[doc = " The second parameter is the event from `lv_event_t`"]
    pub feedback_cb:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_indev_drv_t, arg2: u8)>,
    pub user_data: lv_indev_drv_user_data_t,
    pub disp: *mut _disp_t,
    pub read_task: *mut lv_task_t,
    pub drag_limit: u8,
    pub drag_throw: u8,
    pub long_press_time: u16,
    pub long_press_rep_time: u16,
}
pub type lv_indev_drv_t = _lv_indev_drv_t;
#[doc = " Run time data of input devices"]
#[doc = " Internally used by the library, you should not need to touch it."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _lv_indev_proc_t {
    #[doc = "< Current state of the input device."]
    pub state: lv_indev_state_t,
    pub types: _lv_indev_proc_t__bindgen_ty_1,
    #[doc = "< Pressed time stamp"]
    pub pr_timestamp: u32,
    #[doc = "< Long press repeat time stamp"]
    pub longpr_rep_timestamp: u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _lv_indev_proc_t__bindgen_ty_1 {
    pub pointer: _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1,
    pub keypad: _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Current point of input device."]
    pub act_point: lv_point_t,
    #[doc = "< Last point of input device."]
    pub last_point: lv_point_t,
    #[doc = "< Difference between `act_point` and `last_point`."]
    pub vect: lv_point_t,
    pub drag_sum: lv_point_t,
    pub drag_throw_vect: lv_point_t,
    pub act_obj: *mut _lv_obj_t,
    pub last_obj: *mut _lv_obj_t,
    pub last_pressed: *mut _lv_obj_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn drag_limit_out(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_limit_out(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_in_prog(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_in_prog(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        drag_limit_out: u8,
        drag_in_prog: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let drag_limit_out: u8 = unsafe { ::core::mem::transmute(drag_limit_out) };
            drag_limit_out as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let drag_in_prog: u8 = unsafe { ::core::mem::transmute(drag_in_prog) };
            drag_in_prog as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_2 {
    pub last_state: lv_indev_state_t,
    pub last_key: u32,
}
impl _lv_indev_proc_t {
    #[inline]
    pub fn long_pr_sent(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_long_pr_sent(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reset_query(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reset_query(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disabled(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_disabled(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wait_until_release(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wait_until_release(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        long_pr_sent: u8,
        reset_query: u8,
        disabled: u8,
        wait_until_release: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let long_pr_sent: u8 = unsafe { ::core::mem::transmute(long_pr_sent) };
            long_pr_sent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let reset_query: u8 = unsafe { ::core::mem::transmute(reset_query) };
            reset_query as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let disabled: u8 = unsafe { ::core::mem::transmute(disabled) };
            disabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wait_until_release: u8 = unsafe { ::core::mem::transmute(wait_until_release) };
            wait_until_release as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_indev_proc_t = _lv_indev_proc_t;
#[doc = " The main input device descriptor with driver, runtime data ('proc') and some additional"]
#[doc = " information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _lv_indev_t {
    pub driver: lv_indev_drv_t,
    pub proc_: lv_indev_proc_t,
    #[doc = "< Cursor for LV_INPUT_TYPE_POINTER"]
    pub cursor: *mut _lv_obj_t,
    #[doc = "< Keypad destination group"]
    pub group: *mut _lv_group_t,
    #[doc = "< Array points assigned to the button ()screen will be pressed"]
    #[doc = "here by the buttons"]
    pub btn_points: *const lv_point_t,
}
pub type lv_indev_t = _lv_indev_t;
extern "C" {
    #[doc = " Initialize an input device driver with default values."]
    #[doc = " It is used to surly have known values in the fields ant not memory junk."]
    #[doc = " After it you can set the fields."]
    #[doc = " @param driver pointer to driver variable to initialize"]
    pub fn lv_indev_drv_init(driver: *mut lv_indev_drv_t);
}
extern "C" {
    #[doc = " Register an initialized input device driver."]
    #[doc = " @param driver pointer to an initialized 'lv_indev_drv_t' variable (can be local variable)"]
    #[doc = " @return pointer to the new input device or NULL on error"]
    pub fn lv_indev_drv_register(driver: *mut lv_indev_drv_t) -> *mut lv_indev_t;
}
extern "C" {
    #[doc = " Update the driver in run time."]
    #[doc = " @param indev pointer to a input device. (return value of `lv_indev_drv_register`)"]
    #[doc = " @param new_drv pointer to the new driver"]
    pub fn lv_indev_drv_update(indev: *mut lv_indev_t, new_drv: *mut lv_indev_drv_t);
}
extern "C" {
    #[doc = " Get the next input device."]
    #[doc = " @param indev pointer to the current input device. NULL to initialize."]
    #[doc = " @return the next input devise or NULL if no more. Give the first input device when the parameter"]
    #[doc = " is NULL"]
    pub fn lv_indev_get_next(indev: *mut lv_indev_t) -> *mut lv_indev_t;
}
extern "C" {
    #[doc = " Read data from an input device."]
    #[doc = " @param indev pointer to an input device"]
    #[doc = " @param data input device will write its data here"]
    #[doc = " @return false: no more data; true: there more data to read (buffered)"]
    pub fn lv_indev_read(indev: *mut lv_indev_t, data: *mut lv_indev_data_t) -> bool;
}
extern "C" {
    #[doc = " You have to call this function periodically"]
    #[doc = " @param tick_period the call period of this function in milliseconds"]
    pub fn lv_tick_inc(tick_period: u32);
}
extern "C" {
    #[doc = " Get the elapsed milliseconds since start up"]
    #[doc = " @return the elapsed milliseconds"]
    pub fn lv_tick_get() -> u32;
}
extern "C" {
    #[doc = " Get the elapsed milliseconds since a previous time stamp"]
    #[doc = " @param prev_tick a previous time stamp (return value of systick_get() )"]
    #[doc = " @return the elapsed milliseconds since 'prev_tick'"]
    pub fn lv_tick_elaps(prev_tick: u32) -> u32;
}
pub const _LV_STR_SYMBOL_AUDIO: _bindgen_ty_6 = 0;
pub const _LV_STR_SYMBOL_VIDEO: _bindgen_ty_6 = 1;
pub const _LV_STR_SYMBOL_LIST: _bindgen_ty_6 = 2;
pub const _LV_STR_SYMBOL_OK: _bindgen_ty_6 = 3;
pub const _LV_STR_SYMBOL_CLOSE: _bindgen_ty_6 = 4;
pub const _LV_STR_SYMBOL_POWER: _bindgen_ty_6 = 5;
pub const _LV_STR_SYMBOL_SETTINGS: _bindgen_ty_6 = 6;
pub const _LV_STR_SYMBOL_HOME: _bindgen_ty_6 = 7;
pub const _LV_STR_SYMBOL_DOWNLOAD: _bindgen_ty_6 = 8;
pub const _LV_STR_SYMBOL_DRIVE: _bindgen_ty_6 = 9;
pub const _LV_STR_SYMBOL_REFRESH: _bindgen_ty_6 = 10;
pub const _LV_STR_SYMBOL_MUTE: _bindgen_ty_6 = 11;
pub const _LV_STR_SYMBOL_VOLUME_MID: _bindgen_ty_6 = 12;
pub const _LV_STR_SYMBOL_VOLUME_MAX: _bindgen_ty_6 = 13;
pub const _LV_STR_SYMBOL_IMAGE: _bindgen_ty_6 = 14;
pub const _LV_STR_SYMBOL_EDIT: _bindgen_ty_6 = 15;
pub const _LV_STR_SYMBOL_PREV: _bindgen_ty_6 = 16;
pub const _LV_STR_SYMBOL_PLAY: _bindgen_ty_6 = 17;
pub const _LV_STR_SYMBOL_PAUSE: _bindgen_ty_6 = 18;
pub const _LV_STR_SYMBOL_STOP: _bindgen_ty_6 = 19;
pub const _LV_STR_SYMBOL_NEXT: _bindgen_ty_6 = 20;
pub const _LV_STR_SYMBOL_EJECT: _bindgen_ty_6 = 21;
pub const _LV_STR_SYMBOL_LEFT: _bindgen_ty_6 = 22;
pub const _LV_STR_SYMBOL_RIGHT: _bindgen_ty_6 = 23;
pub const _LV_STR_SYMBOL_PLUS: _bindgen_ty_6 = 24;
pub const _LV_STR_SYMBOL_MINUS: _bindgen_ty_6 = 25;
pub const _LV_STR_SYMBOL_EYE_OPEN: _bindgen_ty_6 = 26;
pub const _LV_STR_SYMBOL_EYE_CLOSE: _bindgen_ty_6 = 27;
pub const _LV_STR_SYMBOL_WARNING: _bindgen_ty_6 = 28;
pub const _LV_STR_SYMBOL_SHUFFLE: _bindgen_ty_6 = 29;
pub const _LV_STR_SYMBOL_UP: _bindgen_ty_6 = 30;
pub const _LV_STR_SYMBOL_DOWN: _bindgen_ty_6 = 31;
pub const _LV_STR_SYMBOL_LOOP: _bindgen_ty_6 = 32;
pub const _LV_STR_SYMBOL_DIRECTORY: _bindgen_ty_6 = 33;
pub const _LV_STR_SYMBOL_UPLOAD: _bindgen_ty_6 = 34;
pub const _LV_STR_SYMBOL_CALL: _bindgen_ty_6 = 35;
pub const _LV_STR_SYMBOL_CUT: _bindgen_ty_6 = 36;
pub const _LV_STR_SYMBOL_COPY: _bindgen_ty_6 = 37;
pub const _LV_STR_SYMBOL_SAVE: _bindgen_ty_6 = 38;
pub const _LV_STR_SYMBOL_CHARGE: _bindgen_ty_6 = 39;
pub const _LV_STR_SYMBOL_PASTE: _bindgen_ty_6 = 40;
pub const _LV_STR_SYMBOL_BELL: _bindgen_ty_6 = 41;
pub const _LV_STR_SYMBOL_KEYBOARD: _bindgen_ty_6 = 42;
pub const _LV_STR_SYMBOL_GPS: _bindgen_ty_6 = 43;
pub const _LV_STR_SYMBOL_FILE: _bindgen_ty_6 = 44;
pub const _LV_STR_SYMBOL_WIFI: _bindgen_ty_6 = 45;
pub const _LV_STR_SYMBOL_BATTERY_FULL: _bindgen_ty_6 = 46;
pub const _LV_STR_SYMBOL_BATTERY_3: _bindgen_ty_6 = 47;
pub const _LV_STR_SYMBOL_BATTERY_2: _bindgen_ty_6 = 48;
pub const _LV_STR_SYMBOL_BATTERY_1: _bindgen_ty_6 = 49;
pub const _LV_STR_SYMBOL_BATTERY_EMPTY: _bindgen_ty_6 = 50;
pub const _LV_STR_SYMBOL_USB: _bindgen_ty_6 = 51;
pub const _LV_STR_SYMBOL_BLUETOOTH: _bindgen_ty_6 = 52;
pub const _LV_STR_SYMBOL_TRASH: _bindgen_ty_6 = 53;
pub const _LV_STR_SYMBOL_BACKSPACE: _bindgen_ty_6 = 54;
pub const _LV_STR_SYMBOL_SD_CARD: _bindgen_ty_6 = 55;
pub const _LV_STR_SYMBOL_NEW_LINE: _bindgen_ty_6 = 56;
pub const _LV_STR_SYMBOL_DUMMY: _bindgen_ty_6 = 57;
pub type _bindgen_ty_6 = u32;
#[doc = " Describes the properties of a glyph."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_font_glyph_dsc_t {
    #[doc = "< The glyph needs this space. Draw the next glyph after this width. 8 bit integer, 4 bit fractional"]
    pub adv_w: u16,
    #[doc = "< Width of the glyph's bounding box"]
    pub box_w: u8,
    #[doc = "< Height of the glyph's bounding box"]
    pub box_h: u8,
    #[doc = "< x offset of the bounding box"]
    pub ofs_x: i8,
    #[doc = "< y offset of the bounding box"]
    pub ofs_y: i8,
    #[doc = "< Bit-per-pixel: 1, 2, 4, 8"]
    pub bpp: u8,
}
pub const LV_FONT_SUBPX_NONE: _bindgen_ty_7 = 0;
pub const LV_FONT_SUBPX_HOR: _bindgen_ty_7 = 1;
pub const LV_FONT_SUBPX_VER: _bindgen_ty_7 = 2;
pub const LV_FONT_SUBPX_BOTH: _bindgen_ty_7 = 3;
#[doc = " The bitmaps might be upscaled by 3 to achieve subpixel rendering."]
pub type _bindgen_ty_7 = u32;
pub type lv_font_subpx_t = u8;
#[doc = " Describe the properties of a font"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_font_struct {
    #[doc = " Get a glyph's  descriptor from a font"]
    pub get_glyph_dsc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const _lv_font_struct,
            arg2: *mut lv_font_glyph_dsc_t,
            letter: u32,
            letter_next: u32,
        ) -> bool,
    >,
    #[doc = " Get a glyph's bitmap from a font"]
    pub get_glyph_bitmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const _lv_font_struct, arg2: u32) -> *const u8,
    >,
    #[doc = "< The real line height where any text fits"]
    pub line_height: u8,
    #[doc = "< Base line measured from the top of the line_height"]
    pub base_line: i8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    #[doc = "< Store implementation specific or run_time data or caching here"]
    pub dsc: *mut cty::c_void,
    #[doc = "< Custom user data for font."]
    pub user_data: lv_font_user_data_t,
}
impl _lv_font_struct {
    #[inline]
    pub fn subpx(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_subpx(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(subpx: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let subpx: u8 = unsafe { ::core::mem::transmute(subpx) };
            subpx as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_font_t = _lv_font_struct;
extern "C" {
    #[doc = " Return with the bitmap of a font."]
    #[doc = " @param font_p pointer to a font"]
    #[doc = " @param letter an UNICODE character code"]
    #[doc = " @return  pointer to the bitmap of the letter"]
    pub fn lv_font_get_glyph_bitmap(font_p: *const lv_font_t, letter: u32) -> *const u8;
}
extern "C" {
    #[doc = " Get the descriptor of a glyph"]
    #[doc = " @param font_p pointer to font"]
    #[doc = " @param dsc_out store the result descriptor here"]
    #[doc = " @param letter an UNICODE letter code"]
    #[doc = " @return true: descriptor is successfully loaded into `dsc_out`."]
    #[doc = "         false: the letter was not found, no data is loaded to `dsc_out`"]
    pub fn lv_font_get_glyph_dsc(
        font_p: *const lv_font_t,
        dsc_out: *mut lv_font_glyph_dsc_t,
        letter: u32,
        letter_next: u32,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the width of a glyph with kerning"]
    #[doc = " @param font pointer to a font"]
    #[doc = " @param letter an UNICODE letter"]
    #[doc = " @param letter_next the next letter after `letter`. Used for kerning"]
    #[doc = " @return the width of the glyph"]
    pub fn lv_font_get_glyph_width(font: *const lv_font_t, letter: u32, letter_next: u32) -> u16;
}
extern "C" {
    pub static mut lv_font_roboto_28: lv_font_t;
}
pub const LV_ANIM_OFF: _bindgen_ty_8 = 0;
pub const LV_ANIM_ON: _bindgen_ty_8 = 1;
#[doc = " Can be used to indicate if animations are enabled or disabled in a case"]
pub type _bindgen_ty_8 = u32;
pub type lv_anim_enable_t = u8;
#[doc = " Type of the animated value"]
pub type lv_anim_value_t = lv_coord_t;
#[doc = " Generic prototype of \"animator\" functions."]
#[doc = " First parameter is the variable to animate."]
#[doc = " Second parameter is the value to set."]
#[doc = " Compatible with `lv_xxx_set_yyy(obj, value)` functions"]
#[doc = " The `x` in `_xcb_t` means its not a fully generic prototype because"]
#[doc = " it doesn't receive `lv_anim_t *` as its first argument"]
pub type lv_anim_exec_xcb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: lv_anim_value_t)>;
#[doc = " Same as `lv_anim_exec_xcb_t` but receives `lv_anim_t *` as the first parameter."]
#[doc = " It's more consistent but less convenient. Might be used by binding generator functions."]
pub type lv_anim_custom_exec_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_anim_t, arg2: lv_anim_value_t)>;
#[doc = " Get the current value during an animation"]
pub type lv_anim_path_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *const _lv_anim_t) -> lv_anim_value_t>;
#[doc = " Callback to call when the animation is ready"]
pub type lv_anim_ready_cb_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_anim_t)>;
#[doc = " Describes an animation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_anim_t {
    #[doc = "<Variable to animate"]
    pub var: *mut cty::c_void,
    #[doc = "< Function to execute to animate"]
    pub exec_cb: lv_anim_exec_xcb_t,
    #[doc = "< Function to get the steps of animations"]
    pub path_cb: lv_anim_path_cb_t,
    #[doc = "< Call it when the animation is ready"]
    pub ready_cb: lv_anim_ready_cb_t,
    #[doc = "< Start value"]
    pub start: i32,
    #[doc = "< End value"]
    pub end: i32,
    #[doc = "< Animation time in ms"]
    pub time: u16,
    #[doc = "< Current time in animation. Set to negative to make delay."]
    pub act_time: i16,
    #[doc = "< Wait before play back"]
    pub playback_pause: u16,
    #[doc = "< Wait before repeat"]
    pub repeat_pause: u16,
    #[doc = "< Custom user data"]
    pub user_data: lv_anim_user_data_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl _lv_anim_t {
    #[inline]
    pub fn playback(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_playback(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repeat(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_repeat(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn playback_now(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_playback_now(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_run(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_run(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        playback: u8,
        repeat: u8,
        playback_now: u8,
        has_run: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let playback: u8 = unsafe { ::core::mem::transmute(playback) };
            playback as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let repeat: u8 = unsafe { ::core::mem::transmute(repeat) };
            repeat as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let playback_now: u8 = unsafe { ::core::mem::transmute(playback_now) };
            playback_now as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let has_run: u32 = unsafe { ::core::mem::transmute(has_run) };
            has_run as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_anim_t = _lv_anim_t;
extern "C" {
    #[doc = " Init. the animation module"]
    pub fn lv_anim_core_init();
}
extern "C" {
    #[doc = " Initialize an animation variable."]
    #[doc = " E.g.:"]
    #[doc = " lv_anim_t a;"]
    #[doc = " lv_anim_init(&a);"]
    #[doc = " lv_anim_set_...(&a);"]
    #[doc = " lv_anim_create(&a);"]
    #[doc = " @param a pointer to an `lv_anim_t` variable to initialize"]
    pub fn lv_anim_init(a: *mut lv_anim_t);
}
extern "C" {
    #[doc = " Create an animation"]
    #[doc = " @param a an initialized 'anim_t' variable. Not required after call."]
    pub fn lv_anim_create(a: *mut lv_anim_t);
}
extern "C" {
    #[doc = " Delete an animation of a variable with a given animator function"]
    #[doc = " @param var pointer to variable"]
    #[doc = " @param exec_cb a function pointer which is animating 'var',"]
    #[doc = "           or NULL to ignore it and delete all the animations of 'var"]
    #[doc = " @return true: at least 1 animation is deleted, false: no animation is deleted"]
    pub fn lv_anim_del(var: *mut cty::c_void, exec_cb: lv_anim_exec_xcb_t) -> bool;
}
extern "C" {
    #[doc = " Get the number of currently running animations"]
    #[doc = " @return the number of running animations"]
    pub fn lv_anim_count_running() -> u16;
}
extern "C" {
    #[doc = " Calculate the time of an animation with a given speed and the start and end values"]
    #[doc = " @param speed speed of animation in unit/sec"]
    #[doc = " @param start start value of the animation"]
    #[doc = " @param end end value of the animation"]
    #[doc = " @return the required time [ms] for the animation with the given parameters"]
    pub fn lv_anim_speed_to_time(speed: u16, start: lv_anim_value_t, end: lv_anim_value_t) -> u16;
}
extern "C" {
    #[doc = " Calculate the current value of an animation applying linear characteristic"]
    #[doc = " @param a pointer to an animation"]
    #[doc = " @return the current value to set"]
    pub fn lv_anim_path_linear(a: *const lv_anim_t) -> lv_anim_value_t;
}
extern "C" {
    #[doc = " Calculate the current value of an animation slowing down the start phase"]
    #[doc = " @param a pointer to an animation"]
    #[doc = " @return the current value to set"]
    pub fn lv_anim_path_ease_in(a: *const lv_anim_t) -> lv_anim_value_t;
}
extern "C" {
    #[doc = " Calculate the current value of an animation slowing down the end phase"]
    #[doc = " @param a pointer to an animation"]
    #[doc = " @return the current value to set"]
    pub fn lv_anim_path_ease_out(a: *const lv_anim_t) -> lv_anim_value_t;
}
extern "C" {
    #[doc = " Calculate the current value of an animation applying an \"S\" characteristic (cosine)"]
    #[doc = " @param a pointer to an animation"]
    #[doc = " @return the current value to set"]
    pub fn lv_anim_path_ease_in_out(a: *const lv_anim_t) -> lv_anim_value_t;
}
extern "C" {
    #[doc = " Calculate the current value of an animation with overshoot at the end"]
    #[doc = " @param a pointer to an animation"]
    #[doc = " @return the current value to set"]
    pub fn lv_anim_path_overshoot(a: *const lv_anim_t) -> lv_anim_value_t;
}
extern "C" {
    #[doc = " Calculate the current value of an animation with 3 bounces"]
    #[doc = " @param a pointer to an animation"]
    #[doc = " @return the current value to set"]
    pub fn lv_anim_path_bounce(a: *const lv_anim_t) -> lv_anim_value_t;
}
extern "C" {
    #[doc = " Calculate the current value of an animation applying step characteristic."]
    #[doc = " (Set end value on the end of the animation)"]
    #[doc = " @param a pointer to an animation"]
    #[doc = " @return the current value to set"]
    pub fn lv_anim_path_step(a: *const lv_anim_t) -> lv_anim_value_t;
}
pub const LV_BORDER_NONE: _bindgen_ty_9 = 0;
pub const LV_BORDER_BOTTOM: _bindgen_ty_9 = 1;
pub const LV_BORDER_TOP: _bindgen_ty_9 = 2;
pub const LV_BORDER_LEFT: _bindgen_ty_9 = 4;
pub const LV_BORDER_RIGHT: _bindgen_ty_9 = 8;
pub const LV_BORDER_FULL: _bindgen_ty_9 = 15;
#[doc = "< FOR matrix-like objects (e.g. Button matrix)"]
pub const LV_BORDER_INTERNAL: _bindgen_ty_9 = 16;
#[doc = "      TYPEDEFS"]
pub type _bindgen_ty_9 = u32;
pub type lv_border_part_t = u8;
#[doc = "< Only draw bottom shadow"]
pub const LV_SHADOW_BOTTOM: _bindgen_ty_10 = 0;
#[doc = "< Draw shadow on all sides"]
pub const LV_SHADOW_FULL: _bindgen_ty_10 = 1;
pub type _bindgen_ty_10 = u32;
pub type lv_shadow_type_t = u8;
#[doc = " Objects in LittlevGL can be assigned a style - which holds information about"]
#[doc = " how the object should be drawn."]
#[doc = ""]
#[doc = " This allows for easy customization without having to modify the object's design"]
#[doc = " function."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_style_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub body: lv_style_t__bindgen_ty_1,
    pub text: lv_style_t__bindgen_ty_2,
    pub image: lv_style_t__bindgen_ty_3,
    pub line: lv_style_t__bindgen_ty_4,
}
#[doc = " Object background."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_style_t__bindgen_ty_1 {
    #[doc = "< Object's main background color."]
    pub main_color: lv_color_t,
    #[doc = "< Second color. If not equal to `main_color` a gradient will be drawn for the background."]
    pub grad_color: lv_color_t,
    #[doc = "< Object's corner radius. You can use #LV_RADIUS_CIRCLE if you want to draw a circle."]
    pub radius: lv_coord_t,
    #[doc = "< Object's opacity (0-255)."]
    pub opa: lv_opa_t,
    pub border: lv_style_t__bindgen_ty_1__bindgen_ty_1,
    pub shadow: lv_style_t__bindgen_ty_1__bindgen_ty_2,
    pub padding: lv_style_t__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_style_t__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Border color"]
    pub color: lv_color_t,
    #[doc = "< Border width"]
    pub width: lv_coord_t,
    #[doc = "< Which borders to draw"]
    pub part: lv_border_part_t,
    #[doc = "< Border opacity."]
    pub opa: lv_opa_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_style_t__bindgen_ty_1__bindgen_ty_2 {
    pub color: lv_color_t,
    pub width: lv_coord_t,
    #[doc = "< Which parts of the shadow to draw"]
    pub type_: lv_shadow_type_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_style_t__bindgen_ty_1__bindgen_ty_3 {
    pub top: lv_coord_t,
    pub bottom: lv_coord_t,
    pub left: lv_coord_t,
    pub right: lv_coord_t,
    pub inner: lv_coord_t,
}
#[doc = " Style for text drawn by this object."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_style_t__bindgen_ty_2 {
    #[doc = "< Text color"]
    pub color: lv_color_t,
    #[doc = "< Text selection background color."]
    pub sel_color: lv_color_t,
    pub font: *const lv_font_t,
    #[doc = "< Space between letters"]
    pub letter_space: lv_coord_t,
    #[doc = "< Space between lines (vertical)"]
    pub line_space: lv_coord_t,
    #[doc = "< Text opacity"]
    pub opa: lv_opa_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_style_t__bindgen_ty_3 {
    #[doc = "< Color to recolor the image with"]
    pub color: lv_color_t,
    #[doc = "< Opacity of recoloring (0 means no recoloring)"]
    pub intense: lv_opa_t,
    #[doc = "< Opacity of whole image"]
    pub opa: lv_opa_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_style_t__bindgen_ty_4 {
    pub color: lv_color_t,
    pub width: lv_coord_t,
    pub opa: lv_opa_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl lv_style_t__bindgen_ty_4 {
    #[inline]
    pub fn rounded(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rounded(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(rounded: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rounded: u8 = unsafe { ::core::mem::transmute(rounded) };
            rounded as u64
        });
        __bindgen_bitfield_unit
    }
}
impl lv_style_t {
    #[inline]
    pub fn glass(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_glass(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(glass: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let glass: u8 = unsafe { ::core::mem::transmute(glass) };
            glass as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Data structure for style animations."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_style_anim_dsc_t {
    pub style_start: lv_style_t,
    pub style_end: lv_style_t,
    pub style_anim: *mut lv_style_t,
    pub ready_cb: lv_anim_ready_cb_t,
}
extern "C" {
    #[doc = "  Init the basic styles"]
    pub fn lv_style_init();
}
extern "C" {
    #[doc = " Copy a style to an other"]
    #[doc = " @param dest pointer to the destination style"]
    #[doc = " @param src pointer to the source style"]
    pub fn lv_style_copy(dest: *mut lv_style_t, src: *const lv_style_t);
}
extern "C" {
    #[doc = " Mix two styles according to a given ratio"]
    #[doc = " @param start start style"]
    #[doc = " @param end end style"]
    #[doc = " @param res store the result style here"]
    #[doc = " @param ratio the ratio of mix [0..256]; 0: `start` style; 256: `end` style"]
    pub fn lv_style_mix(
        start: *const lv_style_t,
        end: *const lv_style_t,
        res: *mut lv_style_t,
        ratio: u16,
    );
}
extern "C" {
    #[doc = " Initialize an animation variable."]
    #[doc = " E.g.:"]
    #[doc = " lv_anim_t a;"]
    #[doc = " lv_style_anim__init(&a);"]
    #[doc = " lv_style_anim_set_...(&a);"]
    #[doc = " lv_style_anim_create(&a);"]
    #[doc = " @param a pointer to an `lv_anim_t` variable to initialize"]
    pub fn lv_style_anim_init(a: *mut lv_anim_t);
}
extern "C" {
    #[doc = " @param a pointer to an initialized `lv_anim_t` variable"]
    #[doc = " @param to_anim pointer to the style to animate"]
    #[doc = " @param start pointer to a style to animate from (start value)"]
    #[doc = " @param end pointer to a style to animate to (end value)"]
    pub fn lv_style_anim_set_styles(
        a: *mut lv_anim_t,
        to_anim: *mut lv_style_t,
        start: *const lv_style_t,
        end: *const lv_style_t,
    );
}
extern "C" {
    pub static mut lv_style_scr: lv_style_t;
}
extern "C" {
    pub static mut lv_style_transp: lv_style_t;
}
extern "C" {
    pub static mut lv_style_transp_fit: lv_style_t;
}
extern "C" {
    pub static mut lv_style_transp_tight: lv_style_t;
}
extern "C" {
    pub static mut lv_style_plain: lv_style_t;
}
extern "C" {
    pub static mut lv_style_plain_color: lv_style_t;
}
extern "C" {
    pub static mut lv_style_pretty: lv_style_t;
}
extern "C" {
    pub static mut lv_style_pretty_color: lv_style_t;
}
extern "C" {
    pub static mut lv_style_btn_rel: lv_style_t;
}
extern "C" {
    pub static mut lv_style_btn_pr: lv_style_t;
}
extern "C" {
    pub static mut lv_style_btn_tgl_rel: lv_style_t;
}
extern "C" {
    pub static mut lv_style_btn_tgl_pr: lv_style_t;
}
extern "C" {
    pub static mut lv_style_btn_ina: lv_style_t;
}
pub const LV_BIDI_DIR_LTR: _bindgen_ty_11 = 0;
pub const LV_BIDI_DIR_RTL: _bindgen_ty_11 = 1;
pub const LV_BIDI_DIR_AUTO: _bindgen_ty_11 = 2;
pub const LV_BIDI_DIR_INHERIT: _bindgen_ty_11 = 3;
pub const LV_BIDI_DIR_NEUTRAL: _bindgen_ty_11 = 32;
pub const LV_BIDI_DIR_WEAK: _bindgen_ty_11 = 33;
#[doc = "      TYPEDEFS"]
pub type _bindgen_ty_11 = u32;
pub type lv_bidi_dir_t = u8;
#[doc = "< Draw the main portion of the object"]
pub const LV_DESIGN_DRAW_MAIN: _bindgen_ty_12 = 0;
#[doc = "< Draw extras on the object"]
pub const LV_DESIGN_DRAW_POST: _bindgen_ty_12 = 1;
#[doc = "< Check if the object fully covers the 'mask_p' area"]
pub const LV_DESIGN_COVER_CHK: _bindgen_ty_12 = 2;
#[doc = " Design modes"]
pub type _bindgen_ty_12 = u32;
pub type lv_design_mode_t = u8;
#[doc = " The design callback is used to draw the object on the screen."]
#[doc = " It accepts the object, a mask area, and the mode in which to draw the object."]
pub type lv_design_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: *mut _lv_obj_t,
        mask_p: *const lv_area_t,
        mode: lv_design_mode_t,
    ) -> bool,
>;
#[doc = "< The object has been pressed"]
pub const LV_EVENT_PRESSED: _bindgen_ty_13 = 0;
#[doc = "< The object is being pressed (called continuously while pressing)"]
pub const LV_EVENT_PRESSING: _bindgen_ty_13 = 1;
#[doc = "< User is still pressing but slid cursor/finger off of the object"]
pub const LV_EVENT_PRESS_LOST: _bindgen_ty_13 = 2;
#[doc = "< User pressed object for a short period of time, then released it. Not called if dragged."]
pub const LV_EVENT_SHORT_CLICKED: _bindgen_ty_13 = 3;
#[doc = "< Object has been pressed for at least `LV_INDEV_LONG_PRESS_TIME`.  Not called if dragged."]
pub const LV_EVENT_LONG_PRESSED: _bindgen_ty_13 = 4;
#[doc = "< Called after `LV_INDEV_LONG_PRESS_TIME` in every"]
#[doc = "`LV_INDEV_LONG_PRESS_REP_TIME` ms.  Not called if dragged."]
pub const LV_EVENT_LONG_PRESSED_REPEAT: _bindgen_ty_13 = 5;
#[doc = "< Called on release if not dragged (regardless to long press)"]
pub const LV_EVENT_CLICKED: _bindgen_ty_13 = 6;
#[doc = "< Called in every cases when the object has been released"]
pub const LV_EVENT_RELEASED: _bindgen_ty_13 = 7;
pub const LV_EVENT_DRAG_BEGIN: _bindgen_ty_13 = 8;
pub const LV_EVENT_DRAG_END: _bindgen_ty_13 = 9;
pub const LV_EVENT_DRAG_THROW_BEGIN: _bindgen_ty_13 = 10;
pub const LV_EVENT_KEY: _bindgen_ty_13 = 11;
pub const LV_EVENT_FOCUSED: _bindgen_ty_13 = 12;
pub const LV_EVENT_DEFOCUSED: _bindgen_ty_13 = 13;
#[doc = "< The object's value has changed (i.e. slider moved)"]
pub const LV_EVENT_VALUE_CHANGED: _bindgen_ty_13 = 14;
pub const LV_EVENT_INSERT: _bindgen_ty_13 = 15;
pub const LV_EVENT_REFRESH: _bindgen_ty_13 = 16;
#[doc = "< \"Ok\", \"Apply\" or similar specific button has clicked"]
pub const LV_EVENT_APPLY: _bindgen_ty_13 = 17;
#[doc = "< \"Close\", \"Cancel\" or similar specific button has clicked"]
pub const LV_EVENT_CANCEL: _bindgen_ty_13 = 18;
#[doc = "< Object is being deleted"]
pub const LV_EVENT_DELETE: _bindgen_ty_13 = 19;
pub type _bindgen_ty_13 = u32;
pub type lv_event_t = u8;
#[doc = " @brief Event callback."]
#[doc = " Events are used to notify the user of some action being taken on the object."]
#[doc = " For details, see ::lv_event_t."]
pub type lv_event_cb_t =
    ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t, event: lv_event_t)>;
#[doc = "< Object is being deleted"]
pub const LV_SIGNAL_CLEANUP: _bindgen_ty_14 = 0;
#[doc = "< Child was removed/added"]
pub const LV_SIGNAL_CHILD_CHG: _bindgen_ty_14 = 1;
#[doc = "< Object coordinates/size have changed"]
pub const LV_SIGNAL_CORD_CHG: _bindgen_ty_14 = 2;
#[doc = "< Parent's size has changed"]
pub const LV_SIGNAL_PARENT_SIZE_CHG: _bindgen_ty_14 = 3;
#[doc = "< Object's style has changed"]
pub const LV_SIGNAL_STYLE_CHG: _bindgen_ty_14 = 4;
#[doc = "<The base dir has changed"]
pub const LV_SIGNAL_BASE_DIR_CHG: _bindgen_ty_14 = 5;
#[doc = "< Object's extra padding has changed"]
pub const LV_SIGNAL_REFR_EXT_DRAW_PAD: _bindgen_ty_14 = 6;
#[doc = "< LittlevGL needs to retrieve the object's type"]
pub const LV_SIGNAL_GET_TYPE: _bindgen_ty_14 = 7;
#[doc = "< The object has been pressed"]
pub const LV_SIGNAL_PRESSED: _bindgen_ty_14 = 8;
#[doc = "< The object is being pressed (called continuously while pressing)"]
pub const LV_SIGNAL_PRESSING: _bindgen_ty_14 = 9;
#[doc = "< User is still pressing but slid cursor/finger off of the object"]
pub const LV_SIGNAL_PRESS_LOST: _bindgen_ty_14 = 10;
#[doc = "< User pressed object for a short period of time, then released it. Not called if dragged."]
pub const LV_SIGNAL_RELEASED: _bindgen_ty_14 = 11;
#[doc = "< Object has been pressed for at least `LV_INDEV_LONG_PRESS_TIME`.  Not called if dragged."]
pub const LV_SIGNAL_LONG_PRESS: _bindgen_ty_14 = 12;
#[doc = "< Called after `LV_INDEV_LONG_PRESS_TIME` in every `LV_INDEV_LONG_PRESS_REP_TIME` ms.  Not called if dragged."]
pub const LV_SIGNAL_LONG_PRESS_REP: _bindgen_ty_14 = 13;
pub const LV_SIGNAL_DRAG_BEGIN: _bindgen_ty_14 = 14;
pub const LV_SIGNAL_DRAG_END: _bindgen_ty_14 = 15;
pub const LV_SIGNAL_FOCUS: _bindgen_ty_14 = 16;
pub const LV_SIGNAL_DEFOCUS: _bindgen_ty_14 = 17;
pub const LV_SIGNAL_CONTROL: _bindgen_ty_14 = 18;
pub const LV_SIGNAL_GET_EDITABLE: _bindgen_ty_14 = 19;
#[doc = " Signals are for use by the object itself or to extend the object's functionality."]
#[doc = " Applications should use ::lv_obj_set_event_cb to be notified of events that occur"]
#[doc = " on the object."]
pub type _bindgen_ty_14 = u32;
pub type lv_signal_t = u8;
pub type lv_signal_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: *mut _lv_obj_t,
        sign: lv_signal_t,
        param: *mut cty::c_void,
    ) -> lv_res_t,
>;
pub const LV_ALIGN_CENTER: _bindgen_ty_15 = 0;
pub const LV_ALIGN_IN_TOP_LEFT: _bindgen_ty_15 = 1;
pub const LV_ALIGN_IN_TOP_MID: _bindgen_ty_15 = 2;
pub const LV_ALIGN_IN_TOP_RIGHT: _bindgen_ty_15 = 3;
pub const LV_ALIGN_IN_BOTTOM_LEFT: _bindgen_ty_15 = 4;
pub const LV_ALIGN_IN_BOTTOM_MID: _bindgen_ty_15 = 5;
pub const LV_ALIGN_IN_BOTTOM_RIGHT: _bindgen_ty_15 = 6;
pub const LV_ALIGN_IN_LEFT_MID: _bindgen_ty_15 = 7;
pub const LV_ALIGN_IN_RIGHT_MID: _bindgen_ty_15 = 8;
pub const LV_ALIGN_OUT_TOP_LEFT: _bindgen_ty_15 = 9;
pub const LV_ALIGN_OUT_TOP_MID: _bindgen_ty_15 = 10;
pub const LV_ALIGN_OUT_TOP_RIGHT: _bindgen_ty_15 = 11;
pub const LV_ALIGN_OUT_BOTTOM_LEFT: _bindgen_ty_15 = 12;
pub const LV_ALIGN_OUT_BOTTOM_MID: _bindgen_ty_15 = 13;
pub const LV_ALIGN_OUT_BOTTOM_RIGHT: _bindgen_ty_15 = 14;
pub const LV_ALIGN_OUT_LEFT_TOP: _bindgen_ty_15 = 15;
pub const LV_ALIGN_OUT_LEFT_MID: _bindgen_ty_15 = 16;
pub const LV_ALIGN_OUT_LEFT_BOTTOM: _bindgen_ty_15 = 17;
pub const LV_ALIGN_OUT_RIGHT_TOP: _bindgen_ty_15 = 18;
pub const LV_ALIGN_OUT_RIGHT_MID: _bindgen_ty_15 = 19;
pub const LV_ALIGN_OUT_RIGHT_BOTTOM: _bindgen_ty_15 = 20;
#[doc = " Object alignment."]
pub type _bindgen_ty_15 = u32;
pub type lv_align_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_reailgn_t {
    pub base: *const _lv_obj_t,
    pub xofs: lv_coord_t,
    pub yofs: lv_coord_t,
    pub align: lv_align_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u16,
}
impl lv_reailgn_t {
    #[inline]
    pub fn auto_realign(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auto_realign(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn origo_align(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_origo_align(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        auto_realign: u8,
        origo_align: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let auto_realign: u8 = unsafe { ::core::mem::transmute(auto_realign) };
            auto_realign as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let origo_align: u8 = unsafe { ::core::mem::transmute(origo_align) };
            origo_align as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< Object can be dragged horizontally."]
pub const LV_DRAG_DIR_HOR: _bindgen_ty_16 = 1;
#[doc = "< Object can be dragged vertically."]
pub const LV_DRAG_DIR_VER: _bindgen_ty_16 = 2;
#[doc = "< Object can be dragged in all directions."]
pub const LV_DRAG_DIR_ALL: _bindgen_ty_16 = 3;
pub type _bindgen_ty_16 = u32;
pub type lv_drag_dir_t = u8;
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_obj_t {
    #[doc = "< Pointer to the parent object"]
    pub par: *mut _lv_obj_t,
    #[doc = "< Linked list to store the children objects"]
    pub child_ll: lv_ll_t,
    #[doc = "< Coordinates of the object (x1, y1, x2, y2)"]
    pub coords: lv_area_t,
    #[doc = "< Event callback function"]
    pub event_cb: lv_event_cb_t,
    #[doc = "< Object type specific signal function"]
    pub signal_cb: lv_signal_cb_t,
    #[doc = "< Object type specific design function"]
    pub design_cb: lv_design_cb_t,
    #[doc = "< Object type specific extended data"]
    pub ext_attr: *mut cty::c_void,
    #[doc = "< Pointer to the object's style"]
    pub style_p: *const lv_style_t,
    #[doc = "< Pointer to the group of the object"]
    pub group_p: *mut cty::c_void,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    #[doc = "< Automatically happening actions can be prevented. 'OR'ed values from"]
    #[doc = "`lv_protect_t`"]
    pub protect: u8,
    #[doc = "< Scale down the opacity by this factor. Effects all children as well"]
    pub opa_scale: lv_opa_t,
    #[doc = "< EXTtend the size in every direction for drawing."]
    pub ext_draw_pad: lv_coord_t,
    #[doc = "< Information about the last call to ::lv_obj_align."]
    pub realign: lv_reailgn_t,
    #[doc = "< Custom user data for object."]
    pub user_data: lv_obj_user_data_t,
}
impl _lv_obj_t {
    #[inline]
    pub fn click(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_click(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_throw(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_throw(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_parent(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_parent(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hidden(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hidden(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn top(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_top(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn opa_scale_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_opa_scale_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn parent_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_parent_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_dir(&self) -> lv_drag_dir_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_drag_dir(&mut self, val: lv_drag_dir_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn base_dir(&self) -> lv_bidi_dir_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_base_dir(&mut self, val: lv_bidi_dir_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        click: u8,
        drag: u8,
        drag_throw: u8,
        drag_parent: u8,
        hidden: u8,
        top: u8,
        opa_scale_en: u8,
        parent_event: u8,
        drag_dir: lv_drag_dir_t,
        base_dir: lv_bidi_dir_t,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let click: u8 = unsafe { ::core::mem::transmute(click) };
            click as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let drag: u8 = unsafe { ::core::mem::transmute(drag) };
            drag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let drag_throw: u8 = unsafe { ::core::mem::transmute(drag_throw) };
            drag_throw as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let drag_parent: u8 = unsafe { ::core::mem::transmute(drag_parent) };
            drag_parent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let hidden: u8 = unsafe { ::core::mem::transmute(hidden) };
            hidden as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let top: u8 = unsafe { ::core::mem::transmute(top) };
            top as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let opa_scale_en: u8 = unsafe { ::core::mem::transmute(opa_scale_en) };
            opa_scale_en as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let parent_event: u8 = unsafe { ::core::mem::transmute(parent_event) };
            parent_event as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let drag_dir: u8 = unsafe { ::core::mem::transmute(drag_dir) };
            drag_dir as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let base_dir: u8 = unsafe { ::core::mem::transmute(base_dir) };
            base_dir as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_obj_t = _lv_obj_t;
pub const LV_PROTECT_NONE: _bindgen_ty_17 = 0;
#[doc = "< Disable the child change signal. Used by the library"]
pub const LV_PROTECT_CHILD_CHG: _bindgen_ty_17 = 1;
#[doc = "< Prevent automatic parent change (e.g. in lv_page)"]
pub const LV_PROTECT_PARENT: _bindgen_ty_17 = 2;
#[doc = "< Prevent automatic positioning (e.g. in lv_cont layout)"]
pub const LV_PROTECT_POS: _bindgen_ty_17 = 4;
#[doc = "< Prevent the object be followed in automatic ordering (e.g. in"]
#[doc = "lv_cont PRETTY layout)"]
pub const LV_PROTECT_FOLLOW: _bindgen_ty_17 = 8;
#[doc = "< If the `indev` was pressing this object but swiped out while"]
#[doc = "pressing do not search other object."]
pub const LV_PROTECT_PRESS_LOST: _bindgen_ty_17 = 16;
#[doc = "< Prevent focusing the object by clicking on it"]
pub const LV_PROTECT_CLICK_FOCUS: _bindgen_ty_17 = 32;
pub type _bindgen_ty_17 = u32;
pub type lv_protect_t = u8;
#[doc = " Used by `lv_obj_get_type()`. The object's and its ancestor types are stored here"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_obj_type_t {
    #[doc = "< [0]: the actual type, [1]: ancestor, [2] #1's ancestor"]
    #[doc = "... [x]: \"lv_obj\""]
    pub type_: [*const cty::c_char; 8usize],
}
extern "C" {
    #[doc = " Init. the 'lv' library."]
    pub fn lv_init();
}
extern "C" {
    pub fn lv_deinit();
}
extern "C" {
    #[doc = " Create a basic object"]
    #[doc = " @param parent pointer to a parent object."]
    #[doc = "                  If NULL then a screen will be created"]
    #[doc = " @param copy pointer to a base object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the new object"]
    pub fn lv_obj_create(parent: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Delete 'obj' and all of its children"]
    #[doc = " @param obj pointer to an object to delete"]
    #[doc = " @return LV_RES_INV because the object is deleted"]
    pub fn lv_obj_del(obj: *mut lv_obj_t) -> lv_res_t;
}
extern "C" {
    #[doc = " Helper function for asynchronously deleting objects."]
    #[doc = " Useful for cases where you can't delete an object directly in an `LV_EVENT_DELETE` handler (i.e. parent)."]
    #[doc = " @param obj object to delete"]
    #[doc = " @see lv_async_call"]
    pub fn lv_obj_del_async(obj: *mut _lv_obj_t);
}
extern "C" {
    #[doc = " Delete all children of an object"]
    #[doc = " @param obj pointer to an object"]
    pub fn lv_obj_clean(obj: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Mark an area of an object as invalid."]
    #[doc = " This area will be redrawn by 'lv_refr_task'"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param area the area to redraw"]
    pub fn lv_obj_invalidate_area(obj: *const lv_obj_t, area: *const lv_area_t);
}
extern "C" {
    #[doc = " Mark the object as invalid therefore its current position will be redrawn by 'lv_refr_task'"]
    #[doc = " @param obj pointer to an object"]
    pub fn lv_obj_invalidate(obj: *const lv_obj_t);
}
extern "C" {
    #[doc = " Set a new parent for an object. Its relative position will be the same."]
    #[doc = " @param obj pointer to an object. Can't be a screen."]
    #[doc = " @param parent pointer to the new parent object. (Can't be NULL)"]
    pub fn lv_obj_set_parent(obj: *mut lv_obj_t, parent: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Move and object to the foreground"]
    #[doc = " @param obj pointer to an object"]
    pub fn lv_obj_move_foreground(obj: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Move and object to the background"]
    #[doc = " @param obj pointer to an object"]
    pub fn lv_obj_move_background(obj: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Set relative the position of an object (relative to the parent)"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param x new distance from the left side of the parent"]
    #[doc = " @param y new distance from the top of the parent"]
    pub fn lv_obj_set_pos(obj: *mut lv_obj_t, x: lv_coord_t, y: lv_coord_t);
}
extern "C" {
    #[doc = " Set the x coordinate of a object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param x new distance from the left side from the parent"]
    pub fn lv_obj_set_x(obj: *mut lv_obj_t, x: lv_coord_t);
}
extern "C" {
    #[doc = " Set the y coordinate of a object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param y new distance from the top of the parent"]
    pub fn lv_obj_set_y(obj: *mut lv_obj_t, y: lv_coord_t);
}
extern "C" {
    #[doc = " Set the size of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param w new width"]
    #[doc = " @param h new height"]
    pub fn lv_obj_set_size(obj: *mut lv_obj_t, w: lv_coord_t, h: lv_coord_t);
}
extern "C" {
    #[doc = " Set the width of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param w new width"]
    pub fn lv_obj_set_width(obj: *mut lv_obj_t, w: lv_coord_t);
}
extern "C" {
    #[doc = " Set the height of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param h new height"]
    pub fn lv_obj_set_height(obj: *mut lv_obj_t, h: lv_coord_t);
}
extern "C" {
    #[doc = " Align an object to an other object."]
    #[doc = " @param obj pointer to an object to align"]
    #[doc = " @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
    #[doc = " @param align type of alignment (see 'lv_align_t' enum)"]
    #[doc = " @param x_mod x coordinate shift after alignment"]
    #[doc = " @param y_mod y coordinate shift after alignment"]
    pub fn lv_obj_align(
        obj: *mut lv_obj_t,
        base: *const lv_obj_t,
        align: lv_align_t,
        x_mod: lv_coord_t,
        y_mod: lv_coord_t,
    );
}
extern "C" {
    #[doc = " Align an object to an other object."]
    #[doc = " @param obj pointer to an object to align"]
    #[doc = " @param base pointer to an object (if NULL the parent is used). 'obj' will be aligned to it."]
    #[doc = " @param align type of alignment (see 'lv_align_t' enum)"]
    #[doc = " @param x_mod x coordinate shift after alignment"]
    #[doc = " @param y_mod y coordinate shift after alignment"]
    pub fn lv_obj_align_origo(
        obj: *mut lv_obj_t,
        base: *const lv_obj_t,
        align: lv_align_t,
        x_mod: lv_coord_t,
        y_mod: lv_coord_t,
    );
}
extern "C" {
    #[doc = " Realign the object based on the last `lv_obj_align` parameters."]
    #[doc = " @param obj pointer to an object"]
    pub fn lv_obj_realign(obj: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Enable the automatic realign of the object when its size has changed based on the last"]
    #[doc = " `lv_obj_align` parameters."]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param en true: enable auto realign; false: disable auto realign"]
    pub fn lv_obj_set_auto_realign(obj: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Set the size of an extended clickable area"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param left extended clickable are on the left [px]"]
    #[doc = " @param right extended clickable are on the right [px]"]
    #[doc = " @param top extended clickable are on the top [px]"]
    #[doc = " @param bottom extended clickable are on the bottom [px]"]
    pub fn lv_obj_set_ext_click_area(
        obj: *mut lv_obj_t,
        left: lv_coord_t,
        right: lv_coord_t,
        top: lv_coord_t,
        bottom: lv_coord_t,
    );
}
extern "C" {
    #[doc = " Set a new style for an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param style_p pointer to the new style"]
    pub fn lv_obj_set_style(obj: *mut lv_obj_t, style: *const lv_style_t);
}
extern "C" {
    #[doc = " Notify an object about its style is modified"]
    #[doc = " @param obj pointer to an object"]
    pub fn lv_obj_refresh_style(obj: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Notify all object if a style is modified"]
    #[doc = " @param style pointer to a style. Only the objects with this style will be notified"]
    #[doc = "               (NULL to notify all objects)"]
    pub fn lv_obj_report_style_mod(style: *mut lv_style_t);
}
extern "C" {
    #[doc = " Hide an object. It won't be visible and clickable."]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param en true: hide the object"]
    pub fn lv_obj_set_hidden(obj: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Enable or disable the clicking of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param en true: make the object clickable"]
    pub fn lv_obj_set_click(obj: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Enable to bring this object to the foreground if it"]
    #[doc = " or any of its children is clicked"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param en true: enable the auto top feature"]
    pub fn lv_obj_set_top(obj: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Enable the dragging of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param en true: make the object dragable"]
    pub fn lv_obj_set_drag(obj: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Set the directions an object can be dragged in"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param drag_dir bitwise OR of allowed drag directions"]
    pub fn lv_obj_set_drag_dir(obj: *mut lv_obj_t, drag_dir: lv_drag_dir_t);
}
extern "C" {
    #[doc = " Enable the throwing of an object after is is dragged"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param en true: enable the drag throw"]
    pub fn lv_obj_set_drag_throw(obj: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Enable to use parent for drag related operations."]
    #[doc = " If trying to drag the object the parent will be moved instead"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param en true: enable the 'drag parent' for the object"]
    pub fn lv_obj_set_drag_parent(obj: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Propagate the events to the parent too"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param en true: enable the event propagation"]
    pub fn lv_obj_set_parent_event(obj: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_obj_set_base_dir(obj: *mut lv_obj_t, dir: lv_bidi_dir_t);
}
extern "C" {
    #[doc = " Set the opa scale enable parameter (required to set opa_scale with `lv_obj_set_opa_scale()`)"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param en true: opa scaling is enabled for this object and all children; false: no opa scaling"]
    pub fn lv_obj_set_opa_scale_enable(obj: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Set the opa scale of an object."]
    #[doc = " The opacity of this object and all it's children will be scaled down with this factor."]
    #[doc = " `lv_obj_set_opa_scale_enable(obj, true)` needs to be called to enable it."]
    #[doc = " (not for all children just for the parent where to start the opa scaling)"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param opa_scale a factor to scale down opacity [0..255]"]
    pub fn lv_obj_set_opa_scale(obj: *mut lv_obj_t, opa_scale: lv_opa_t);
}
extern "C" {
    #[doc = " Set a bit or bits in the protect filed"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param prot 'OR'-ed values from `lv_protect_t`"]
    pub fn lv_obj_set_protect(obj: *mut lv_obj_t, prot: u8);
}
extern "C" {
    #[doc = " Clear a bit or bits in the protect filed"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param prot 'OR'-ed values from `lv_protect_t`"]
    pub fn lv_obj_clear_protect(obj: *mut lv_obj_t, prot: u8);
}
extern "C" {
    #[doc = " Set a an event handler function for an object."]
    #[doc = " Used by the user to react on event which happens with the object."]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param event_cb the new event function"]
    pub fn lv_obj_set_event_cb(obj: *mut lv_obj_t, event_cb: lv_event_cb_t);
}
extern "C" {
    #[doc = " Send an event to the object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param event the type of the event from `lv_event_t`."]
    #[doc = " @param data arbitrary data depending on the object type and the event. (Usually `NULL`)"]
    #[doc = " @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event"]
    pub fn lv_event_send(
        obj: *mut lv_obj_t,
        event: lv_event_t,
        data: *const cty::c_void,
    ) -> lv_res_t;
}
extern "C" {
    #[doc = " Call an event function with an object, event, and data."]
    #[doc = " @param event_xcb an event callback function. If `NULL` `LV_RES_OK` will return without any actions."]
    #[doc = "        (the 'x' in the argument name indicates that its not a fully generic function because it not follows"]
    #[doc = "         the `func_name(object, callback, ...)` convention)"]
    #[doc = " @param obj pointer to an object to associate with the event (can be `NULL` to simply call the `event_cb`)"]
    #[doc = " @param event an event"]
    #[doc = " @param data pointer to a custom data"]
    #[doc = " @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event"]
    pub fn lv_event_send_func(
        event_xcb: lv_event_cb_t,
        obj: *mut lv_obj_t,
        event: lv_event_t,
        data: *const cty::c_void,
    ) -> lv_res_t;
}
extern "C" {
    #[doc = " Get the `data` parameter of the current event"]
    #[doc = " @return the `data` parameter"]
    pub fn lv_event_get_data() -> *const cty::c_void;
}
extern "C" {
    #[doc = " Set the a signal function of an object. Used internally by the library."]
    #[doc = " Always call the previous signal function in the new."]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param signal_cb the new signal function"]
    pub fn lv_obj_set_signal_cb(obj: *mut lv_obj_t, signal_cb: lv_signal_cb_t);
}
extern "C" {
    #[doc = " Send an event to the object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param event the type of the event from `lv_event_t`."]
    pub fn lv_signal_send(obj: *mut lv_obj_t, signal: lv_signal_t, param: *mut cty::c_void);
}
extern "C" {
    #[doc = " Set a new design function for an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param design_cb the new design function"]
    pub fn lv_obj_set_design_cb(obj: *mut lv_obj_t, design_cb: lv_design_cb_t);
}
extern "C" {
    #[doc = " Allocate a new ext. data for an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param ext_size the size of the new ext. data"]
    #[doc = " @return pointer to the allocated ext"]
    pub fn lv_obj_allocate_ext_attr(obj: *mut lv_obj_t, ext_size: u16) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Send a 'LV_SIGNAL_REFR_EXT_SIZE' signal to the object"]
    #[doc = " @param obj pointer to an object"]
    pub fn lv_obj_refresh_ext_draw_pad(obj: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Return with the screen of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return pointer to a screen"]
    pub fn lv_obj_get_screen(obj: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Get the display of an object"]
    #[doc = " @param scr pointer to an object"]
    #[doc = " @return pointer the object's display"]
    pub fn lv_obj_get_disp(obj: *const lv_obj_t) -> *mut lv_disp_t;
}
extern "C" {
    #[doc = " Returns with the parent of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return pointer to the parent of  'obj'"]
    pub fn lv_obj_get_parent(obj: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Iterate through the children of an object (start from the \"youngest, lastly created\")"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param child NULL at first call to get the next children"]
    #[doc = "                  and the previous return value later"]
    #[doc = " @return the child after 'act_child' or NULL if no more child"]
    pub fn lv_obj_get_child(obj: *const lv_obj_t, child: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Iterate through the children of an object (start from the \"oldest\", firstly created)"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param child NULL at first call to get the next children"]
    #[doc = "                  and the previous return value later"]
    #[doc = " @return the child after 'act_child' or NULL if no more child"]
    pub fn lv_obj_get_child_back(obj: *const lv_obj_t, child: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Count the children of an object (only children directly on 'obj')"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return children number of 'obj'"]
    pub fn lv_obj_count_children(obj: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Recursively count the children of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return children number of 'obj'"]
    pub fn lv_obj_count_children_recursive(obj: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Copy the coordinates of an object to an area"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param cords_p pointer to an area to store the coordinates"]
    pub fn lv_obj_get_coords(obj: *const lv_obj_t, cords_p: *mut lv_area_t);
}
extern "C" {
    #[doc = " Reduce area retried by `lv_obj_get_coords()` the get graphically usable area of an object."]
    #[doc = " (Without the size of the border or other extra graphical elements)"]
    #[doc = " @param coords_p store the result area here"]
    pub fn lv_obj_get_inner_coords(obj: *const lv_obj_t, coords_p: *mut lv_area_t);
}
extern "C" {
    #[doc = " Get the x coordinate of object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return distance of 'obj' from the left side of its parent"]
    pub fn lv_obj_get_x(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get the y coordinate of object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return distance of 'obj' from the top of its parent"]
    pub fn lv_obj_get_y(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get the width of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return the width"]
    pub fn lv_obj_get_width(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get the height of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return the height"]
    pub fn lv_obj_get_height(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get that width reduced by the left and right padding."]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return the width which still fits into the container"]
    pub fn lv_obj_get_width_fit(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get that height reduced by the top an bottom padding."]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return the height which still fits into the container"]
    pub fn lv_obj_get_height_fit(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get the automatic realign property of the object."]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return  true: auto realign is enabled; false: auto realign is disabled"]
    pub fn lv_obj_get_auto_realign(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get the left padding of extended clickable area"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return the extended left padding"]
    pub fn lv_obj_get_ext_click_pad_left(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get the right padding of extended clickable area"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return the extended right padding"]
    pub fn lv_obj_get_ext_click_pad_right(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get the top padding of extended clickable area"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return the extended top padding"]
    pub fn lv_obj_get_ext_click_pad_top(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get the bottom padding of extended clickable area"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return the extended bottom padding"]
    pub fn lv_obj_get_ext_click_pad_bottom(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get the extended size attribute of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return the extended size attribute"]
    pub fn lv_obj_get_ext_draw_pad(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get the style pointer of an object (if NULL get style of the parent)"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return pointer to a style"]
    pub fn lv_obj_get_style(obj: *const lv_obj_t) -> *const lv_style_t;
}
extern "C" {
    #[doc = " Get the hidden attribute of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return true: the object is hidden"]
    pub fn lv_obj_get_hidden(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get the click enable attribute of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return true: the object is clickable"]
    pub fn lv_obj_get_click(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get the top enable attribute of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return true: the auto top feature is enabled"]
    pub fn lv_obj_get_top(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get the drag enable attribute of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return true: the object is dragable"]
    pub fn lv_obj_get_drag(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get the directions an object can be dragged"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return bitwise OR of allowed directions an object can be dragged in"]
    pub fn lv_obj_get_drag_dir(obj: *const lv_obj_t) -> lv_drag_dir_t;
}
extern "C" {
    #[doc = " Get the drag throw enable attribute of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return true: drag throw is enabled"]
    pub fn lv_obj_get_drag_throw(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get the drag parent attribute of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return true: drag parent is enabled"]
    pub fn lv_obj_get_drag_parent(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get the drag parent attribute of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return true: drag parent is enabled"]
    pub fn lv_obj_get_parent_event(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_obj_get_base_dir(obj: *const lv_obj_t) -> lv_bidi_dir_t;
}
extern "C" {
    #[doc = " Get the opa scale enable parameter"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return true: opa scaling is enabled for this object and all children; false: no opa scaling"]
    pub fn lv_obj_get_opa_scale_enable(obj: *const lv_obj_t) -> lv_opa_t;
}
extern "C" {
    #[doc = " Get the opa scale parameter of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return opa scale [0..255]"]
    pub fn lv_obj_get_opa_scale(obj: *const lv_obj_t) -> lv_opa_t;
}
extern "C" {
    #[doc = " Get the protect field of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return protect field ('OR'ed values of `lv_protect_t`)"]
    pub fn lv_obj_get_protect(obj: *const lv_obj_t) -> u8;
}
extern "C" {
    #[doc = " Check at least one bit of a given protect bitfield is set"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param prot protect bits to test ('OR'ed values of `lv_protect_t`)"]
    #[doc = " @return false: none of the given bits are set, true: at least one bit is set"]
    pub fn lv_obj_is_protected(obj: *const lv_obj_t, prot: u8) -> bool;
}
extern "C" {
    #[doc = " Get the signal function of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return the signal function"]
    pub fn lv_obj_get_signal_cb(obj: *const lv_obj_t) -> lv_signal_cb_t;
}
extern "C" {
    #[doc = " Get the design function of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return the design function"]
    pub fn lv_obj_get_design_cb(obj: *const lv_obj_t) -> lv_design_cb_t;
}
extern "C" {
    #[doc = " Get the event function of an object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return the event function"]
    pub fn lv_obj_get_event_cb(obj: *const lv_obj_t) -> lv_event_cb_t;
}
extern "C" {
    #[doc = " Get the ext pointer"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return the ext pointer but not the dynamic version"]
    #[doc = "         Use it as ext->data1, and NOT da(ext)->data1"]
    pub fn lv_obj_get_ext_attr(obj: *const lv_obj_t) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Get object's and its ancestors type. Put their name in `type_buf` starting with the current type."]
    #[doc = " E.g. buf.type[0]=\"lv_btn\", buf.type[1]=\"lv_cont\", buf.type[2]=\"lv_obj\""]
    #[doc = " @param obj pointer to an object which type should be get"]
    #[doc = " @param buf pointer to an `lv_obj_type_t` buffer to store the types"]
    pub fn lv_obj_get_type(obj: *const lv_obj_t, buf: *mut lv_obj_type_t);
}
extern "C" {
    #[doc = " Get the object's user data"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return user data"]
    pub fn lv_obj_get_user_data(obj: *const lv_obj_t) -> lv_obj_user_data_t;
}
extern "C" {
    #[doc = " Get a pointer to the object's user data"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return pointer to the user data"]
    pub fn lv_obj_get_user_data_ptr(obj: *const lv_obj_t) -> *mut lv_obj_user_data_t;
}
extern "C" {
    #[doc = " Set the object's user data. The data will be copied."]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @param data user data"]
    pub fn lv_obj_set_user_data(obj: *mut lv_obj_t, data: lv_obj_user_data_t);
}
extern "C" {
    #[doc = " Get the group of the object"]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return the pointer to group of the object"]
    pub fn lv_obj_get_group(obj: *const lv_obj_t) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Tell whether the object is the focused object of a group or not."]
    #[doc = " @param obj pointer to an object"]
    #[doc = " @return true: the object is focused, false: the object is not focused or not in a group"]
    pub fn lv_obj_is_focused(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Used in the signal callback to handle `LV_SIGNAL_GET_TYPE` signal"]
    #[doc = " @param buf pointer to `lv_obj_type_t`. (`param` in the signal callback)"]
    #[doc = " @param name name of the object. E.g. \"lv_btn\". (Only the pointer is saved)"]
    #[doc = " @return LV_RES_OK"]
    pub fn lv_obj_handle_get_type_signal(
        buf: *mut lv_obj_type_t,
        name: *const cty::c_char,
    ) -> lv_res_t;
}
pub const LV_KEY_UP: _bindgen_ty_18 = 17;
pub const LV_KEY_DOWN: _bindgen_ty_18 = 18;
pub const LV_KEY_RIGHT: _bindgen_ty_18 = 19;
pub const LV_KEY_LEFT: _bindgen_ty_18 = 20;
pub const LV_KEY_ESC: _bindgen_ty_18 = 27;
pub const LV_KEY_DEL: _bindgen_ty_18 = 127;
pub const LV_KEY_BACKSPACE: _bindgen_ty_18 = 8;
pub const LV_KEY_ENTER: _bindgen_ty_18 = 10;
pub const LV_KEY_NEXT: _bindgen_ty_18 = 9;
pub const LV_KEY_PREV: _bindgen_ty_18 = 11;
pub const LV_KEY_HOME: _bindgen_ty_18 = 2;
pub const LV_KEY_END: _bindgen_ty_18 = 3;
#[doc = "      DEFINES"]
pub type _bindgen_ty_18 = u32;
pub type lv_key_t = u8;
pub type lv_group_style_mod_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_group_t, arg2: *mut lv_style_t)>;
pub type lv_group_focus_cb_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_group_t)>;
#[doc = " Groups can be used to logically hold objects so that they can be individually focused."]
#[doc = " They are NOT for laying out objects on a screen (try `lv_cont` for that)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _lv_group_t {
    #[doc = "< Linked list to store the objects in the group"]
    pub obj_ll: lv_ll_t,
    #[doc = "< The object in focus"]
    pub obj_focus: *mut *mut lv_obj_t,
    #[doc = "< A function to modifies the style of the focused object"]
    pub style_mod_cb: lv_group_style_mod_cb_t,
    #[doc = "< A function which modifies the style of the edited object"]
    pub style_mod_edit_cb: lv_group_style_mod_cb_t,
    #[doc = "< A function to call when a new object is focused (optional)"]
    pub focus_cb: lv_group_focus_cb_t,
    #[doc = "< Stores the modified style of the focused object"]
    pub style_tmp: lv_style_t,
    pub user_data: lv_group_user_data_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl _lv_group_t {
    #[inline]
    pub fn frozen(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_frozen(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn editing(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_editing(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn click_focus(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_click_focus(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn refocus_policy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_refocus_policy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wrap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wrap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frozen: u8,
        editing: u8,
        click_focus: u8,
        refocus_policy: u8,
        wrap: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frozen: u8 = unsafe { ::core::mem::transmute(frozen) };
            frozen as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let editing: u8 = unsafe { ::core::mem::transmute(editing) };
            editing as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let click_focus: u8 = unsafe { ::core::mem::transmute(click_focus) };
            click_focus as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let refocus_policy: u8 = unsafe { ::core::mem::transmute(refocus_policy) };
            refocus_policy as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let wrap: u8 = unsafe { ::core::mem::transmute(wrap) };
            wrap as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_group_t = _lv_group_t;
pub const LV_GROUP_REFOCUS_POLICY_NEXT: _bindgen_ty_19 = 0;
pub const LV_GROUP_REFOCUS_POLICY_PREV: _bindgen_ty_19 = 1;
pub type _bindgen_ty_19 = u32;
pub type lv_group_refocus_policy_t = u8;
extern "C" {
    #[doc = " Init. the group module"]
    #[doc = " @remarks Internal function, do not call directly."]
    pub fn lv_group_init();
}
extern "C" {
    #[doc = " Create a new object group"]
    #[doc = " @return pointer to the new object group"]
    pub fn lv_group_create() -> *mut lv_group_t;
}
extern "C" {
    #[doc = " Delete a group object"]
    #[doc = " @param group pointer to a group"]
    pub fn lv_group_del(group: *mut lv_group_t);
}
extern "C" {
    #[doc = " Add an object to a group"]
    #[doc = " @param group pointer to a group"]
    #[doc = " @param obj pointer to an object to add"]
    pub fn lv_group_add_obj(group: *mut lv_group_t, obj: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Remove an object from its group"]
    #[doc = " @param obj pointer to an object to remove"]
    pub fn lv_group_remove_obj(obj: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Remove all objects from a group"]
    #[doc = " @param group pointer to a group"]
    pub fn lv_group_remove_all_objs(group: *mut lv_group_t);
}
extern "C" {
    #[doc = " Focus on an object (defocus the current)"]
    #[doc = " @param obj pointer to an object to focus on"]
    pub fn lv_group_focus_obj(obj: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Focus the next object in a group (defocus the current)"]
    #[doc = " @param group pointer to a group"]
    pub fn lv_group_focus_next(group: *mut lv_group_t);
}
extern "C" {
    #[doc = " Focus the previous object in a group (defocus the current)"]
    #[doc = " @param group pointer to a group"]
    pub fn lv_group_focus_prev(group: *mut lv_group_t);
}
extern "C" {
    #[doc = " Do not let to change the focus from the current object"]
    #[doc = " @param group pointer to a group"]
    #[doc = " @param en true: freeze, false: release freezing (normal mode)"]
    pub fn lv_group_focus_freeze(group: *mut lv_group_t, en: bool);
}
extern "C" {
    #[doc = " Send a control character to the focuses object of a group"]
    #[doc = " @param group pointer to a group"]
    #[doc = " @param c a character (use LV_KEY_.. to navigate)"]
    #[doc = " @return result of focused object in group."]
    pub fn lv_group_send_data(group: *mut lv_group_t, c: u32) -> lv_res_t;
}
extern "C" {
    #[doc = " Set a function for a group which will modify the object's style if it is in focus"]
    #[doc = " @param group pointer to a group"]
    #[doc = " @param style_mod_cb the style modifier function pointer"]
    pub fn lv_group_set_style_mod_cb(group: *mut lv_group_t, style_mod_cb: lv_group_style_mod_cb_t);
}
extern "C" {
    #[doc = " Set a function for a group which will modify the object's style if it is in focus in edit mode"]
    #[doc = " @param group pointer to a group"]
    #[doc = " @param style_mod_edit_cb the style modifier function pointer"]
    pub fn lv_group_set_style_mod_edit_cb(
        group: *mut lv_group_t,
        style_mod_edit_cb: lv_group_style_mod_cb_t,
    );
}
extern "C" {
    #[doc = " Set a function for a group which will be called when a new object is focused"]
    #[doc = " @param group pointer to a group"]
    #[doc = " @param focus_cb the call back function or NULL if unused"]
    pub fn lv_group_set_focus_cb(group: *mut lv_group_t, focus_cb: lv_group_focus_cb_t);
}
extern "C" {
    #[doc = " Set whether the next or previous item in a group is focused if the currently focussed obj is"]
    #[doc = " deleted."]
    #[doc = " @param group pointer to a group"]
    #[doc = " @param new refocus policy enum"]
    pub fn lv_group_set_refocus_policy(group: *mut lv_group_t, policy: lv_group_refocus_policy_t);
}
extern "C" {
    #[doc = " Manually set the current mode (edit or navigate)."]
    #[doc = " @param group pointer to group"]
    #[doc = " @param edit: true: edit mode; false: navigate mode"]
    pub fn lv_group_set_editing(group: *mut lv_group_t, edit: bool);
}
extern "C" {
    #[doc = " Set the `click_focus` attribute. If enabled then the object will be focused then it is clicked."]
    #[doc = " @param group pointer to group"]
    #[doc = " @param en: true: enable `click_focus`"]
    pub fn lv_group_set_click_focus(group: *mut lv_group_t, en: bool);
}
extern "C" {
    #[doc = " Set whether focus next/prev will allow wrapping from first->last or last->first object."]
    #[doc = " @param group pointer to group"]
    #[doc = " @param en: true: wrapping enabled; false: wrapping disabled"]
    pub fn lv_group_set_wrap(group: *mut lv_group_t, en: bool);
}
extern "C" {
    #[doc = " Modify a style with the set 'style_mod' function. The input style remains unchanged."]
    #[doc = " @param group pointer to group"]
    #[doc = " @param style pointer to a style to modify"]
    #[doc = " @return a copy of the input style but modified with the 'style_mod' function"]
    pub fn lv_group_mod_style(group: *mut lv_group_t, style: *const lv_style_t) -> *mut lv_style_t;
}
extern "C" {
    #[doc = " Get the focused object or NULL if there isn't one"]
    #[doc = " @param group pointer to a group"]
    #[doc = " @return pointer to the focused object"]
    pub fn lv_group_get_focused(group: *const lv_group_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Get a pointer to the group's user data"]
    #[doc = " @param group pointer to an group"]
    #[doc = " @return pointer to the user data"]
    pub fn lv_group_get_user_data(group: *mut lv_group_t) -> *mut lv_group_user_data_t;
}
extern "C" {
    #[doc = " Get a the style modifier function of a group"]
    #[doc = " @param group pointer to a group"]
    #[doc = " @return pointer to the style modifier function"]
    pub fn lv_group_get_style_mod_cb(group: *const lv_group_t) -> lv_group_style_mod_cb_t;
}
extern "C" {
    #[doc = " Get a the style modifier function of a group in edit mode"]
    #[doc = " @param group pointer to a group"]
    #[doc = " @return pointer to the style modifier function"]
    pub fn lv_group_get_style_mod_edit_cb(group: *const lv_group_t) -> lv_group_style_mod_cb_t;
}
extern "C" {
    #[doc = " Get the focus callback function of a group"]
    #[doc = " @param group pointer to a group"]
    #[doc = " @return the call back function or NULL if not set"]
    pub fn lv_group_get_focus_cb(group: *const lv_group_t) -> lv_group_focus_cb_t;
}
extern "C" {
    #[doc = " Get the current mode (edit or navigate)."]
    #[doc = " @param group pointer to group"]
    #[doc = " @return true: edit mode; false: navigate mode"]
    pub fn lv_group_get_editing(group: *const lv_group_t) -> bool;
}
extern "C" {
    #[doc = " Get the `click_focus` attribute."]
    #[doc = " @param group pointer to group"]
    #[doc = " @return true: `click_focus` is enabled; false: disabled"]
    pub fn lv_group_get_click_focus(group: *const lv_group_t) -> bool;
}
extern "C" {
    #[doc = " Get whether focus next/prev will allow wrapping from first->last or last->first object."]
    #[doc = " @param group pointer to group"]
    #[doc = " @param en: true: wrapping enabled; false: wrapping disabled"]
    pub fn lv_group_get_wrap(group: *mut lv_group_t) -> bool;
}
extern "C" {
    #[doc = " Notify the group that current theme changed and style modification callbacks need to be"]
    #[doc = " refreshed."]
    #[doc = " @param group pointer to group. If NULL then all groups are notified."]
    pub fn lv_group_report_style_mod(group: *mut lv_group_t);
}
extern "C" {
    #[doc = " Initialize the display input device subsystem"]
    pub fn lv_indev_init();
}
extern "C" {
    #[doc = " Called periodically to read the input devices"]
    #[doc = " @param task pointer to the task itself"]
    pub fn lv_indev_read_task(task: *mut lv_task_t);
}
extern "C" {
    #[doc = " Get the currently processed input device. Can be used in action functions too."]
    #[doc = " @return pointer to the currently processed input device or NULL if no input device processing"]
    #[doc = " right now"]
    pub fn lv_indev_get_act() -> *mut lv_indev_t;
}
extern "C" {
    #[doc = " Get the type of an input device"]
    #[doc = " @param indev pointer to an input device"]
    #[doc = " @return the type of the input device from `lv_hal_indev_type_t` (`LV_INDEV_TYPE_...`)"]
    pub fn lv_indev_get_type(indev: *const lv_indev_t) -> lv_indev_type_t;
}
extern "C" {
    #[doc = " Reset one or all input devices"]
    #[doc = " @param indev pointer to an input device to reset or NULL to reset all of them"]
    pub fn lv_indev_reset(indev: *mut lv_indev_t);
}
extern "C" {
    #[doc = " Reset the long press state of an input device"]
    #[doc = " @param indev_proc pointer to an input device"]
    pub fn lv_indev_reset_long_press(indev: *mut lv_indev_t);
}
extern "C" {
    #[doc = " Enable or disable an input devices"]
    #[doc = " @param indev pointer to an input device"]
    #[doc = " @param en true: enable; false: disable"]
    pub fn lv_indev_enable(indev: *mut lv_indev_t, en: bool);
}
extern "C" {
    #[doc = " Set a cursor for a pointer input device (for LV_INPUT_TYPE_POINTER and LV_INPUT_TYPE_BUTTON)"]
    #[doc = " @param indev pointer to an input device"]
    #[doc = " @param cur_obj pointer to an object to be used as cursor"]
    pub fn lv_indev_set_cursor(indev: *mut lv_indev_t, cur_obj: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Set a destination group for a keypad input device (for LV_INDEV_TYPE_KEYPAD)"]
    #[doc = " @param indev pointer to an input device"]
    #[doc = " @param group point to a group"]
    pub fn lv_indev_set_group(indev: *mut lv_indev_t, group: *mut lv_group_t);
}
extern "C" {
    #[doc = " Set the an array of points for LV_INDEV_TYPE_BUTTON."]
    #[doc = " These points will be assigned to the buttons to press a specific point on the screen"]
    #[doc = " @param indev pointer to an input device"]
    #[doc = " @param group point to a group"]
    pub fn lv_indev_set_button_points(indev: *mut lv_indev_t, points: *const lv_point_t);
}
extern "C" {
    #[doc = " Get the last point of an input device (for LV_INDEV_TYPE_POINTER and LV_INDEV_TYPE_BUTTON)"]
    #[doc = " @param indev pointer to an input device"]
    #[doc = " @param point pointer to a point to store the result"]
    pub fn lv_indev_get_point(indev: *const lv_indev_t, point: *mut lv_point_t);
}
extern "C" {
    #[doc = " Get the last pressed key of an input device (for LV_INDEV_TYPE_KEYPAD)"]
    #[doc = " @param indev pointer to an input device"]
    #[doc = " @return the last pressed key (0 on error)"]
    pub fn lv_indev_get_key(indev: *const lv_indev_t) -> u32;
}
extern "C" {
    #[doc = " Check if there is dragging with an input device or not (for LV_INDEV_TYPE_POINTER and"]
    #[doc = " LV_INDEV_TYPE_BUTTON)"]
    #[doc = " @param indev pointer to an input device"]
    #[doc = " @return true: drag is in progress"]
    pub fn lv_indev_is_dragging(indev: *const lv_indev_t) -> bool;
}
extern "C" {
    #[doc = " Get the vector of dragging of an input device (for LV_INDEV_TYPE_POINTER and"]
    #[doc = " LV_INDEV_TYPE_BUTTON)"]
    #[doc = " @param indev pointer to an input device"]
    #[doc = " @param point pointer to a point to store the vector"]
    pub fn lv_indev_get_vect(indev: *const lv_indev_t, point: *mut lv_point_t);
}
extern "C" {
    #[doc = " Do nothing until the next release"]
    #[doc = " @param indev pointer to an input device"]
    pub fn lv_indev_wait_release(indev: *mut lv_indev_t);
}
extern "C" {
    #[doc = " Get a pointer to the indev read task to"]
    #[doc = " modify its parameters with `lv_task_...` functions."]
    #[doc = " @param indev pointer to an inout device"]
    #[doc = " @return pointer to the indev read refresher task. (NULL on error)"]
    pub fn lv_indev_get_read_task(indev: *mut lv_disp_t) -> *mut lv_task_t;
}
extern "C" {
    #[doc = " Gets a pointer to the currently active object in indev proc functions."]
    #[doc = " NULL if no object is currently being handled or if groups aren't used."]
    #[doc = " @return pointer to currently active object"]
    pub fn lv_indev_get_obj_act() -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Initialize the screen refresh subsystem"]
    pub fn lv_refr_init();
}
extern "C" {
    #[doc = " Redraw the invalidated areas now."]
    #[doc = " Normally the redrawing is periodically executed in `lv_task_handler` but a long blocking process"]
    #[doc = " can prevent the call of `lv_task_handler`. In this case if the the GUI is updated in the process"]
    #[doc = " (e.g. progress bar) this function can be called when the screen should be updated."]
    #[doc = " @param disp pointer to display to refresh. NULL to refresh all displays."]
    pub fn lv_refr_now(disp: *mut lv_disp_t);
}
extern "C" {
    #[doc = " Invalidate an area on display to redraw it"]
    #[doc = " @param area_p pointer to area which should be invalidated (NULL: delete the invalidated areas)"]
    #[doc = " @param disp pointer to display where the area should be invalidated (NULL can be used if there is"]
    #[doc = " only one display)"]
    pub fn lv_inv_area(disp: *mut lv_disp_t, area_p: *const lv_area_t);
}
extern "C" {
    #[doc = " Get the display which is being refreshed"]
    #[doc = " @return the display being refreshed"]
    pub fn lv_refr_get_disp_refreshing() -> *mut lv_disp_t;
}
extern "C" {
    #[doc = " Set the display which is being refreshed."]
    #[doc = " It shouldn1t be used directly by the user."]
    #[doc = " It can be used to trick the drawing functions about there is an active display."]
    #[doc = " @param the display being refreshed"]
    pub fn lv_refr_set_disp_refreshing(disp: *mut lv_disp_t);
}
extern "C" {
    #[doc = " Called periodically to handle the refreshing"]
    #[doc = " @param task pointer to the task itself"]
    pub fn lv_disp_refr_task(task: *mut lv_task_t);
}
extern "C" {
    #[doc = " Return with a pointer to the active screen"]
    #[doc = " @param disp pointer to display which active screen should be get. (NULL to use the default"]
    #[doc = " screen)"]
    #[doc = " @return pointer to the active screen object (loaded by 'lv_scr_load()')"]
    pub fn lv_disp_get_scr_act(disp: *mut lv_disp_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Make a screen active"]
    #[doc = " @param scr pointer to a screen"]
    pub fn lv_disp_load_scr(scr: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Return with the top layer. (Same on every screen and it is above the normal screen layer)"]
    #[doc = " @param disp pointer to display which top layer should be get. (NULL to use the default screen)"]
    #[doc = " @return pointer to the top layer object  (transparent screen sized lv_obj)"]
    pub fn lv_disp_get_layer_top(disp: *mut lv_disp_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Return with the sys. layer. (Same on every screen and it is above the normal screen and the top"]
    #[doc = " layer)"]
    #[doc = " @param disp pointer to display which sys. layer  should be get. (NULL to use the default screen)"]
    #[doc = " @return pointer to the sys layer object  (transparent screen sized lv_obj)"]
    pub fn lv_disp_get_layer_sys(disp: *mut lv_disp_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Assign a screen to a display."]
    #[doc = " @param disp pointer to a display where to assign the screen"]
    #[doc = " @param scr pointer to a screen object to assign"]
    pub fn lv_disp_assign_screen(disp: *mut lv_disp_t, scr: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Get a pointer to the screen refresher task to"]
    #[doc = " modify its parameters with `lv_task_...` functions."]
    #[doc = " @param disp pointer to a display"]
    #[doc = " @return pointer to the display refresher task. (NULL on error)"]
    pub fn lv_disp_get_refr_task(disp: *mut lv_disp_t) -> *mut lv_task_t;
}
extern "C" {
    #[doc = " Get elapsed time since last user activity on a display (e.g. click)"]
    #[doc = " @param disp pointer to an display (NULL to get the overall smallest inactivity)"]
    #[doc = " @return elapsed ticks (milliseconds) since the last activity"]
    pub fn lv_disp_get_inactive_time(disp: *const lv_disp_t) -> u32;
}
extern "C" {
    #[doc = " Manually trigger an activity on a display"]
    #[doc = " @param disp pointer to an display (NULL to use the default display)"]
    pub fn lv_disp_trig_activity(disp: *mut lv_disp_t);
}
#[doc = " A theme in LittlevGL consists of many styles bound together."]
#[doc = ""]
#[doc = " There is a style for each object type, as well as a generic style for"]
#[doc = " backgrounds and panels."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t {
    pub style: lv_theme_t__bindgen_ty_1,
    pub group: lv_theme_t__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1 {
    pub scr: *mut lv_style_t,
    pub bg: *mut lv_style_t,
    pub panel: *mut lv_style_t,
    pub cont: *mut lv_style_t,
    pub btn: lv_theme_t__bindgen_ty_1__bindgen_ty_1,
    pub imgbtn: lv_theme_t__bindgen_ty_1__bindgen_ty_2,
    pub label: lv_theme_t__bindgen_ty_1__bindgen_ty_3,
    pub img: lv_theme_t__bindgen_ty_1__bindgen_ty_4,
    pub line: lv_theme_t__bindgen_ty_1__bindgen_ty_5,
    pub led: *mut lv_style_t,
    pub bar: lv_theme_t__bindgen_ty_1__bindgen_ty_6,
    pub slider: lv_theme_t__bindgen_ty_1__bindgen_ty_7,
    pub lmeter: *mut lv_style_t,
    pub gauge: *mut lv_style_t,
    pub arc: *mut lv_style_t,
    pub preload: *mut lv_style_t,
    pub sw: lv_theme_t__bindgen_ty_1__bindgen_ty_8,
    pub chart: *mut lv_style_t,
    pub calendar: lv_theme_t__bindgen_ty_1__bindgen_ty_9,
    pub cb: lv_theme_t__bindgen_ty_1__bindgen_ty_10,
    pub btnm: lv_theme_t__bindgen_ty_1__bindgen_ty_11,
    pub kb: lv_theme_t__bindgen_ty_1__bindgen_ty_12,
    pub mbox: lv_theme_t__bindgen_ty_1__bindgen_ty_13,
    pub page: lv_theme_t__bindgen_ty_1__bindgen_ty_14,
    pub ta: lv_theme_t__bindgen_ty_1__bindgen_ty_15,
    pub spinbox: lv_theme_t__bindgen_ty_1__bindgen_ty_16,
    pub list: lv_theme_t__bindgen_ty_1__bindgen_ty_17,
    pub ddlist: lv_theme_t__bindgen_ty_1__bindgen_ty_18,
    pub roller: lv_theme_t__bindgen_ty_1__bindgen_ty_19,
    pub tabview: lv_theme_t__bindgen_ty_1__bindgen_ty_20,
    pub tileview: lv_theme_t__bindgen_ty_1__bindgen_ty_21,
    pub table: lv_theme_t__bindgen_ty_1__bindgen_ty_22,
    pub win: lv_theme_t__bindgen_ty_1__bindgen_ty_23,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_1 {
    pub rel: *mut lv_style_t,
    pub pr: *mut lv_style_t,
    pub tgl_rel: *mut lv_style_t,
    pub tgl_pr: *mut lv_style_t,
    pub ina: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_2 {
    pub rel: *mut lv_style_t,
    pub pr: *mut lv_style_t,
    pub tgl_rel: *mut lv_style_t,
    pub tgl_pr: *mut lv_style_t,
    pub ina: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_3 {
    pub prim: *mut lv_style_t,
    pub sec: *mut lv_style_t,
    pub hint: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_4 {
    pub light: *mut lv_style_t,
    pub dark: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_5 {
    pub decor: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_6 {
    pub bg: *mut lv_style_t,
    pub indic: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_7 {
    pub bg: *mut lv_style_t,
    pub indic: *mut lv_style_t,
    pub knob: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_8 {
    pub bg: *mut lv_style_t,
    pub indic: *mut lv_style_t,
    pub knob_off: *mut lv_style_t,
    pub knob_on: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_9 {
    pub bg: *mut lv_style_t,
    pub header: *mut lv_style_t,
    pub header_pr: *mut lv_style_t,
    pub day_names: *mut lv_style_t,
    pub highlighted_days: *mut lv_style_t,
    pub inactive_days: *mut lv_style_t,
    pub week_box: *mut lv_style_t,
    pub today_box: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_10 {
    pub bg: *mut lv_style_t,
    pub box_: lv_theme_t__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_10__bindgen_ty_1 {
    pub rel: *mut lv_style_t,
    pub pr: *mut lv_style_t,
    pub tgl_rel: *mut lv_style_t,
    pub tgl_pr: *mut lv_style_t,
    pub ina: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_11 {
    pub bg: *mut lv_style_t,
    pub btn: lv_theme_t__bindgen_ty_1__bindgen_ty_11__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_11__bindgen_ty_1 {
    pub rel: *mut lv_style_t,
    pub pr: *mut lv_style_t,
    pub tgl_rel: *mut lv_style_t,
    pub tgl_pr: *mut lv_style_t,
    pub ina: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_12 {
    pub bg: *mut lv_style_t,
    pub btn: lv_theme_t__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1 {
    pub rel: *mut lv_style_t,
    pub pr: *mut lv_style_t,
    pub tgl_rel: *mut lv_style_t,
    pub tgl_pr: *mut lv_style_t,
    pub ina: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_13 {
    pub bg: *mut lv_style_t,
    pub btn: lv_theme_t__bindgen_ty_1__bindgen_ty_13__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_13__bindgen_ty_1 {
    pub bg: *mut lv_style_t,
    pub rel: *mut lv_style_t,
    pub pr: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_14 {
    pub bg: *mut lv_style_t,
    pub scrl: *mut lv_style_t,
    pub sb: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_15 {
    pub area: *mut lv_style_t,
    pub oneline: *mut lv_style_t,
    pub cursor: *mut lv_style_t,
    pub sb: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_16 {
    pub bg: *mut lv_style_t,
    pub cursor: *mut lv_style_t,
    pub sb: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_17 {
    pub bg: *mut lv_style_t,
    pub scrl: *mut lv_style_t,
    pub sb: *mut lv_style_t,
    pub btn: lv_theme_t__bindgen_ty_1__bindgen_ty_17__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_17__bindgen_ty_1 {
    pub rel: *mut lv_style_t,
    pub pr: *mut lv_style_t,
    pub tgl_rel: *mut lv_style_t,
    pub tgl_pr: *mut lv_style_t,
    pub ina: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_18 {
    pub bg: *mut lv_style_t,
    pub sel: *mut lv_style_t,
    pub sb: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_19 {
    pub bg: *mut lv_style_t,
    pub sel: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_20 {
    pub bg: *mut lv_style_t,
    pub indic: *mut lv_style_t,
    pub btn: lv_theme_t__bindgen_ty_1__bindgen_ty_20__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_20__bindgen_ty_1 {
    pub bg: *mut lv_style_t,
    pub rel: *mut lv_style_t,
    pub pr: *mut lv_style_t,
    pub tgl_rel: *mut lv_style_t,
    pub tgl_pr: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_21 {
    pub bg: *mut lv_style_t,
    pub scrl: *mut lv_style_t,
    pub sb: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_22 {
    pub bg: *mut lv_style_t,
    pub cell: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_23 {
    pub bg: *mut lv_style_t,
    pub sb: *mut lv_style_t,
    pub header: *mut lv_style_t,
    pub content: *mut lv_style_t,
    pub btn: lv_theme_t__bindgen_ty_1__bindgen_ty_23__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_1__bindgen_ty_23__bindgen_ty_1 {
    pub rel: *mut lv_style_t,
    pub pr: *mut lv_style_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_theme_t__bindgen_ty_2 {
    pub style_mod_xcb: lv_group_style_mod_cb_t,
    pub style_mod_edit_xcb: lv_group_style_mod_cb_t,
}
extern "C" {
    #[doc = " Set a theme for the system."]
    #[doc = " From now, all the created objects will use styles from this theme by default"]
    #[doc = " @param th pointer to theme (return value of: 'lv_theme_init_xxx()')"]
    pub fn lv_theme_set_current(th: *mut lv_theme_t);
}
extern "C" {
    #[doc = " Get the current system theme."]
    #[doc = " @return pointer to the current system theme. NULL if not set."]
    pub fn lv_theme_get_current() -> *mut lv_theme_t;
}
#[doc = " This describes a glyph."]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct lv_font_fmt_txt_glyph_dsc_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    #[doc = "< Width of the glyph's bounding box"]
    pub box_w: u8,
    #[doc = "< Height of the glyph's bounding box"]
    pub box_h: u8,
    #[doc = "< x offset of the bounding box"]
    pub ofs_x: i8,
    #[doc = "< y offset of the bounding box. Measured from the top of the line"]
    pub ofs_y: i8,
}
impl lv_font_fmt_txt_glyph_dsc_t {
    #[inline]
    pub fn bitmap_index(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_bitmap_index(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn adv_w(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_adv_w(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bitmap_index: u32,
        adv_w: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let bitmap_index: u32 = unsafe { ::core::mem::transmute(bitmap_index) };
            bitmap_index as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let adv_w: u32 = unsafe { ::core::mem::transmute(adv_w) };
            adv_w as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY: _bindgen_ty_20 = 0;
pub const LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL: _bindgen_ty_20 = 1;
pub const LV_FONT_FMT_TXT_CMAP_SPARSE_TINY: _bindgen_ty_20 = 2;
pub const LV_FONT_FMT_TXT_CMAP_SPARSE_FULL: _bindgen_ty_20 = 3;
#[doc = " Format of font character map."]
pub type _bindgen_ty_20 = u32;
pub type lv_font_fmt_txt_cmap_type_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_font_fmt_txt_cmap_t {
    #[doc = " First Unicode character for this range"]
    pub range_start: u32,
    #[doc = " Number of Unicode characters related to this range."]
    #[doc = " Last Unicode character = range_start + range_length - 1"]
    pub range_length: u16,
    #[doc = " First glyph ID (array index of `glyph_dsc`) for this range"]
    pub glyph_id_start: u16,
    pub unicode_list: *const u16,
    #[doc = " if(type == LV_FONT_FMT_TXT_CMAP_FORMAT0_...) it's `uint8_t *`"]
    #[doc = " if(type == LV_FONT_FMT_TXT_CMAP_SPARSE_...)  it's `uint16_t *`"]
    pub glyph_id_ofs_list: *const cty::c_void,
    #[doc = " Length of `unicode_list` and/or `glyph_id_ofs_list`"]
    pub list_length: u16,
    #[doc = " Type of this character map"]
    pub type_: lv_font_fmt_txt_cmap_type_t,
}
#[doc = " A simple mapping of kern values from pairs"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_font_fmt_txt_kern_pair_t {
    pub glyph_ids: *const cty::c_void,
    pub values: *const i8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_padding_0: u32,
}
impl lv_font_fmt_txt_kern_pair_t {
    #[inline]
    pub fn pair_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_pair_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn glyph_ids_size(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_glyph_ids_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pair_cnt: u32,
        glyph_ids_size: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let pair_cnt: u32 = unsafe { ::core::mem::transmute(pair_cnt) };
            pair_cnt as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let glyph_ids_size: u32 = unsafe { ::core::mem::transmute(glyph_ids_size) };
            glyph_ids_size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " More complex but more optimal class based kern value storage"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_font_fmt_txt_kern_classes_t {
    pub class_pair_values: *const i8,
    pub left_class_mapping: *const u8,
    pub right_class_mapping: *const u8,
    pub left_class_cnt: u8,
    pub right_class_cnt: u8,
}
pub const lv_font_fmt_txt_bitmap_format_t_LV_FONT_FMT_TXT_PLAIN: lv_font_fmt_txt_bitmap_format_t =
    0;
pub const lv_font_fmt_txt_bitmap_format_t_LV_FONT_FMT_TXT_COMPRESSED:
    lv_font_fmt_txt_bitmap_format_t = 1;
#[doc = " Bitmap formats"]
pub type lv_font_fmt_txt_bitmap_format_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_font_fmt_txt_dsc_t {
    pub glyph_bitmap: *const u8,
    pub glyph_dsc: *const lv_font_fmt_txt_glyph_dsc_t,
    pub cmaps: *const lv_font_fmt_txt_cmap_t,
    pub kern_dsc: *const cty::c_void,
    pub kern_scale: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    pub last_letter: u32,
    pub last_glyph_id: u32,
}
impl lv_font_fmt_txt_dsc_t {
    #[inline]
    pub fn cmap_num(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u16) }
    }
    #[inline]
    pub fn set_cmap_num(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn bpp(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_bpp(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn kern_classes(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_kern_classes(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitmap_format(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_bitmap_format(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cmap_num: u16,
        bpp: u16,
        kern_classes: u16,
        bitmap_format: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let cmap_num: u16 = unsafe { ::core::mem::transmute(cmap_num) };
            cmap_num as u64
        });
        __bindgen_bitfield_unit.set(10usize, 3u8, {
            let bpp: u16 = unsafe { ::core::mem::transmute(bpp) };
            bpp as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let kern_classes: u16 = unsafe { ::core::mem::transmute(kern_classes) };
            kern_classes as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let bitmap_format: u16 = unsafe { ::core::mem::transmute(bitmap_format) };
            bitmap_format as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " Used as `get_glyph_bitmap` callback in LittelvGL's native font format if the font is uncompressed."]
    #[doc = " @param font pointer to font"]
    #[doc = " @param unicode_letter an unicode letter which bitmap should be get"]
    #[doc = " @return pointer to the bitmap or NULL if not found"]
    pub fn lv_font_get_bitmap_fmt_txt(font: *const lv_font_t, letter: u32) -> *const u8;
}
extern "C" {
    #[doc = " Used as `get_glyph_dsc` callback in LittelvGL's native font format if the font is uncompressed."]
    #[doc = " @param font_p pointer to font"]
    #[doc = " @param dsc_out store the result descriptor here"]
    #[doc = " @param letter an UNICODE letter code"]
    #[doc = " @return true: descriptor is successfully loaded into `dsc_out`."]
    #[doc = "         false: the letter was not found, no data is loaded to `dsc_out`"]
    pub fn lv_font_get_glyph_dsc_fmt_txt(
        font: *const lv_font_t,
        dsc_out: *mut lv_font_glyph_dsc_t,
        unicode_letter: u32,
        unicode_letter_next: u32,
    ) -> bool;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
extern "C" {
    #[doc = " Tiny snprintf/vsnprintf implementation"]
    #[doc = " \\param buffer A pointer to the buffer where to store the formatted string"]
    #[doc = " \\param count The maximum number of characters to store in the buffer, including a terminating null character"]
    #[doc = " \\param format A string that specifies the format of the output"]
    #[doc = " \\param va A value identifying a variable arguments list"]
    #[doc = " \\return The number of characters that COULD have been written into the buffer, not counting the terminating"]
    #[doc = "         null character. A value equal or larger than count indicates truncation. Only when the returned value"]
    #[doc = "         is non-negative and less than count, the string has been completely written."]
    pub fn lv_snprintf(
        buffer: *mut cty::c_char,
        count: size_t,
        format: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn lv_vsnprintf(
        buffer: *mut cty::c_char,
        count: size_t,
        format: *const cty::c_char,
        va: *mut __va_list_tag,
    ) -> cty::c_int;
}
#[doc = "< No layout"]
pub const LV_LAYOUT_OFF: _bindgen_ty_21 = 0;
#[doc = "< Center objects"]
pub const LV_LAYOUT_CENTER: _bindgen_ty_21 = 1;
#[doc = "< Column left align"]
pub const LV_LAYOUT_COL_L: _bindgen_ty_21 = 2;
#[doc = "< Column middle align"]
pub const LV_LAYOUT_COL_M: _bindgen_ty_21 = 3;
#[doc = "< Column right align"]
pub const LV_LAYOUT_COL_R: _bindgen_ty_21 = 4;
#[doc = "< Row top align"]
pub const LV_LAYOUT_ROW_T: _bindgen_ty_21 = 5;
#[doc = "< Row middle align"]
pub const LV_LAYOUT_ROW_M: _bindgen_ty_21 = 6;
#[doc = "< Row bottom align"]
pub const LV_LAYOUT_ROW_B: _bindgen_ty_21 = 7;
#[doc = "< Put as many object as possible in row and begin a new row"]
pub const LV_LAYOUT_PRETTY: _bindgen_ty_21 = 8;
#[doc = "< Align same-sized object into a grid"]
pub const LV_LAYOUT_GRID: _bindgen_ty_21 = 9;
pub const _LV_LAYOUT_NUM: _bindgen_ty_21 = 10;
#[doc = " Container layout options"]
pub type _bindgen_ty_21 = u32;
pub type lv_layout_t = u8;
#[doc = "< Do not change the size automatically"]
pub const LV_FIT_NONE: _bindgen_ty_22 = 0;
#[doc = "< Shrink wrap around the children"]
pub const LV_FIT_TIGHT: _bindgen_ty_22 = 1;
#[doc = "< Align the size to the parent's edge"]
pub const LV_FIT_FLOOD: _bindgen_ty_22 = 2;
#[doc = "< Align the size to the parent's edge first but if there is an object out of it"]
#[doc = "then get larger"]
pub const LV_FIT_FILL: _bindgen_ty_22 = 3;
pub const _LV_FIT_NUM: _bindgen_ty_22 = 4;
#[doc = " How to resize the container around the children."]
pub type _bindgen_ty_22 = u32;
pub type lv_fit_t = u8;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct lv_cont_ext_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
impl lv_cont_ext_t {
    #[inline]
    pub fn layout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_layout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn fit_left(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fit_left(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fit_right(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fit_right(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fit_top(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fit_top(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fit_bottom(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fit_bottom(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        layout: u8,
        fit_left: u8,
        fit_right: u8,
        fit_top: u8,
        fit_bottom: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let layout: u8 = unsafe { ::core::mem::transmute(layout) };
            layout as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let fit_left: u8 = unsafe { ::core::mem::transmute(fit_left) };
            fit_left as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let fit_right: u8 = unsafe { ::core::mem::transmute(fit_right) };
            fit_right as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let fit_top: u8 = unsafe { ::core::mem::transmute(fit_top) };
            fit_top as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let fit_bottom: u8 = unsafe { ::core::mem::transmute(fit_bottom) };
            fit_bottom as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_CONT_STYLE_MAIN: _bindgen_ty_23 = 0;
pub type _bindgen_ty_23 = u32;
pub type lv_cont_style_t = u8;
extern "C" {
    #[doc = " Create a container objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new container"]
    #[doc = " @param copy pointer to a container object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created container"]
    pub fn lv_cont_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set a layout on a container"]
    #[doc = " @param cont pointer to a container object"]
    #[doc = " @param layout a layout from 'lv_cont_layout_t'"]
    pub fn lv_cont_set_layout(cont: *mut lv_obj_t, layout: lv_layout_t);
}
extern "C" {
    #[doc = " Set the fit policy in all 4 directions separately."]
    #[doc = " It tell how to change the container's size automatically."]
    #[doc = " @param cont pointer to a container object"]
    #[doc = " @param left left fit policy from `lv_fit_t`"]
    #[doc = " @param right right fit policy from `lv_fit_t`"]
    #[doc = " @param top top fit policy from `lv_fit_t`"]
    #[doc = " @param bottom bottom fit policy from `lv_fit_t`"]
    pub fn lv_cont_set_fit4(
        cont: *mut lv_obj_t,
        left: lv_fit_t,
        right: lv_fit_t,
        top: lv_fit_t,
        bottom: lv_fit_t,
    );
}
extern "C" {
    #[doc = " Get the layout of a container"]
    #[doc = " @param cont pointer to container object"]
    #[doc = " @return the layout from 'lv_cont_layout_t'"]
    pub fn lv_cont_get_layout(cont: *const lv_obj_t) -> lv_layout_t;
}
extern "C" {
    #[doc = " Get left fit mode of a container"]
    #[doc = " @param cont pointer to a container object"]
    #[doc = " @return an element of `lv_fit_t`"]
    pub fn lv_cont_get_fit_left(cont: *const lv_obj_t) -> lv_fit_t;
}
extern "C" {
    #[doc = " Get right fit mode of a container"]
    #[doc = " @param cont pointer to a container object"]
    #[doc = " @return an element of `lv_fit_t`"]
    pub fn lv_cont_get_fit_right(cont: *const lv_obj_t) -> lv_fit_t;
}
extern "C" {
    #[doc = " Get top fit mode of a container"]
    #[doc = " @param cont pointer to a container object"]
    #[doc = " @return an element of `lv_fit_t`"]
    pub fn lv_cont_get_fit_top(cont: *const lv_obj_t) -> lv_fit_t;
}
extern "C" {
    #[doc = " Get bottom fit mode of a container"]
    #[doc = " @param cont pointer to a container object"]
    #[doc = " @return an element of `lv_fit_t`"]
    pub fn lv_cont_get_fit_bottom(cont: *const lv_obj_t) -> lv_fit_t;
}
#[doc = "Released"]
pub const LV_BTN_STATE_REL: _bindgen_ty_24 = 0;
#[doc = "Pressed"]
pub const LV_BTN_STATE_PR: _bindgen_ty_24 = 1;
#[doc = "Toggled released"]
pub const LV_BTN_STATE_TGL_REL: _bindgen_ty_24 = 2;
#[doc = "Toggled pressed"]
pub const LV_BTN_STATE_TGL_PR: _bindgen_ty_24 = 3;
#[doc = "Inactive"]
pub const LV_BTN_STATE_INA: _bindgen_ty_24 = 4;
#[doc = "Number of states"]
pub const _LV_BTN_STATE_NUM: _bindgen_ty_24 = 5;
#[doc = " Possible states of a button."]
#[doc = " It can be used not only by buttons but other button-like objects too"]
pub type _bindgen_ty_24 = u32;
pub type lv_btn_state_t = u8;
#[doc = " Extended data of button"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_btn_ext_t {
    #[doc = " Ext. of ancestor"]
    pub cont: lv_cont_ext_t,
    #[doc = "Styles in each state"]
    pub styles: [*const lv_style_t; 5usize],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl lv_btn_ext_t {
    #[inline]
    pub fn state(&self) -> lv_btn_state_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_state(&mut self, val: lv_btn_state_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn toggle(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_toggle(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state: lv_btn_state_t,
        toggle: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let state: u8 = unsafe { ::core::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let toggle: u8 = unsafe { ::core::mem::transmute(toggle) };
            toggle as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Release style"]
pub const LV_BTN_STYLE_REL: _bindgen_ty_25 = 0;
#[doc = "Pressed style"]
pub const LV_BTN_STYLE_PR: _bindgen_ty_25 = 1;
#[doc = " Toggle released style"]
pub const LV_BTN_STYLE_TGL_REL: _bindgen_ty_25 = 2;
#[doc = " Toggle pressed style"]
pub const LV_BTN_STYLE_TGL_PR: _bindgen_ty_25 = 3;
#[doc = " Inactive style"]
pub const LV_BTN_STYLE_INA: _bindgen_ty_25 = 4;
#[doc = "Styles"]
pub type _bindgen_ty_25 = u32;
pub type lv_btn_style_t = u8;
extern "C" {
    #[doc = " Create a button object"]
    #[doc = " @param par pointer to an object, it will be the parent of the new button"]
    #[doc = " @param copy pointer to a button object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created button"]
    pub fn lv_btn_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Enable the toggled states. On release the button will change from/to toggled state."]
    #[doc = " @param btn pointer to a button object"]
    #[doc = " @param tgl true: enable toggled states, false: disable"]
    pub fn lv_btn_set_toggle(btn: *mut lv_obj_t, tgl: bool);
}
extern "C" {
    #[doc = " Set the state of the button"]
    #[doc = " @param btn pointer to a button object"]
    #[doc = " @param state the new state of the button (from lv_btn_state_t enum)"]
    pub fn lv_btn_set_state(btn: *mut lv_obj_t, state: lv_btn_state_t);
}
extern "C" {
    #[doc = " Toggle the state of the button (ON->OFF, OFF->ON)"]
    #[doc = " @param btn pointer to a button object"]
    pub fn lv_btn_toggle(btn: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Set time of the ink effect (draw a circle on click to animate in the new state)"]
    #[doc = " @param btn pointer to a button object"]
    #[doc = " @param time the time of the ink animation"]
    pub fn lv_btn_set_ink_in_time(btn: *mut lv_obj_t, time: u16);
}
extern "C" {
    #[doc = " Set the wait time before the ink disappears"]
    #[doc = " @param btn pointer to a button object"]
    #[doc = " @param time the time of the ink animation"]
    pub fn lv_btn_set_ink_wait_time(btn: *mut lv_obj_t, time: u16);
}
extern "C" {
    #[doc = " Set time of the ink out effect (animate to the released state)"]
    #[doc = " @param btn pointer to a button object"]
    #[doc = " @param time the time of the ink animation"]
    pub fn lv_btn_set_ink_out_time(btn: *mut lv_obj_t, time: u16);
}
extern "C" {
    #[doc = " Set a style of a button."]
    #[doc = " @param btn pointer to button object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_btn_set_style(btn: *mut lv_obj_t, type_: lv_btn_style_t, style: *const lv_style_t);
}
extern "C" {
    #[doc = " Get the current state of the button"]
    #[doc = " @param btn pointer to a button object"]
    #[doc = " @return the state of the button (from lv_btn_state_t enum)"]
    pub fn lv_btn_get_state(btn: *const lv_obj_t) -> lv_btn_state_t;
}
extern "C" {
    #[doc = " Get the toggle enable attribute of the button"]
    #[doc = " @param btn pointer to a button object"]
    #[doc = " @return true: toggle enabled, false: disabled"]
    pub fn lv_btn_get_toggle(btn: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get time of the ink in effect (draw a circle on click to animate in the new state)"]
    #[doc = " @param btn pointer to a button object"]
    #[doc = " @return the time of the ink animation"]
    pub fn lv_btn_get_ink_in_time(btn: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get the wait time before the ink disappears"]
    #[doc = " @param btn pointer to a button object"]
    #[doc = " @return the time of the ink animation"]
    pub fn lv_btn_get_ink_wait_time(btn: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get time of the ink out effect (animate to the releases state)"]
    #[doc = " @param btn pointer to a button object"]
    #[doc = " @return the time of the ink animation"]
    pub fn lv_btn_get_ink_out_time(btn: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get style of a button."]
    #[doc = " @param btn pointer to button object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to the style"]
    pub fn lv_btn_get_style(btn: *const lv_obj_t, type_: lv_btn_style_t) -> *const lv_style_t;
}
pub const LV_TXT_FLAG_NONE: _bindgen_ty_26 = 0;
#[doc = "< Enable parsing of recolor command"]
pub const LV_TXT_FLAG_RECOLOR: _bindgen_ty_26 = 1;
#[doc = "< Ignore width to avoid automatic word wrapping"]
pub const LV_TXT_FLAG_EXPAND: _bindgen_ty_26 = 2;
#[doc = "< Align the text to the middle"]
pub const LV_TXT_FLAG_CENTER: _bindgen_ty_26 = 4;
#[doc = "< Align the text to the right"]
pub const LV_TXT_FLAG_RIGHT: _bindgen_ty_26 = 8;
#[doc = "      TYPEDEFS"]
#[doc = " Options for text rendering."]
pub type _bindgen_ty_26 = u32;
pub type lv_txt_flag_t = u8;
#[doc = "< Waiting for command"]
pub const LV_TXT_CMD_STATE_WAIT: _bindgen_ty_27 = 0;
#[doc = "< Processing the parameter"]
pub const LV_TXT_CMD_STATE_PAR: _bindgen_ty_27 = 1;
#[doc = "< Processing the command"]
pub const LV_TXT_CMD_STATE_IN: _bindgen_ty_27 = 2;
#[doc = " State machine for text renderer."]
pub type _bindgen_ty_27 = u32;
pub type lv_txt_cmd_state_t = u8;
extern "C" {
    #[doc = " Get size of a text"]
    #[doc = " @param size_res pointer to a 'point_t' variable to store the result"]
    #[doc = " @param text pointer to a text"]
    #[doc = " @param font pinter to font of the text"]
    #[doc = " @param letter_space letter space of the text"]
    #[doc = " @param line_space line space of the text"]
    #[doc = " @param flags settings for the text from 'txt_flag_t' enum"]
    #[doc = " @param max_width max with of the text (break the lines to fit this size) Set CORD_MAX to avoid"]
    #[doc = " line breaks"]
    pub fn lv_txt_get_size(
        size_res: *mut lv_point_t,
        text: *const cty::c_char,
        font: *const lv_font_t,
        letter_space: lv_coord_t,
        line_space: lv_coord_t,
        max_width: lv_coord_t,
        flag: lv_txt_flag_t,
    );
}
extern "C" {
    #[doc = " Get the next line of text. Check line length and break chars too."]
    #[doc = " @param txt a '\\0' terminated string"]
    #[doc = " @param font pointer to a font"]
    #[doc = " @param letter_space letter space"]
    #[doc = " @param max_width max with of the text (break the lines to fit this size) Set CORD_MAX to avoid"]
    #[doc = " line breaks"]
    #[doc = " @param flags settings for the text from 'txt_flag_type' enum"]
    #[doc = " @return the index of the first char of the new line (in byte index not letter index. With UTF-8"]
    #[doc = " they are different)"]
    pub fn lv_txt_get_next_line(
        txt: *const cty::c_char,
        font: *const lv_font_t,
        letter_space: lv_coord_t,
        max_width: lv_coord_t,
        flag: lv_txt_flag_t,
    ) -> u16;
}
extern "C" {
    #[doc = " Give the length of a text with a given font"]
    #[doc = " @param txt a '\\0' terminate string"]
    #[doc = " @param length length of 'txt' in byte count and not characters ( is 1 character but 2 bytes in"]
    #[doc = " UTF-8)"]
    #[doc = " @param font pointer to a font"]
    #[doc = " @param letter_space letter space"]
    #[doc = " @param flags settings for the text from 'txt_flag_t' enum"]
    #[doc = " @return length of a char_num long text"]
    pub fn lv_txt_get_width(
        txt: *const cty::c_char,
        length: u16,
        font: *const lv_font_t,
        letter_space: lv_coord_t,
        flag: lv_txt_flag_t,
    ) -> lv_coord_t;
}
extern "C" {
    #[doc = " Check next character in a string and decide if te character is part of the command or not"]
    #[doc = " @param state pointer to a txt_cmd_state_t variable which stores the current state of command"]
    #[doc = " processing"]
    #[doc = " @param c the current character"]
    #[doc = " @return true: the character is part of a command and should not be written,"]
    #[doc = "         false: the character should be written"]
    pub fn lv_txt_is_cmd(state: *mut lv_txt_cmd_state_t, c: u32) -> bool;
}
extern "C" {
    #[doc = " Insert a string into an other"]
    #[doc = " @param txt_buf the original text (must be big enough for the result text)"]
    #[doc = " @param pos position to insert (0: before the original text, 1: after the first char etc.)"]
    #[doc = " @param ins_txt text to insert"]
    pub fn lv_txt_ins(txt_buf: *mut cty::c_char, pos: u32, ins_txt: *const cty::c_char);
}
extern "C" {
    #[doc = " Delete a part of a string"]
    #[doc = " @param txt string to modify"]
    #[doc = " @param pos position where to start the deleting (0: before the first char, 1: after the first"]
    #[doc = " char etc.)"]
    #[doc = " @param len number of characters to delete"]
    pub fn lv_txt_cut(txt: *mut cty::c_char, pos: u32, len: u32);
}
extern "C" {
    pub static mut lv_txt_encoded_size:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const cty::c_char) -> u8>;
}
extern "C" {
    pub static mut lv_txt_unicode_to_encoded:
        ::core::option::Option<unsafe extern "C" fn(arg1: u32) -> u32>;
}
extern "C" {
    pub static mut lv_txt_encoded_conv_wc:
        ::core::option::Option<unsafe extern "C" fn(c: u32) -> u32>;
}
extern "C" {
    pub static mut lv_txt_encoded_next: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const cty::c_char, arg2: *mut u32) -> u32,
    >;
}
extern "C" {
    pub static mut lv_txt_encoded_prev: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const cty::c_char, arg2: *mut u32) -> u32,
    >;
}
extern "C" {
    pub static mut lv_txt_encoded_get_byte_id:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const cty::c_char, arg2: u32) -> u32>;
}
extern "C" {
    pub static mut lv_txt_encoded_get_char_id:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const cty::c_char, arg2: u32) -> u32>;
}
extern "C" {
    pub static mut lv_txt_get_encoded_length:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const cty::c_char) -> u32>;
}
pub const LV_IMG_SRC_VARIABLE: _bindgen_ty_28 = 0;
#[doc = " Binary/C variable"]
pub const LV_IMG_SRC_FILE: _bindgen_ty_28 = 1;
#[doc = " File in filesystem"]
pub const LV_IMG_SRC_SYMBOL: _bindgen_ty_28 = 2;
#[doc = " Symbol (@ref lv_symbol_def.h)"]
pub const LV_IMG_SRC_UNKNOWN: _bindgen_ty_28 = 3;
#[doc = " Source of image."]
pub type _bindgen_ty_28 = u32;
pub type lv_img_src_t = u8;
#[doc = " LittlevGL image header"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct lv_img_header_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
impl lv_img_header_t {
    #[inline]
    pub fn cf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_cf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn always_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_always_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn w(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_w(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn h(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_h(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cf: u32,
        always_zero: u32,
        reserved: u32,
        w: u32,
        h: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let cf: u32 = unsafe { ::core::mem::transmute(cf) };
            cf as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let always_zero: u32 = unsafe { ::core::mem::transmute(always_zero) };
            always_zero as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(10usize, 11u8, {
            let w: u32 = unsafe { ::core::mem::transmute(w) };
            w as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let h: u32 = unsafe { ::core::mem::transmute(h) };
            h as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_IMG_CF_UNKNOWN: _bindgen_ty_29 = 0;
#[doc = "< Contains the file as it is. Needs custom decoder function"]
pub const LV_IMG_CF_RAW: _bindgen_ty_29 = 1;
#[doc = "< Contains the file as it is. The image has alpha. Needs custom decoder"]
#[doc = "function"]
pub const LV_IMG_CF_RAW_ALPHA: _bindgen_ty_29 = 2;
#[doc = "< Contains the file as it is. The image is chroma keyed. Needs"]
#[doc = "custom decoder function"]
pub const LV_IMG_CF_RAW_CHROMA_KEYED: _bindgen_ty_29 = 3;
#[doc = "< Color format and depth should match with LV_COLOR settings"]
pub const LV_IMG_CF_TRUE_COLOR: _bindgen_ty_29 = 4;
#[doc = "< Same as `LV_IMG_CF_TRUE_COLOR` but every pixel has an alpha byte"]
pub const LV_IMG_CF_TRUE_COLOR_ALPHA: _bindgen_ty_29 = 5;
#[doc = "< Same as `LV_IMG_CF_TRUE_COLOR` but LV_COLOR_TRANSP pixels"]
#[doc = "will be transparent"]
pub const LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED: _bindgen_ty_29 = 6;
#[doc = "< Can have 2 different colors in a palette (always chroma keyed)"]
pub const LV_IMG_CF_INDEXED_1BIT: _bindgen_ty_29 = 7;
#[doc = "< Can have 4 different colors in a palette (always chroma keyed)"]
pub const LV_IMG_CF_INDEXED_2BIT: _bindgen_ty_29 = 8;
#[doc = "< Can have 16 different colors in a palette (always chroma keyed)"]
pub const LV_IMG_CF_INDEXED_4BIT: _bindgen_ty_29 = 9;
#[doc = "< Can have 256 different colors in a palette (always chroma keyed)"]
pub const LV_IMG_CF_INDEXED_8BIT: _bindgen_ty_29 = 10;
#[doc = "< Can have one color and it can be drawn or not"]
pub const LV_IMG_CF_ALPHA_1BIT: _bindgen_ty_29 = 11;
#[doc = "< Can have one color but 4 different alpha value"]
pub const LV_IMG_CF_ALPHA_2BIT: _bindgen_ty_29 = 12;
#[doc = "< Can have one color but 16 different alpha value"]
pub const LV_IMG_CF_ALPHA_4BIT: _bindgen_ty_29 = 13;
#[doc = "< Can have one color but 256 different alpha value"]
pub const LV_IMG_CF_ALPHA_8BIT: _bindgen_ty_29 = 14;
#[doc = "< Reserved for further use."]
pub const LV_IMG_CF_RESERVED_15: _bindgen_ty_29 = 15;
#[doc = "< Reserved for further use."]
pub const LV_IMG_CF_RESERVED_16: _bindgen_ty_29 = 16;
#[doc = "< Reserved for further use."]
pub const LV_IMG_CF_RESERVED_17: _bindgen_ty_29 = 17;
#[doc = "< Reserved for further use."]
pub const LV_IMG_CF_RESERVED_18: _bindgen_ty_29 = 18;
#[doc = "< Reserved for further use."]
pub const LV_IMG_CF_RESERVED_19: _bindgen_ty_29 = 19;
#[doc = "< Reserved for further use."]
pub const LV_IMG_CF_RESERVED_20: _bindgen_ty_29 = 20;
#[doc = "< Reserved for further use."]
pub const LV_IMG_CF_RESERVED_21: _bindgen_ty_29 = 21;
#[doc = "< Reserved for further use."]
pub const LV_IMG_CF_RESERVED_22: _bindgen_ty_29 = 22;
#[doc = "< Reserved for further use."]
pub const LV_IMG_CF_RESERVED_23: _bindgen_ty_29 = 23;
#[doc = "< User holder encoding format."]
pub const LV_IMG_CF_USER_ENCODED_0: _bindgen_ty_29 = 24;
#[doc = "< User holder encoding format."]
pub const LV_IMG_CF_USER_ENCODED_1: _bindgen_ty_29 = 25;
#[doc = "< User holder encoding format."]
pub const LV_IMG_CF_USER_ENCODED_2: _bindgen_ty_29 = 26;
#[doc = "< User holder encoding format."]
pub const LV_IMG_CF_USER_ENCODED_3: _bindgen_ty_29 = 27;
#[doc = "< User holder encoding format."]
pub const LV_IMG_CF_USER_ENCODED_4: _bindgen_ty_29 = 28;
#[doc = "< User holder encoding format."]
pub const LV_IMG_CF_USER_ENCODED_5: _bindgen_ty_29 = 29;
#[doc = "< User holder encoding format."]
pub const LV_IMG_CF_USER_ENCODED_6: _bindgen_ty_29 = 30;
#[doc = "< User holder encoding format."]
pub const LV_IMG_CF_USER_ENCODED_7: _bindgen_ty_29 = 31;
pub type _bindgen_ty_29 = u32;
pub type lv_img_cf_t = u8;
#[doc = " Image header it is compatible with"]
#[doc = " the result from image converter utility"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_img_dsc_t {
    pub header: lv_img_header_t,
    pub data_size: u32,
    pub data: *const u8,
}
#[doc = " Get info from an image and store in the `header`"]
#[doc = " @param src the image source. Can be a pointer to a C array or a file name (Use"]
#[doc = " `lv_img_src_get_type` to determine the type)"]
#[doc = " @param header store the info here"]
#[doc = " @return LV_RES_OK: info written correctly; LV_RES_INV: failed"]
pub type lv_img_decoder_info_f_t = ::core::option::Option<
    unsafe extern "C" fn(
        decoder: *mut _lv_img_decoder,
        src: *const cty::c_void,
        header: *mut lv_img_header_t,
    ) -> lv_res_t,
>;
#[doc = " Open an image for decoding. Prepare it as it is required to read it later"]
#[doc = " @param decoder pointer to the decoder the function associated with"]
#[doc = " @param dsc pointer to decoder descriptor. `src`, `style` are already initialized in it."]
pub type lv_img_decoder_open_f_t = ::core::option::Option<
    unsafe extern "C" fn(decoder: *mut _lv_img_decoder, dsc: *mut _lv_img_decoder_dsc) -> lv_res_t,
>;
#[doc = " Decode `len` pixels starting from the given `x`, `y` coordinates and store them in `buf`."]
#[doc = " Required only if the \"open\" function can't return with the whole decoded pixel array."]
#[doc = " @param decoder pointer to the decoder the function associated with"]
#[doc = " @param dsc pointer to decoder descriptor"]
#[doc = " @param x start x coordinate"]
#[doc = " @param y start y coordinate"]
#[doc = " @param len number of pixels to decode"]
#[doc = " @param buf a buffer to store the decoded pixels"]
#[doc = " @return LV_RES_OK: ok; LV_RES_INV: failed"]
pub type lv_img_decoder_read_line_f_t = ::core::option::Option<
    unsafe extern "C" fn(
        decoder: *mut _lv_img_decoder,
        dsc: *mut _lv_img_decoder_dsc,
        x: lv_coord_t,
        y: lv_coord_t,
        len: lv_coord_t,
        buf: *mut u8,
    ) -> lv_res_t,
>;
#[doc = " Close the pending decoding. Free resources etc."]
#[doc = " @param decoder pointer to the decoder the function associated with"]
#[doc = " @param dsc pointer to decoder descriptor"]
pub type lv_img_decoder_close_f_t = ::core::option::Option<
    unsafe extern "C" fn(decoder: *mut _lv_img_decoder, dsc: *mut _lv_img_decoder_dsc),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_img_decoder {
    pub info_cb: lv_img_decoder_info_f_t,
    pub open_cb: lv_img_decoder_open_f_t,
    pub read_line_cb: lv_img_decoder_read_line_f_t,
    pub close_cb: lv_img_decoder_close_f_t,
    pub user_data: lv_img_decoder_user_data_t,
}
pub type lv_img_decoder_t = _lv_img_decoder;
#[doc = "Describe an image decoding session. Stores data about the decoding"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_img_decoder_dsc {
    #[doc = "The decoder which was able to open the image source"]
    pub decoder: *mut lv_img_decoder_t,
    #[doc = "The image source. A file path like \"S:my_img.png\" or pointer to an `lv_img_dsc_t` variable"]
    pub src: *const cty::c_void,
    #[doc = "Style to draw the image."]
    pub style: *const lv_style_t,
    #[doc = "Type of the source: file or variable. Can be set in `open` function if required"]
    pub src_type: lv_img_src_t,
    #[doc = "Info about the opened image: color format, size, etc. MUST be set in `open` function"]
    pub header: lv_img_header_t,
    #[doc = " Pointer to a buffer where the image's data (pixels) are stored in a decoded, plain format."]
    #[doc = "  MUST be set in `open` function"]
    pub img_data: *const u8,
    #[doc = " How much time did it take to open the image. [ms]"]
    #[doc = "  If not set `lv_img_cache` will measure and set the time to open"]
    pub time_to_open: u32,
    #[doc = "A text to display instead of the image when the image can't be opened."]
    #[doc = " Can be set in `open` function or set NULL."]
    pub error_msg: *const cty::c_char,
    #[doc = "Store any custom data here is required"]
    pub user_data: *mut cty::c_void,
}
pub type lv_img_decoder_dsc_t = _lv_img_decoder_dsc;
extern "C" {
    #[doc = " Initialize the image decoder module"]
    pub fn lv_img_decoder_init();
}
extern "C" {
    #[doc = " Get information about an image."]
    #[doc = " Try the created image decoder one by one. Once one is able to get info that info will be used."]
    #[doc = " @param src the image source. Can be"]
    #[doc = "  1) File name: E.g. \"S:folder/img1.png\" (The drivers needs to registered via `lv_fs_add_drv()`)"]
    #[doc = "  2) Variable: Pointer to an `lv_img_dsc_t` variable"]
    #[doc = "  3) Symbol: E.g. `LV_SYMBOL_OK`"]
    #[doc = " @param header the image info will be stored here"]
    #[doc = " @return LV_RES_OK: success; LV_RES_INV: wasn't able to get info about the image"]
    pub fn lv_img_decoder_get_info(
        src: *const cty::c_char,
        header: *mut lv_img_header_t,
    ) -> lv_res_t;
}
extern "C" {
    #[doc = " Open an image."]
    #[doc = " Try the created image decoder one by one. Once one is able to open the image that decoder is save in `dsc`"]
    #[doc = " @param dsc describe a decoding session. Simply a pointer to an `lv_img_decoder_dsc_t` variable."]
    #[doc = " @param src the image source. Can be"]
    #[doc = "  1) File name: E.g. \"S:folder/img1.png\" (The drivers needs to registered via `lv_fs_add_drv()`)"]
    #[doc = "  2) Variable: Pointer to an `lv_img_dsc_t` variable"]
    #[doc = "  3) Symbol: E.g. `LV_SYMBOL_OK`"]
    #[doc = " @param style the style of the image"]
    #[doc = " @return LV_RES_OK: opened the image. `dsc->img_data` and `dsc->header` are set."]
    #[doc = "         LV_RES_INV: none of the registered image decoders were able to open the image."]
    pub fn lv_img_decoder_open(
        dsc: *mut lv_img_decoder_dsc_t,
        src: *const cty::c_void,
        style: *const lv_style_t,
    ) -> lv_res_t;
}
extern "C" {
    #[doc = " Read a line from an opened image"]
    #[doc = " @param dsc pointer to `lv_img_decoder_dsc_t` used in `lv_img_decoder_open`"]
    #[doc = " @param x start X coordinate (from left)"]
    #[doc = " @param y start Y coordinate (from top)"]
    #[doc = " @param len number of pixels to read"]
    #[doc = " @param buf store the data here"]
    #[doc = " @return LV_RES_OK: success; LV_RES_INV: an error occurred"]
    pub fn lv_img_decoder_read_line(
        dsc: *mut lv_img_decoder_dsc_t,
        x: lv_coord_t,
        y: lv_coord_t,
        len: lv_coord_t,
        buf: *mut u8,
    ) -> lv_res_t;
}
extern "C" {
    #[doc = " Close a decoding session"]
    #[doc = " @param dsc pointer to `lv_img_decoder_dsc_t` used in `lv_img_decoder_open`"]
    pub fn lv_img_decoder_close(dsc: *mut lv_img_decoder_dsc_t);
}
extern "C" {
    #[doc = " Create a new image decoder"]
    #[doc = " @return pointer to the new image decoder"]
    pub fn lv_img_decoder_create() -> *mut lv_img_decoder_t;
}
extern "C" {
    #[doc = " Delete an image decoder"]
    #[doc = " @param decoder pointer to an image decoder"]
    pub fn lv_img_decoder_delete(decoder: *mut lv_img_decoder_t);
}
extern "C" {
    #[doc = " Set a callback to get information about the image"]
    #[doc = " @param decoder pointer to an image decoder"]
    #[doc = " @param info_cb a function to collect info about an image (fill an `lv_img_header_t` struct)"]
    pub fn lv_img_decoder_set_info_cb(
        decoder: *mut lv_img_decoder_t,
        info_cb: lv_img_decoder_info_f_t,
    );
}
extern "C" {
    #[doc = " Set a callback to open an image"]
    #[doc = " @param decoder pointer to an image decoder"]
    #[doc = " @param open_cb a function to open an image"]
    pub fn lv_img_decoder_set_open_cb(
        decoder: *mut lv_img_decoder_t,
        open_cb: lv_img_decoder_open_f_t,
    );
}
extern "C" {
    #[doc = " Set a callback to a decoded line of an image"]
    #[doc = " @param decoder pointer to an image decoder"]
    #[doc = " @param read_line_cb a function to read a line of an image"]
    pub fn lv_img_decoder_set_read_line_cb(
        decoder: *mut lv_img_decoder_t,
        read_line_cb: lv_img_decoder_read_line_f_t,
    );
}
extern "C" {
    #[doc = " Set a callback to close a decoding session. E.g. close files and free other resources."]
    #[doc = " @param decoder pointer to an image decoder"]
    #[doc = " @param close_cb a function to close a decoding session"]
    pub fn lv_img_decoder_set_close_cb(
        decoder: *mut lv_img_decoder_t,
        close_cb: lv_img_decoder_close_f_t,
    );
}
extern "C" {
    #[doc = " Get info about a built-in image"]
    #[doc = " @param decoder the decoder where this function belongs"]
    #[doc = " @param src the image source: pointer to an `lv_img_dsc_t` variable, a file path or a symbol"]
    #[doc = " @param header store the image data here"]
    #[doc = " @return LV_RES_OK: the info is successfully stored in `header`; LV_RES_INV: unknown format or other error."]
    pub fn lv_img_decoder_built_in_info(
        decoder: *mut lv_img_decoder_t,
        src: *const cty::c_void,
        header: *mut lv_img_header_t,
    ) -> lv_res_t;
}
extern "C" {
    #[doc = " Open a built in image"]
    #[doc = " @param decoder the decoder where this function belongs"]
    #[doc = " @param dsc pointer to decoder descriptor. `src`, `style` are already initialized in it."]
    #[doc = " @return LV_RES_OK: the info is successfully stored in `header`; LV_RES_INV: unknown format or other error."]
    pub fn lv_img_decoder_built_in_open(
        decoder: *mut lv_img_decoder_t,
        dsc: *mut lv_img_decoder_dsc_t,
    ) -> lv_res_t;
}
extern "C" {
    #[doc = " Decode `len` pixels starting from the given `x`, `y` coordinates and store them in `buf`."]
    #[doc = " Required only if the \"open\" function can't return with the whole decoded pixel array."]
    #[doc = " @param decoder pointer to the decoder the function associated with"]
    #[doc = " @param dsc pointer to decoder descriptor"]
    #[doc = " @param x start x coordinate"]
    #[doc = " @param y start y coordinate"]
    #[doc = " @param len number of pixels to decode"]
    #[doc = " @param buf a buffer to store the decoded pixels"]
    #[doc = " @return LV_RES_OK: ok; LV_RES_INV: failed"]
    pub fn lv_img_decoder_built_in_read_line(
        decoder: *mut lv_img_decoder_t,
        dsc: *mut lv_img_decoder_dsc_t,
        x: lv_coord_t,
        y: lv_coord_t,
        len: lv_coord_t,
        buf: *mut u8,
    ) -> lv_res_t;
}
extern "C" {
    #[doc = " Close the pending decoding. Free resources etc."]
    #[doc = " @param decoder pointer to the decoder the function associated with"]
    #[doc = " @param dsc pointer to decoder descriptor"]
    pub fn lv_img_decoder_built_in_close(
        decoder: *mut lv_img_decoder_t,
        dsc: *mut lv_img_decoder_dsc_t,
    );
}
extern "C" {
    #[doc = " Give a buffer with the given to use during drawing."]
    #[doc = " Be careful to not use the buffer while other processes are using it."]
    #[doc = " @param size the required size"]
    pub fn lv_draw_get_buf(size: u32) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Free the draw buffer"]
    pub fn lv_draw_free_buf();
}
extern "C" {
    #[doc = " Get the opacity of a pixel based it's position in a line segment"]
    #[doc = " @param seg segment length"]
    #[doc = " @param px_id position of  of a pixel which opacity should be get [0..seg-1]"]
    #[doc = " @param base_opa the base opacity"]
    #[doc = " @return the opacity of the given pixel"]
    pub fn lv_draw_aa_get_opa(seg: lv_coord_t, px_id: lv_coord_t, base_opa: lv_opa_t) -> lv_opa_t;
}
extern "C" {
    #[doc = " Add a vertical  anti-aliasing segment (pixels with decreasing opacity)"]
    #[doc = " @param x start point x coordinate"]
    #[doc = " @param y start point y coordinate"]
    #[doc = " @param length length of segment (negative value to start from 0 opacity)"]
    #[doc = " @param mask draw only in this area"]
    #[doc = " @param color color of pixels"]
    #[doc = " @param opa maximum opacity"]
    pub fn lv_draw_aa_ver_seg(
        x: lv_coord_t,
        y: lv_coord_t,
        length: lv_coord_t,
        mask: *const lv_area_t,
        color: lv_color_t,
        opa: lv_opa_t,
    );
}
extern "C" {
    #[doc = " Add a horizontal anti-aliasing segment (pixels with decreasing opacity)"]
    #[doc = " @param x start point x coordinate"]
    #[doc = " @param y start point y coordinate"]
    #[doc = " @param length length of segment (negative value to start from 0 opacity)"]
    #[doc = " @param mask draw only in this area"]
    #[doc = " @param color color of pixels"]
    #[doc = " @param opa maximum opacity"]
    pub fn lv_draw_aa_hor_seg(
        x: lv_coord_t,
        y: lv_coord_t,
        length: lv_coord_t,
        mask: *const lv_area_t,
        color: lv_color_t,
        opa: lv_opa_t,
    );
}
extern "C" {
    #[doc = " GLOBAL PROTOTYPES"]
    pub fn lv_draw_px(
        x: lv_coord_t,
        y: lv_coord_t,
        mask_p: *const lv_area_t,
        color: lv_color_t,
        opa: lv_opa_t,
    );
}
extern "C" {
    #[doc = " Fill an area in the Virtual Display Buffer"]
    #[doc = " @param cords_p coordinates of the area to fill"]
    #[doc = " @param mask_p fill only o this mask"]
    #[doc = " @param color fill color"]
    #[doc = " @param opa opacity of the area (0..255)"]
    pub fn lv_draw_fill(
        cords_p: *const lv_area_t,
        mask_p: *const lv_area_t,
        color: lv_color_t,
        opa: lv_opa_t,
    );
}
extern "C" {
    #[doc = " Draw a letter in the Virtual Display Buffer"]
    #[doc = " @param pos_p left-top coordinate of the latter"]
    #[doc = " @param mask_p the letter will be drawn only on this area"]
    #[doc = " @param font_p pointer to font"]
    #[doc = " @param letter a letter to draw"]
    #[doc = " @param color color of letter"]
    #[doc = " @param opa opacity of letter (0..255)"]
    pub fn lv_draw_letter(
        pos_p: *const lv_point_t,
        mask_p: *const lv_area_t,
        font_p: *const lv_font_t,
        letter: u32,
        color: lv_color_t,
        opa: lv_opa_t,
    );
}
extern "C" {
    #[doc = " Draw a color map to the display (image)"]
    #[doc = " @param cords_p coordinates the color map"]
    #[doc = " @param mask_p the map will drawn only on this area  (truncated to VDB area)"]
    #[doc = " @param map_p pointer to a lv_color_t array"]
    #[doc = " @param opa opacity of the map"]
    #[doc = " @param chroma_keyed true: enable transparency of LV_IMG_LV_COLOR_TRANSP color pixels"]
    #[doc = " @param alpha_byte true: extra alpha byte is inserted for every pixel"]
    #[doc = " @param recolor mix the pixels with this color"]
    #[doc = " @param recolor_opa the intense of recoloring"]
    pub fn lv_draw_map(
        cords_p: *const lv_area_t,
        mask_p: *const lv_area_t,
        map_p: *const u8,
        opa: lv_opa_t,
        chroma_key: bool,
        alpha_byte: bool,
        recolor: lv_color_t,
        recolor_opa: lv_opa_t,
    );
}
extern "C" {
    #[doc = " Draw a rectangle"]
    #[doc = " @param coords the coordinates of the rectangle"]
    #[doc = " @param mask the rectangle will be drawn only in this mask"]
    #[doc = " @param style pointer to a style"]
    #[doc = " @param opa_scale scale down all opacities by the factor"]
    pub fn lv_draw_rect(
        coords: *const lv_area_t,
        mask: *const lv_area_t,
        style: *const lv_style_t,
        opa_scale: lv_opa_t,
    );
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_draw_label_txt_sel_t {
    pub start: u16,
    pub end: u16,
}
#[doc = " Store some info to speed up drawing of very large texts"]
#[doc = " It takes a lot of time to get the first visible character because"]
#[doc = " all the previous characters needs to be checked to calculate the positions."]
#[doc = " This structure stores an earlier (e.g. at -1000 px) coordinate and the index of that line."]
#[doc = " Therefore the calculations can start from here."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_draw_label_hint_t {
    #[doc = " Index of the line at `y` coordinate"]
    pub line_start: i32,
    #[doc = " Give the `y` coordinate of the first letter at `line start` index. Relative to the label's coordinates"]
    pub y: i32,
    #[doc = " The 'y1' coordinate of the label when the hint was saved."]
    #[doc = " Used to invalidate the hint if the label has moved too much."]
    pub coord_y: i32,
}
extern "C" {
    #[doc = " Write a text"]
    #[doc = " @param coords coordinates of the label"]
    #[doc = " @param mask the label will be drawn only in this area"]
    #[doc = " @param style pointer to a style"]
    #[doc = " @param opa_scale scale down all opacities by the factor"]
    #[doc = " @param txt 0 terminated text to write"]
    #[doc = " @param flag settings for the text from 'txt_flag_t' enum"]
    #[doc = " @param offset text offset in x and y direction (NULL if unused)"]
    #[doc = " @param sel_start start index of selected area (`LV_LABEL_TXT_SEL_OFF` if none)"]
    #[doc = " @param bidi_dir base direction of the text"]
    pub fn lv_draw_label(
        coords: *const lv_area_t,
        mask: *const lv_area_t,
        style: *const lv_style_t,
        opa_scale: lv_opa_t,
        txt: *const cty::c_char,
        flag: lv_txt_flag_t,
        offset: *mut lv_point_t,
        sel: *mut lv_draw_label_txt_sel_t,
        hint: *mut lv_draw_label_hint_t,
        bidi_dir: lv_bidi_dir_t,
    );
}
extern "C" {
    #[doc = " Draw a line"]
    #[doc = " @param point1 first point of the line"]
    #[doc = " @param point2 second point of the line"]
    #[doc = " @param mask the line will be drawn only on this area"]
    #[doc = " @param style pointer to a line's style"]
    #[doc = " @param opa_scale scale down all opacities by the factor"]
    pub fn lv_draw_line(
        point1: *const lv_point_t,
        point2: *const lv_point_t,
        mask: *const lv_area_t,
        style: *const lv_style_t,
        opa_scale: lv_opa_t,
    );
}
extern "C" {
    #[doc = " @param points pointer to an array with 3 points"]
    #[doc = " @param mask the triangle will be drawn only in this mask"]
    #[doc = " @param style style for of the triangle"]
    #[doc = " @param opa_scale scale down all opacities by the factor (0..255)"]
    pub fn lv_draw_triangle(
        points: *const lv_point_t,
        mask: *const lv_area_t,
        style: *const lv_style_t,
        opa_scale: lv_opa_t,
    );
}
extern "C" {
    #[doc = " Draw a polygon from triangles. Only convex polygons are supported"]
    #[doc = " @param points an array of points"]
    #[doc = " @param point_cnt number of points"]
    #[doc = " @param mask polygon will be drawn only in this mask"]
    #[doc = " @param style style of the polygon"]
    #[doc = " @param opa_scale scale down all opacities by the factor (0..255)"]
    pub fn lv_draw_polygon(
        points: *const lv_point_t,
        point_cnt: u32,
        mask: *const lv_area_t,
        style: *const lv_style_t,
        opa_scale: lv_opa_t,
    );
}
extern "C" {
    #[doc = " Draw an arc. (Can draw pie too with great thickness.)"]
    #[doc = " @param center_x the x coordinate of the center of the arc"]
    #[doc = " @param center_y the y coordinate of the center of the arc"]
    #[doc = " @param radius the radius of the arc"]
    #[doc = " @param mask the arc will be drawn only in this mask"]
    #[doc = " @param start_angle the start angle of the arc (0 deg on the bottom, 90 deg on the right)"]
    #[doc = " @param end_angle the end angle of the arc"]
    #[doc = " @param style style of the arc (`body.thickness`, `body.main_color`, `body.opa` is used)"]
    #[doc = " @param opa_scale scale down all opacities by the factor"]
    pub fn lv_draw_arc(
        center_x: lv_coord_t,
        center_y: lv_coord_t,
        radius: u16,
        mask: *const lv_area_t,
        start_angle: u16,
        end_angle: u16,
        style: *const lv_style_t,
        opa_scale: lv_opa_t,
    );
}
extern "C" {
    #[doc = " Draw an image"]
    #[doc = " @param coords the coordinates of the image"]
    #[doc = " @param mask the image will be drawn only in this area"]
    #[doc = " @param src pointer to a lv_color_t array which contains the pixels of the image"]
    #[doc = " @param style style of the image"]
    #[doc = " @param opa_scale scale down all opacities by the factor"]
    pub fn lv_draw_img(
        coords: *const lv_area_t,
        mask: *const lv_area_t,
        src: *const cty::c_void,
        style: *const lv_style_t,
        opa_scale: lv_opa_t,
    );
}
extern "C" {
    #[doc = " Get the type of an image source"]
    #[doc = " @param src pointer to an image source:"]
    #[doc = "  - pointer to an 'lv_img_t' variable (image stored internally and compiled into the code)"]
    #[doc = "  - a path to a file (e.g. \"S:/folder/image.bin\")"]
    #[doc = "  - or a symbol (e.g. LV_SYMBOL_CLOSE)"]
    #[doc = " @return type of the image source LV_IMG_SRC_VARIABLE/FILE/SYMBOL/UNKNOWN"]
    pub fn lv_img_src_get_type(src: *const cty::c_void) -> lv_img_src_t;
}
extern "C" {
    #[doc = " Get the color of an image's pixel"]
    #[doc = " @param dsc an image descriptor"]
    #[doc = " @param x x coordinate of the point to get"]
    #[doc = " @param y x coordinate of the point to get"]
    #[doc = " @param style style of the image. In case of `LV_IMG_CF_ALPHA_1/2/4/8` `style->image.color` shows"]
    #[doc = " the color. Can be `NULL` but for `ALPHA` images black will be returned. In other cases it is not"]
    #[doc = " used."]
    #[doc = " @return color of the point"]
    pub fn lv_img_buf_get_px_color(
        dsc: *mut lv_img_dsc_t,
        x: lv_coord_t,
        y: lv_coord_t,
        style: *const lv_style_t,
    ) -> lv_color_t;
}
extern "C" {
    #[doc = " Get the alpha value of an image's pixel"]
    #[doc = " @param dsc pointer to an image descriptor"]
    #[doc = " @param x x coordinate of the point to set"]
    #[doc = " @param y x coordinate of the point to set"]
    #[doc = " @return alpha value of the point"]
    pub fn lv_img_buf_get_px_alpha(
        dsc: *mut lv_img_dsc_t,
        x: lv_coord_t,
        y: lv_coord_t,
    ) -> lv_opa_t;
}
extern "C" {
    #[doc = " Set the color of a pixel of an image. The alpha channel won't be affected."]
    #[doc = " @param dsc pointer to an image descriptor"]
    #[doc = " @param x x coordinate of the point to set"]
    #[doc = " @param y x coordinate of the point to set"]
    #[doc = " @param c color of the point"]
    pub fn lv_img_buf_set_px_color(
        dsc: *mut lv_img_dsc_t,
        x: lv_coord_t,
        y: lv_coord_t,
        c: lv_color_t,
    );
}
extern "C" {
    #[doc = " Set the alpha value of a pixel of an image. The color won't be affected"]
    #[doc = " @param dsc pointer to an image descriptor"]
    #[doc = " @param x x coordinate of the point to set"]
    #[doc = " @param y x coordinate of the point to set"]
    #[doc = " @param opa the desired opacity"]
    pub fn lv_img_buf_set_px_alpha(
        dsc: *mut lv_img_dsc_t,
        x: lv_coord_t,
        y: lv_coord_t,
        opa: lv_opa_t,
    );
}
extern "C" {
    #[doc = " Set the palette color of an indexed image. Valid only for `LV_IMG_CF_INDEXED1/2/4/8`"]
    #[doc = " @param dsc pointer to an image descriptor"]
    #[doc = " @param id the palette color to set:"]
    #[doc = "   - for `LV_IMG_CF_INDEXED1`: 0..1"]
    #[doc = "   - for `LV_IMG_CF_INDEXED2`: 0..3"]
    #[doc = "   - for `LV_IMG_CF_INDEXED4`: 0..15"]
    #[doc = "   - for `LV_IMG_CF_INDEXED8`: 0..255"]
    #[doc = " @param c the color to set"]
    pub fn lv_img_buf_set_palette(dsc: *mut lv_img_dsc_t, id: u8, c: lv_color_t);
}
extern "C" {
    #[doc = " Get the pixel size of a color format in bits"]
    #[doc = " @param cf a color format (`LV_IMG_CF_...`)"]
    #[doc = " @return the pixel size in bits"]
    pub fn lv_img_color_format_get_px_size(cf: lv_img_cf_t) -> u8;
}
extern "C" {
    #[doc = " Check if a color format is chroma keyed or not"]
    #[doc = " @param cf a color format (`LV_IMG_CF_...`)"]
    #[doc = " @return true: chroma keyed; false: not chroma keyed"]
    pub fn lv_img_color_format_is_chroma_keyed(cf: lv_img_cf_t) -> bool;
}
extern "C" {
    #[doc = " Check if a color format has alpha channel or not"]
    #[doc = " @param cf a color format (`LV_IMG_CF_...`)"]
    #[doc = " @return true: has alpha channel; false: doesn't have alpha channel"]
    pub fn lv_img_color_format_has_alpha(cf: lv_img_cf_t) -> bool;
}
extern "C" {
    #[doc = " Allocate an image buffer in RAM"]
    #[doc = " @param w width of image"]
    #[doc = " @param h height of image"]
    #[doc = " @param cf a color format (`LV_IMG_CF_...`)"]
    #[doc = " @return an allocated image, or NULL on failure"]
    pub fn lv_img_buf_alloc(w: lv_coord_t, h: lv_coord_t, cf: lv_img_cf_t) -> *mut lv_img_dsc_t;
}
extern "C" {
    #[doc = " Free an allocated image buffer"]
    #[doc = " @param dsc image buffer to free"]
    pub fn lv_img_buf_free(dsc: *mut lv_img_dsc_t);
}
extern "C" {
    #[doc = " Get the memory consumption of a raw bitmap, given color format and dimensions."]
    #[doc = " @param w width"]
    #[doc = " @param h height"]
    #[doc = " @param cf color format"]
    #[doc = " @return size in bytes"]
    pub fn lv_img_buf_get_img_size(w: lv_coord_t, h: lv_coord_t, cf: lv_img_cf_t) -> u32;
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_imgbtn_ext_t {
    pub btn: lv_btn_ext_t,
    pub img_src: [*const cty::c_void; 5usize],
    pub act_cf: lv_img_cf_t,
}
#[doc = "< Same meaning as ordinary button styles."]
pub const LV_IMGBTN_STYLE_REL: _bindgen_ty_30 = 0;
pub const LV_IMGBTN_STYLE_PR: _bindgen_ty_30 = 1;
pub const LV_IMGBTN_STYLE_TGL_REL: _bindgen_ty_30 = 2;
pub const LV_IMGBTN_STYLE_TGL_PR: _bindgen_ty_30 = 3;
pub const LV_IMGBTN_STYLE_INA: _bindgen_ty_30 = 4;
pub type _bindgen_ty_30 = u32;
pub type lv_imgbtn_style_t = u8;
extern "C" {
    #[doc = " Create a image button objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new image button"]
    #[doc = " @param copy pointer to a image button object, if not NULL then the new object will be copied from"]
    #[doc = " it"]
    #[doc = " @return pointer to the created image button"]
    pub fn lv_imgbtn_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set images for a state of the image button"]
    #[doc = " @param imgbtn pointer to an image button object"]
    #[doc = " @param state for which state set the new image (from `lv_btn_state_t`) `"]
    #[doc = " @param src pointer to an image source (a C array or path to a file)"]
    pub fn lv_imgbtn_set_src(imgbtn: *mut lv_obj_t, state: lv_btn_state_t, src: *const cty::c_void);
}
extern "C" {
    #[doc = " Set a style of a image button."]
    #[doc = " @param imgbtn pointer to image button object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_imgbtn_set_style(
        imgbtn: *mut lv_obj_t,
        type_: lv_imgbtn_style_t,
        style: *const lv_style_t,
    );
}
extern "C" {
    #[doc = " Get the images in a  given state"]
    #[doc = " @param imgbtn pointer to an image button object"]
    #[doc = " @param state the state where to get the image (from `lv_btn_state_t`) `"]
    #[doc = " @return pointer to an image source (a C array or path to a file)"]
    pub fn lv_imgbtn_get_src(imgbtn: *mut lv_obj_t, state: lv_btn_state_t) -> *const cty::c_void;
}
extern "C" {
    #[doc = " Get style of a image button."]
    #[doc = " @param imgbtn pointer to image button object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to the style"]
    pub fn lv_imgbtn_get_style(
        imgbtn: *const lv_obj_t,
        type_: lv_imgbtn_style_t,
    ) -> *const lv_style_t;
}
#[doc = "< Expand the object size to the text size"]
pub const LV_LABEL_LONG_EXPAND: _bindgen_ty_31 = 0;
#[doc = "< Keep the object width, break the too long lines and expand the object"]
#[doc = "height"]
pub const LV_LABEL_LONG_BREAK: _bindgen_ty_31 = 1;
#[doc = "< Keep the size and write dots at the end if the text is too long"]
pub const LV_LABEL_LONG_DOT: _bindgen_ty_31 = 2;
#[doc = "< Keep the size and roll the text back and forth"]
pub const LV_LABEL_LONG_SROLL: _bindgen_ty_31 = 3;
#[doc = "< Keep the size and roll the text circularly"]
pub const LV_LABEL_LONG_SROLL_CIRC: _bindgen_ty_31 = 4;
#[doc = "< Keep the size and crop the text out of it"]
pub const LV_LABEL_LONG_CROP: _bindgen_ty_31 = 5;
#[doc = " Long mode behaviors. Used in 'lv_label_ext_t'"]
pub type _bindgen_ty_31 = u32;
pub type lv_label_long_mode_t = u8;
#[doc = "< Align text to left"]
pub const LV_LABEL_ALIGN_LEFT: _bindgen_ty_32 = 0;
#[doc = "< Align text to center"]
pub const LV_LABEL_ALIGN_CENTER: _bindgen_ty_32 = 1;
#[doc = "< Align text to right"]
pub const LV_LABEL_ALIGN_RIGHT: _bindgen_ty_32 = 2;
#[doc = "< Use LEFT or RIGHT depending on the direction of the text (LTR/RTL)"]
pub const LV_LABEL_ALIGN_AUTO: _bindgen_ty_32 = 3;
#[doc = " Label align policy"]
pub type _bindgen_ty_32 = u32;
pub type lv_label_align_t = u8;
#[doc = " Data of label"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_label_ext_t {
    pub text: *mut cty::c_char,
    pub dot: lv_label_ext_t__bindgen_ty_1,
    pub dot_end: u16,
    pub offset: lv_point_t,
    pub anim_speed: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_padding_0: [u16; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lv_label_ext_t__bindgen_ty_1 {
    pub tmp_ptr: *mut cty::c_char,
    pub tmp: [cty::c_char; 4usize],
    _bindgen_union_align: u64,
}
impl lv_label_ext_t {
    #[inline]
    pub fn long_mode(&self) -> lv_label_long_mode_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_long_mode(&mut self, val: lv_label_long_mode_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn static_txt(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_static_txt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn align(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_align(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn recolor(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_recolor(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn expand(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_expand(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn body_draw(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_body_draw(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dot_tmp_alloc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dot_tmp_alloc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        long_mode: lv_label_long_mode_t,
        static_txt: u8,
        align: u8,
        recolor: u8,
        expand: u8,
        body_draw: u8,
        dot_tmp_alloc: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let long_mode: u8 = unsafe { ::core::mem::transmute(long_mode) };
            long_mode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let static_txt: u8 = unsafe { ::core::mem::transmute(static_txt) };
            static_txt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let align: u8 = unsafe { ::core::mem::transmute(align) };
            align as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let recolor: u8 = unsafe { ::core::mem::transmute(recolor) };
            recolor as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let expand: u8 = unsafe { ::core::mem::transmute(expand) };
            expand as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let body_draw: u8 = unsafe { ::core::mem::transmute(body_draw) };
            body_draw as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let dot_tmp_alloc: u8 = unsafe { ::core::mem::transmute(dot_tmp_alloc) };
            dot_tmp_alloc as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_LABEL_STYLE_MAIN: _bindgen_ty_33 = 0;
#[doc = " Label styles"]
pub type _bindgen_ty_33 = u32;
pub type lv_label_style_t = u8;
extern "C" {
    #[doc = " Create a label objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new label"]
    #[doc = " @param copy pointer to a button object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created button"]
    pub fn lv_label_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set a new text for a label. Memory will be allocated to store the text by the label."]
    #[doc = " @param label pointer to a label object"]
    #[doc = " @param text '\\0' terminated character string. NULL to refresh with the current text."]
    pub fn lv_label_set_text(label: *mut lv_obj_t, text: *const cty::c_char);
}
extern "C" {
    #[doc = " Set a new formatted text for a label. Memory will be allocated to store the text by the label."]
    #[doc = " @param label pointer to a label object"]
    #[doc = " @param fmt `printf`-like format"]
    pub fn lv_label_set_text_fmt(label: *mut lv_obj_t, fmt: *const cty::c_char, ...);
}
extern "C" {
    #[doc = " Set a new text for a label from a character array. The array don't has to be '\\0' terminated."]
    #[doc = " Memory will be allocated to store the array by the label."]
    #[doc = " @param label pointer to a label object"]
    #[doc = " @param array array of characters or NULL to refresh the label"]
    #[doc = " @param size the size of 'array' in bytes"]
    pub fn lv_label_set_array_text(label: *mut lv_obj_t, array: *const cty::c_char, size: u16);
}
extern "C" {
    #[doc = " Set a static text. It will not be saved by the label so the 'text' variable"]
    #[doc = " has to be 'alive' while the label exist."]
    #[doc = " @param label pointer to a label object"]
    #[doc = " @param text pointer to a text. NULL to refresh with the current text."]
    pub fn lv_label_set_static_text(label: *mut lv_obj_t, text: *const cty::c_char);
}
extern "C" {
    #[doc = " Set the behavior of the label with longer text then the object size"]
    #[doc = " @param label pointer to a label object"]
    #[doc = " @param long_mode the new mode from 'lv_label_long_mode' enum."]
    #[doc = "                  In LV_LONG_BREAK/LONG/ROLL the size of the label should be set AFTER this"]
    #[doc = " function"]
    pub fn lv_label_set_long_mode(label: *mut lv_obj_t, long_mode: lv_label_long_mode_t);
}
extern "C" {
    #[doc = " Set the align of the label (left or center)"]
    #[doc = " @param label pointer to a label object"]
    #[doc = " @param align 'LV_LABEL_ALIGN_LEFT' or 'LV_LABEL_ALIGN_LEFT'"]
    pub fn lv_label_set_align(label: *mut lv_obj_t, align: lv_label_align_t);
}
extern "C" {
    #[doc = " Enable the recoloring by in-line commands"]
    #[doc = " @param label pointer to a label object"]
    #[doc = " @param en true: enable recoloring, false: disable"]
    pub fn lv_label_set_recolor(label: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Set the label to draw (or not draw) background specified in its style's body"]
    #[doc = " @param label pointer to a label object"]
    #[doc = " @param en true: draw body; false: don't draw body"]
    pub fn lv_label_set_body_draw(label: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Set the label's animation speed in LV_LABEL_LONG_SROLL/SCROLL_CIRC modes"]
    #[doc = " @param label pointer to a label object"]
    #[doc = " @param anim_speed speed of animation in px/sec unit"]
    pub fn lv_label_set_anim_speed(label: *mut lv_obj_t, anim_speed: u16);
}
extern "C" {
    #[doc = " @brief Set the selection start index."]
    #[doc = " @param label pointer to a label object."]
    #[doc = " @param index index to set. `LV_LABEL_TXT_SEL_OFF` to select nothing."]
    pub fn lv_label_set_text_sel_start(label: *mut lv_obj_t, index: u16);
}
extern "C" {
    #[doc = " @brief Set the selection end index."]
    #[doc = " @param label pointer to a label object."]
    #[doc = " @param index index to set. `LV_LABEL_TXT_SEL_OFF` to select nothing."]
    pub fn lv_label_set_text_sel_end(label: *mut lv_obj_t, index: u16);
}
extern "C" {
    #[doc = " Get the text of a label"]
    #[doc = " @param label pointer to a label object"]
    #[doc = " @return the text of the label"]
    pub fn lv_label_get_text(label: *const lv_obj_t) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Get the long mode of a label"]
    #[doc = " @param label pointer to a label object"]
    #[doc = " @return the long mode"]
    pub fn lv_label_get_long_mode(label: *const lv_obj_t) -> lv_label_long_mode_t;
}
extern "C" {
    #[doc = " Get the align attribute"]
    #[doc = " @param label pointer to a label object"]
    #[doc = " @return LV_LABEL_ALIGN_LEFT or LV_LABEL_ALIGN_CENTER"]
    pub fn lv_label_get_align(label: *const lv_obj_t) -> lv_label_align_t;
}
extern "C" {
    #[doc = " Get the recoloring attribute"]
    #[doc = " @param label pointer to a label object"]
    #[doc = " @return true: recoloring is enabled, false: disable"]
    pub fn lv_label_get_recolor(label: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get the body draw attribute"]
    #[doc = " @param label pointer to a label object"]
    #[doc = " @return true: draw body; false: don't draw body"]
    pub fn lv_label_get_body_draw(label: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get the label's animation speed in LV_LABEL_LONG_ROLL and SCROLL modes"]
    #[doc = " @param label pointer to a label object"]
    #[doc = " @return speed of animation in px/sec unit"]
    pub fn lv_label_get_anim_speed(label: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get the relative x and y coordinates of a letter"]
    #[doc = " @param label pointer to a label object"]
    #[doc = " @param index index of the letter [0 ... text length]. Expressed in character index, not byte"]
    #[doc = " index (different in UTF-8)"]
    #[doc = " @param pos store the result here (E.g. index = 0 gives 0;0 coordinates)"]
    pub fn lv_label_get_letter_pos(label: *const lv_obj_t, index: u16, pos: *mut lv_point_t);
}
extern "C" {
    #[doc = " Get the index of letter on a relative point of a label"]
    #[doc = " @param label pointer to label object"]
    #[doc = " @param pos pointer to point with coordinates on a the label"]
    #[doc = " @return the index of the letter on the 'pos_p' point (E.g. on 0;0 is the 0. letter)"]
    #[doc = " Expressed in character index and not byte index (different in UTF-8)"]
    pub fn lv_label_get_letter_on(label: *const lv_obj_t, pos: *mut lv_point_t) -> u16;
}
extern "C" {
    #[doc = " Check if a character is drawn under a point."]
    #[doc = " @param label Label object"]
    #[doc = " @param pos Point to check for characte under"]
    #[doc = " @return whether a character is drawn under the point"]
    pub fn lv_label_is_char_under_pos(label: *const lv_obj_t, pos: *mut lv_point_t) -> bool;
}
extern "C" {
    #[doc = " @brief Get the selection start index."]
    #[doc = " @param label pointer to a label object."]
    #[doc = " @return selection start index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected."]
    pub fn lv_label_get_text_sel_start(label: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " @brief Get the selection end index."]
    #[doc = " @param label pointer to a label object."]
    #[doc = " @return selection end index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected."]
    pub fn lv_label_get_text_sel_end(label: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Insert a text to the label. The label text can not be static."]
    #[doc = " @param label pointer to a label object"]
    #[doc = " @param pos character index to insert. Expressed in character index and not byte index (Different"]
    #[doc = " in UTF-8) 0: before first char. LV_LABEL_POS_LAST: after last char."]
    #[doc = " @param txt pointer to the text to insert"]
    pub fn lv_label_ins_text(label: *mut lv_obj_t, pos: u32, txt: *const cty::c_char);
}
extern "C" {
    #[doc = " Delete characters from a label. The label text can not be static."]
    #[doc = " @param label pointer to a label object"]
    #[doc = " @param pos character index to insert. Expressed in character index and not byte index (Different"]
    #[doc = " in UTF-8) 0: before first char."]
    #[doc = " @param cnt number of characters to cut"]
    pub fn lv_label_cut_text(label: *mut lv_obj_t, pos: u32, cnt: u32);
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_img_ext_t {
    pub src: *const cty::c_void,
    pub offset: lv_point_t,
    pub w: lv_coord_t,
    pub h: lv_coord_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl lv_img_ext_t {
    #[inline]
    pub fn src_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_src_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auto_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cf(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_cf(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        src_type: u8,
        auto_size: u8,
        cf: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let src_type: u8 = unsafe { ::core::mem::transmute(src_type) };
            src_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let auto_size: u8 = unsafe { ::core::mem::transmute(auto_size) };
            auto_size as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let cf: u8 = unsafe { ::core::mem::transmute(cf) };
            cf as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_IMG_STYLE_MAIN: _bindgen_ty_34 = 0;
pub type _bindgen_ty_34 = u32;
pub type lv_img_style_t = u8;
extern "C" {
    #[doc = " Create an image objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new button"]
    #[doc = " @param copy pointer to a image object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created image"]
    pub fn lv_img_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set the pixel map to display by the image"]
    #[doc = " @param img pointer to an image object"]
    #[doc = " @param data the image data"]
    pub fn lv_img_set_src(img: *mut lv_obj_t, src_img: *const cty::c_void);
}
extern "C" {
    #[doc = " Enable the auto size feature."]
    #[doc = " If enabled the object size will be same as the picture size."]
    #[doc = " @param img pointer to an image"]
    #[doc = " @param en true: auto size enable, false: auto size disable"]
    pub fn lv_img_set_auto_size(img: *mut lv_obj_t, autosize_en: bool);
}
extern "C" {
    #[doc = " Set an offset for the source of an image."]
    #[doc = " so the image will be displayed from the new origin."]
    #[doc = " @param img pointer to an image"]
    #[doc = " @param x: the new offset along x axis."]
    pub fn lv_img_set_offset_x(img: *mut lv_obj_t, x: lv_coord_t);
}
extern "C" {
    #[doc = " Set an offset for the source of an image."]
    #[doc = " so the image will be displayed from the new origin."]
    #[doc = " @param img pointer to an image"]
    #[doc = " @param y: the new offset along y axis."]
    pub fn lv_img_set_offset_y(img: *mut lv_obj_t, y: lv_coord_t);
}
extern "C" {
    #[doc = " Get the source of the image"]
    #[doc = " @param img pointer to an image object"]
    #[doc = " @return the image source (symbol, file name or C array)"]
    pub fn lv_img_get_src(img: *mut lv_obj_t) -> *const cty::c_void;
}
extern "C" {
    #[doc = " Get the name of the file set for an image"]
    #[doc = " @param img pointer to an image"]
    #[doc = " @return file name"]
    pub fn lv_img_get_file_name(img: *const lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Get the auto size enable attribute"]
    #[doc = " @param img pointer to an image"]
    #[doc = " @return true: auto size is enabled, false: auto size is disabled"]
    pub fn lv_img_get_auto_size(img: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get the offset.x attribute of the img object."]
    #[doc = " @param img pointer to an image"]
    #[doc = " @return offset.x value."]
    pub fn lv_img_get_offset_x(img: *mut lv_obj_t) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get the offset.y attribute of the img object."]
    #[doc = " @param img pointer to an image"]
    #[doc = " @return offset.y value."]
    pub fn lv_img_get_offset_y(img: *mut lv_obj_t) -> lv_coord_t;
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_line_ext_t {
    pub point_array: *const lv_point_t,
    pub point_num: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 5usize],
}
impl lv_line_ext_t {
    #[inline]
    pub fn auto_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auto_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn y_inv(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_y_inv(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(auto_size: u8, y_inv: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let auto_size: u8 = unsafe { ::core::mem::transmute(auto_size) };
            auto_size as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let y_inv: u8 = unsafe { ::core::mem::transmute(y_inv) };
            y_inv as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_LINE_STYLE_MAIN: _bindgen_ty_35 = 0;
pub type _bindgen_ty_35 = u32;
pub type lv_line_style_t = u8;
extern "C" {
    #[doc = " Create a line objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new line"]
    #[doc = " @return pointer to the created line"]
    pub fn lv_line_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set an array of points. The line object will connect these points."]
    #[doc = " @param line pointer to a line object"]
    #[doc = " @param point_a an array of points. Only the address is saved,"]
    #[doc = " so the array can NOT be a local variable which will be destroyed"]
    #[doc = " @param point_num number of points in 'point_a'"]
    pub fn lv_line_set_points(line: *mut lv_obj_t, point_a: *const lv_point_t, point_num: u16);
}
extern "C" {
    #[doc = " Enable (or disable) the auto-size option. The size of the object will fit to its points."]
    #[doc = " (set width to x max and height to y max)"]
    #[doc = " @param line pointer to a line object"]
    #[doc = " @param en true: auto size is enabled, false: auto size is disabled"]
    pub fn lv_line_set_auto_size(line: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Enable (or disable) the y coordinate inversion."]
    #[doc = " If enabled then y will be subtracted from the height of the object,"]
    #[doc = " therefore the y=0 coordinate will be on the bottom."]
    #[doc = " @param line pointer to a line object"]
    #[doc = " @param en true: enable the y inversion, false:disable the y inversion"]
    pub fn lv_line_set_y_invert(line: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Get the auto size attribute"]
    #[doc = " @param line pointer to a line object"]
    #[doc = " @return true: auto size is enabled, false: disabled"]
    pub fn lv_line_get_auto_size(line: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get the y inversion attribute"]
    #[doc = " @param line pointer to a line object"]
    #[doc = " @return true: y inversion is enabled, false: disabled"]
    pub fn lv_line_get_y_invert(line: *const lv_obj_t) -> bool;
}
#[doc = "< Never show scrollbars"]
pub const LV_SB_MODE_OFF: _bindgen_ty_36 = 0;
#[doc = "< Always show scrollbars"]
pub const LV_SB_MODE_ON: _bindgen_ty_36 = 1;
#[doc = "< Show scrollbars when page is being dragged"]
pub const LV_SB_MODE_DRAG: _bindgen_ty_36 = 2;
#[doc = "< Show scrollbars when the scrollable container is large enough to be scrolled"]
pub const LV_SB_MODE_AUTO: _bindgen_ty_36 = 3;
#[doc = "< Hide the scroll bar temporally"]
pub const LV_SB_MODE_HIDE: _bindgen_ty_36 = 4;
#[doc = "< Unhide the previously hidden scrollbar. Recover it's type too"]
pub const LV_SB_MODE_UNHIDE: _bindgen_ty_36 = 5;
#[doc = " Scrollbar modes: shows when should the scrollbars be visible"]
pub type _bindgen_ty_36 = u32;
pub type lv_sb_mode_t = u8;
pub const LV_PAGE_EDGE_LEFT: _bindgen_ty_37 = 1;
pub const LV_PAGE_EDGE_TOP: _bindgen_ty_37 = 2;
pub const LV_PAGE_EDGE_RIGHT: _bindgen_ty_37 = 4;
pub const LV_PAGE_EDGE_BOTTOM: _bindgen_ty_37 = 8;
#[doc = " Edges: describes the four edges of the page"]
pub type _bindgen_ty_37 = u32;
pub type lv_page_edge_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_page_ext_t {
    pub bg: lv_cont_ext_t,
    pub scrl: *mut lv_obj_t,
    pub sb: lv_page_ext_t__bindgen_ty_1,
    pub edge_flash: lv_page_ext_t__bindgen_ty_2,
    pub anim_time: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_page_ext_t__bindgen_ty_1 {
    pub style: *const lv_style_t,
    pub hor_area: lv_area_t,
    pub ver_area: lv_area_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl lv_page_ext_t__bindgen_ty_1 {
    #[inline]
    pub fn hor_draw(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hor_draw(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ver_draw(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ver_draw(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mode(&self) -> lv_sb_mode_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_mode(&mut self, val: lv_sb_mode_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hor_draw: u8,
        ver_draw: u8,
        mode: lv_sb_mode_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hor_draw: u8 = unsafe { ::core::mem::transmute(hor_draw) };
            hor_draw as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ver_draw: u8 = unsafe { ::core::mem::transmute(ver_draw) };
            ver_draw as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let mode: u8 = unsafe { ::core::mem::transmute(mode) };
            mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_page_ext_t__bindgen_ty_2 {
    pub state: lv_anim_value_t,
    pub style: *const lv_style_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl lv_page_ext_t__bindgen_ty_2 {
    #[inline]
    pub fn enabled(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn top_ip(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_top_ip(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bottom_ip(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bottom_ip(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn right_ip(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_right_ip(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn left_ip(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_left_ip(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled: u8,
        top_ip: u8,
        bottom_ip: u8,
        right_ip: u8,
        left_ip: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u8 = unsafe { ::core::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let top_ip: u8 = unsafe { ::core::mem::transmute(top_ip) };
            top_ip as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bottom_ip: u8 = unsafe { ::core::mem::transmute(bottom_ip) };
            bottom_ip as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let right_ip: u8 = unsafe { ::core::mem::transmute(right_ip) };
            right_ip as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let left_ip: u8 = unsafe { ::core::mem::transmute(left_ip) };
            left_ip as u64
        });
        __bindgen_bitfield_unit
    }
}
impl lv_page_ext_t {
    #[inline]
    pub fn scroll_prop(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scroll_prop(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scroll_prop_ip(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scroll_prop_ip(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        scroll_prop: u8,
        scroll_prop_ip: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let scroll_prop: u8 = unsafe { ::core::mem::transmute(scroll_prop) };
            scroll_prop as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let scroll_prop_ip: u8 = unsafe { ::core::mem::transmute(scroll_prop_ip) };
            scroll_prop_ip as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_PAGE_STYLE_BG: _bindgen_ty_38 = 0;
pub const LV_PAGE_STYLE_SCRL: _bindgen_ty_38 = 1;
pub const LV_PAGE_STYLE_SB: _bindgen_ty_38 = 2;
pub const LV_PAGE_STYLE_EDGE_FLASH: _bindgen_ty_38 = 3;
pub type _bindgen_ty_38 = u32;
pub type lv_page_style_t = u8;
extern "C" {
    #[doc = " Create a page objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new page"]
    #[doc = " @param copy pointer to a page object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created page"]
    pub fn lv_page_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Delete all children of the scrl object, without deleting scrl child."]
    #[doc = " @param page pointer to an object"]
    pub fn lv_page_clean(page: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Get the scrollable object of a page"]
    #[doc = " @param page pointer to a page object"]
    #[doc = " @return pointer to a container which is the scrollable part of the page"]
    pub fn lv_page_get_scrl(page: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Get the animation time"]
    #[doc = " @param page pointer to a page object"]
    #[doc = " @return the animation time in milliseconds"]
    pub fn lv_page_get_anim_time(page: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Set the scroll bar mode on a page"]
    #[doc = " @param page pointer to a page object"]
    #[doc = " @param sb_mode the new mode from 'lv_page_sb.mode_t' enum"]
    pub fn lv_page_set_sb_mode(page: *mut lv_obj_t, sb_mode: lv_sb_mode_t);
}
extern "C" {
    #[doc = " Set the animation time for the page"]
    #[doc = " @param page pointer to a page object"]
    #[doc = " @param anim_time animation time in milliseconds"]
    pub fn lv_page_set_anim_time(page: *mut lv_obj_t, anim_time: u16);
}
extern "C" {
    #[doc = " Enable the scroll propagation feature. If enabled then the page will move its parent if there is"]
    #[doc = " no more space to scroll."]
    #[doc = " @param page pointer to a Page"]
    #[doc = " @param en true or false to enable/disable scroll propagation"]
    pub fn lv_page_set_scroll_propagation(page: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Enable the edge flash effect. (Show an arc when the an edge is reached)"]
    #[doc = " @param page pointer to a Page"]
    #[doc = " @param en true or false to enable/disable end flash"]
    pub fn lv_page_set_edge_flash(page: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Set a style of a page"]
    #[doc = " @param page pointer to a page object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_page_set_style(page: *mut lv_obj_t, type_: lv_page_style_t, style: *const lv_style_t);
}
extern "C" {
    #[doc = " Set the scroll bar mode on a page"]
    #[doc = " @param page pointer to a page object"]
    #[doc = " @return the mode from 'lv_page_sb.mode_t' enum"]
    pub fn lv_page_get_sb_mode(page: *const lv_obj_t) -> lv_sb_mode_t;
}
extern "C" {
    #[doc = " Get the scroll propagation property"]
    #[doc = " @param page pointer to a Page"]
    #[doc = " @return true or false"]
    pub fn lv_page_get_scroll_propagation(page: *mut lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get the edge flash effect property."]
    #[doc = " @param page pointer to a Page"]
    #[doc = " return true or false"]
    pub fn lv_page_get_edge_flash(page: *mut lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get that width which can be set to the children to still not cause overflow (show scrollbars)"]
    #[doc = " @param page pointer to a page object"]
    #[doc = " @return the width which still fits into the page"]
    pub fn lv_page_get_fit_width(page: *mut lv_obj_t) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get that height which can be set to the children to still not cause overflow (show scrollbars)"]
    #[doc = " @param page pointer to a page object"]
    #[doc = " @return the height which still fits into the page"]
    pub fn lv_page_get_fit_height(page: *mut lv_obj_t) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get a style of a page"]
    #[doc = " @param page pointer to page object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to a style"]
    pub fn lv_page_get_style(page: *const lv_obj_t, type_: lv_page_style_t) -> *const lv_style_t;
}
extern "C" {
    #[doc = " Find whether the page has been scrolled to a certain edge."]
    #[doc = " @param page Page object"]
    #[doc = " @param edge Edge to check"]
    #[doc = " @return true if the page is on the specified edge"]
    pub fn lv_page_on_edge(page: *mut lv_obj_t, edge: lv_page_edge_t) -> bool;
}
extern "C" {
    #[doc = " Glue the object to the page. After it the page can be moved (dragged) with this object too."]
    #[doc = " @param obj pointer to an object on a page"]
    #[doc = " @param glue true: enable glue, false: disable glue"]
    pub fn lv_page_glue_obj(obj: *mut lv_obj_t, glue: bool);
}
extern "C" {
    #[doc = " Focus on an object. It ensures that the object will be visible on the page."]
    #[doc = " @param page pointer to a page object"]
    #[doc = " @param obj pointer to an object to focus (must be on the page)"]
    #[doc = " @param anim_en LV_ANIM_ON to focus with animation; LV_ANIM_OFF to focus without animation"]
    pub fn lv_page_focus(page: *mut lv_obj_t, obj: *const lv_obj_t, anim_en: lv_anim_enable_t);
}
extern "C" {
    #[doc = " Scroll the page horizontally"]
    #[doc = " @param page pointer to a page object"]
    #[doc = " @param dist the distance to scroll (< 0: scroll left; > 0 scroll right)"]
    pub fn lv_page_scroll_hor(page: *mut lv_obj_t, dist: lv_coord_t);
}
extern "C" {
    #[doc = " Scroll the page vertically"]
    #[doc = " @param page pointer to a page object"]
    #[doc = " @param dist the distance to scroll (< 0: scroll down; > 0 scroll up)"]
    pub fn lv_page_scroll_ver(page: *mut lv_obj_t, dist: lv_coord_t);
}
extern "C" {
    #[doc = " Not intended to use directly by the user but by other object types internally."]
    #[doc = " Start an edge flash animation. Exactly one `ext->edge_flash.xxx_ip` should be set"]
    #[doc = " @param page"]
    pub fn lv_page_start_edge_flash(page: *mut lv_obj_t);
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_list_ext_t {
    pub page: lv_page_ext_t,
    pub styles_btn: [*const lv_style_t; 5usize],
    pub style_img: *const lv_style_t,
    pub size: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub last_sel: *mut lv_obj_t,
    pub selected_btn: *mut lv_obj_t,
    pub last_clicked_btn: *mut lv_obj_t,
}
impl lv_list_ext_t {
    #[inline]
    pub fn single_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_single_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(single_mode: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let single_mode: u8 = unsafe { ::core::mem::transmute(single_mode) };
            single_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< List background style"]
pub const LV_LIST_STYLE_BG: _bindgen_ty_39 = 0;
#[doc = "< List scrollable area style."]
pub const LV_LIST_STYLE_SCRL: _bindgen_ty_39 = 1;
#[doc = "< List scrollbar style."]
pub const LV_LIST_STYLE_SB: _bindgen_ty_39 = 2;
#[doc = "< List edge flash style."]
pub const LV_LIST_STYLE_EDGE_FLASH: _bindgen_ty_39 = 3;
#[doc = "< Same meaning as the ordinary button styles."]
pub const LV_LIST_STYLE_BTN_REL: _bindgen_ty_39 = 4;
pub const LV_LIST_STYLE_BTN_PR: _bindgen_ty_39 = 5;
pub const LV_LIST_STYLE_BTN_TGL_REL: _bindgen_ty_39 = 6;
pub const LV_LIST_STYLE_BTN_TGL_PR: _bindgen_ty_39 = 7;
pub const LV_LIST_STYLE_BTN_INA: _bindgen_ty_39 = 8;
#[doc = " List styles."]
pub type _bindgen_ty_39 = u32;
pub type lv_list_style_t = u8;
extern "C" {
    #[doc = " Create a list objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new list"]
    #[doc = " @param copy pointer to a list object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created list"]
    pub fn lv_list_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Delete all children of the scrl object, without deleting scrl child."]
    #[doc = " @param list pointer to an object"]
    pub fn lv_list_clean(list: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Add a list element to the list"]
    #[doc = " @param list pointer to list object"]
    #[doc = " @param img_fn file name of an image before the text (NULL if unused)"]
    #[doc = " @param txt text of the list element (NULL if unused)"]
    #[doc = " @return pointer to the new list element which can be customized (a button)"]
    pub fn lv_list_add_btn(
        list: *mut lv_obj_t,
        img_src: *const cty::c_void,
        txt: *const cty::c_char,
    ) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Remove the index of the button in the list"]
    #[doc = " @param list pointer to a list object"]
    #[doc = " @param index pointer to a the button's index in the list, index must be 0 <= index <"]
    #[doc = " lv_list_ext_t.size"]
    #[doc = " @return true: successfully deleted"]
    pub fn lv_list_remove(list: *const lv_obj_t, index: u16) -> bool;
}
extern "C" {
    #[doc = " Set single button selected mode, only one button will be selected if enabled."]
    #[doc = " @param list pointer to the currently pressed list object"]
    #[doc = " @param mode enable(true)/disable(false) single selected mode."]
    pub fn lv_list_set_single_mode(list: *mut lv_obj_t, mode: bool);
}
extern "C" {
    #[doc = " Make a button selected"]
    #[doc = " @param list pointer to a list object"]
    #[doc = " @param btn pointer to a button to select"]
    #[doc = "            NULL to not select any buttons"]
    pub fn lv_list_set_btn_selected(list: *mut lv_obj_t, btn: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Set a style of a list"]
    #[doc = " @param list pointer to a list object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_list_set_style(list: *mut lv_obj_t, type_: lv_list_style_t, style: *const lv_style_t);
}
extern "C" {
    #[doc = " Set layout of a list"]
    #[doc = " @param list pointer to a list object"]
    #[doc = " @param layout which layout should be used"]
    pub fn lv_list_set_layout(list: *mut lv_obj_t, layout: lv_layout_t);
}
extern "C" {
    #[doc = " Get single button selected mode."]
    #[doc = " @param list pointer to the currently pressed list object."]
    pub fn lv_list_get_single_mode(list: *mut lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get the text of a list element"]
    #[doc = " @param btn pointer to list element"]
    #[doc = " @return pointer to the text"]
    pub fn lv_list_get_btn_text(btn: *const lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Get the label object from a list element"]
    #[doc = " @param btn pointer to a list element (button)"]
    #[doc = " @return pointer to the label from the list element or NULL if not found"]
    pub fn lv_list_get_btn_label(btn: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Get the image object from a list element"]
    #[doc = " @param btn pointer to a list element (button)"]
    #[doc = " @return pointer to the image from the list element or NULL if not found"]
    pub fn lv_list_get_btn_img(btn: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Get the next button from list. (Starts from the bottom button)"]
    #[doc = " @param list pointer to a list object"]
    #[doc = " @param prev_btn pointer to button. Search the next after it."]
    #[doc = " @return pointer to the next button or NULL when no more buttons"]
    pub fn lv_list_get_prev_btn(list: *const lv_obj_t, prev_btn: *mut lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Get the previous button from list. (Starts from the top button)"]
    #[doc = " @param list pointer to a list object"]
    #[doc = " @param prev_btn pointer to button. Search the previous before it."]
    #[doc = " @return pointer to the previous button or NULL when no more buttons"]
    pub fn lv_list_get_next_btn(list: *const lv_obj_t, prev_btn: *mut lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Get the index of the button in the list"]
    #[doc = " @param list pointer to a list object. If NULL, assumes btn is part of a list."]
    #[doc = " @param btn pointer to a list element (button)"]
    #[doc = " @return the index of the button in the list, or -1 of the button not in this list"]
    pub fn lv_list_get_btn_index(list: *const lv_obj_t, btn: *const lv_obj_t) -> i32;
}
extern "C" {
    #[doc = " Get the number of buttons in the list"]
    #[doc = " @param list pointer to a list object"]
    #[doc = " @return the number of buttons in the list"]
    pub fn lv_list_get_size(list: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get the currently selected button. Can be used while navigating in the list with a keypad."]
    #[doc = " @param list pointer to a list object"]
    #[doc = " @return pointer to the selected button"]
    pub fn lv_list_get_btn_selected(list: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Get layout of a list"]
    #[doc = " @param list pointer to a list object"]
    #[doc = " @return layout of the list object"]
    pub fn lv_list_get_layout(list: *mut lv_obj_t) -> lv_layout_t;
}
extern "C" {
    #[doc = " Get a style of a list"]
    #[doc = " @param list pointer to a list object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to a style"]
    pub fn lv_list_get_style(list: *const lv_obj_t, type_: lv_list_style_t) -> *const lv_style_t;
}
extern "C" {
    #[doc = " Move the list elements up by one"]
    #[doc = " @param list pointer a to list object"]
    pub fn lv_list_up(list: *const lv_obj_t);
}
extern "C" {
    #[doc = " Move the list elements down by one"]
    #[doc = " @param list pointer to a list object"]
    pub fn lv_list_down(list: *const lv_obj_t);
}
extern "C" {
    #[doc = " Focus on a list button. It ensures that the button will be visible on the list."]
    #[doc = " @param btn pointer to a list button to focus"]
    #[doc = " @param anim LV_ANOM_ON: scroll with animation, LV_ANIM_OFF: without animation"]
    pub fn lv_list_focus(btn: *const lv_obj_t, anim: lv_anim_enable_t);
}
#[doc = "< Don't draw the series"]
pub const LV_CHART_TYPE_NONE: _bindgen_ty_40 = 0;
#[doc = "< Connect the points with lines"]
pub const LV_CHART_TYPE_LINE: _bindgen_ty_40 = 1;
#[doc = "< Draw columns"]
pub const LV_CHART_TYPE_COLUMN: _bindgen_ty_40 = 2;
#[doc = "< Draw circles on the points"]
pub const LV_CHART_TYPE_POINT: _bindgen_ty_40 = 4;
#[doc = "< Draw vertical lines on points (useful when chart width == point count)"]
pub const LV_CHART_TYPE_VERTICAL_LINE: _bindgen_ty_40 = 8;
#[doc = "< Draw area chart"]
pub const LV_CHART_TYPE_AREA: _bindgen_ty_40 = 16;
#[doc = " Chart types"]
pub type _bindgen_ty_40 = u32;
pub type lv_chart_type_t = u8;
#[doc = "< Shift old data to the left and add the new one o the right"]
pub const LV_CHART_UPDATE_MODE_SHIFT: _bindgen_ty_41 = 0;
#[doc = "< Add the new data in a circular way"]
pub const LV_CHART_UPDATE_MODE_CIRCULAR: _bindgen_ty_41 = 1;
#[doc = " Chart update mode for `lv_chart_set_next`"]
pub type _bindgen_ty_41 = u32;
pub type lv_chart_update_mode_t = u8;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_chart_series_t {
    pub points: *mut lv_coord_t,
    pub color: lv_color_t,
    pub start_point: u16,
}
#[doc = "< don't draw the last tick"]
pub const LV_CHART_AXIS_SKIP_LAST_TICK: _bindgen_ty_42 = 0;
#[doc = "< draw the last tick"]
pub const LV_CHART_AXIS_DRAW_LAST_TICK: _bindgen_ty_42 = 1;
#[doc = "< draw tick labels in an inversed order"]
pub const LV_CHART_AXIS_INVERSE_LABELS_ORDER: _bindgen_ty_42 = 2;
#[doc = " Data of axis"]
pub type _bindgen_ty_42 = u32;
pub type lv_chart_axis_options_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_chart_axis_cfg_t {
    pub list_of_values: *const cty::c_char,
    pub options: lv_chart_axis_options_t,
    pub num_tick_marks: u8,
    pub major_tick_len: u8,
    pub minor_tick_len: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_chart_ext_t {
    pub series_ll: lv_ll_t,
    pub ymin: lv_coord_t,
    pub ymax: lv_coord_t,
    pub hdiv_cnt: u8,
    pub vdiv_cnt: u8,
    pub point_cnt: u16,
    pub type_: lv_chart_type_t,
    pub y_axis: lv_chart_axis_cfg_t,
    pub x_axis: lv_chart_axis_cfg_t,
    pub secondary_y_axis: lv_chart_axis_cfg_t,
    pub margin: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub series: lv_chart_ext_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_chart_ext_t__bindgen_ty_1 {
    pub width: lv_coord_t,
    pub num: u8,
    pub opa: lv_opa_t,
    pub dark: lv_opa_t,
}
impl lv_chart_ext_t {
    #[inline]
    pub fn update_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_update_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(update_mode: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let update_mode: u8 = unsafe { ::core::mem::transmute(update_mode) };
            update_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_CHART_STYLE_MAIN: _bindgen_ty_43 = 0;
pub type _bindgen_ty_43 = u32;
pub type lv_chart_style_t = u8;
extern "C" {
    #[doc = " Create a chart background objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new chart background"]
    #[doc = " @param copy pointer to a chart background object, if not NULL then the new object will be copied"]
    #[doc = " from it"]
    #[doc = " @return pointer to the created chart background"]
    pub fn lv_chart_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Allocate and add a data series to the chart"]
    #[doc = " @param chart pointer to a chart object"]
    #[doc = " @param color color of the data series"]
    #[doc = " @return pointer to the allocated data series"]
    pub fn lv_chart_add_series(chart: *mut lv_obj_t, color: lv_color_t) -> *mut lv_chart_series_t;
}
extern "C" {
    #[doc = " Clear the point of a serie"]
    #[doc = " @param chart pointer to a chart object"]
    #[doc = " @param serie pointer to the chart's serie to clear"]
    pub fn lv_chart_clear_serie(chart: *mut lv_obj_t, serie: *mut lv_chart_series_t);
}
extern "C" {
    #[doc = " Set the number of horizontal and vertical division lines"]
    #[doc = " @param chart pointer to a graph background object"]
    #[doc = " @param hdiv number of horizontal division lines"]
    #[doc = " @param vdiv number of vertical division lines"]
    pub fn lv_chart_set_div_line_count(chart: *mut lv_obj_t, hdiv: u8, vdiv: u8);
}
extern "C" {
    #[doc = " Set the minimal and maximal y values"]
    #[doc = " @param chart pointer to a graph background object"]
    #[doc = " @param ymin y minimum value"]
    #[doc = " @param ymax y maximum value"]
    pub fn lv_chart_set_range(chart: *mut lv_obj_t, ymin: lv_coord_t, ymax: lv_coord_t);
}
extern "C" {
    #[doc = " Set a new type for a chart"]
    #[doc = " @param chart pointer to a chart object"]
    #[doc = " @param type new type of the chart (from 'lv_chart_type_t' enum)"]
    pub fn lv_chart_set_type(chart: *mut lv_obj_t, type_: lv_chart_type_t);
}
extern "C" {
    #[doc = " Set the number of points on a data line on a chart"]
    #[doc = " @param chart pointer r to chart object"]
    #[doc = " @param point_cnt new number of points on the data lines"]
    pub fn lv_chart_set_point_count(chart: *mut lv_obj_t, point_cnt: u16);
}
extern "C" {
    #[doc = " Set the opacity of the data series"]
    #[doc = " @param chart pointer to a chart object"]
    #[doc = " @param opa opacity of the data series"]
    pub fn lv_chart_set_series_opa(chart: *mut lv_obj_t, opa: lv_opa_t);
}
extern "C" {
    #[doc = " Set the line width or point radius of the data series"]
    #[doc = " @param chart pointer to a chart object"]
    #[doc = " @param width the new width"]
    pub fn lv_chart_set_series_width(chart: *mut lv_obj_t, width: lv_coord_t);
}
extern "C" {
    #[doc = " Set the dark effect on the bottom of the points or columns"]
    #[doc = " @param chart pointer to a chart object"]
    #[doc = " @param dark_eff dark effect level (LV_OPA_TRANSP to turn off)"]
    pub fn lv_chart_set_series_darking(chart: *mut lv_obj_t, dark_eff: lv_opa_t);
}
extern "C" {
    #[doc = " Initialize all data points with a value"]
    #[doc = " @param chart pointer to chart object"]
    #[doc = " @param ser pointer to a data series on 'chart'"]
    #[doc = " @param y the new value  for all points"]
    pub fn lv_chart_init_points(chart: *mut lv_obj_t, ser: *mut lv_chart_series_t, y: lv_coord_t);
}
extern "C" {
    #[doc = " Set the value of points from an array"]
    #[doc = " @param chart pointer to chart object"]
    #[doc = " @param ser pointer to a data series on 'chart'"]
    #[doc = " @param y_array array of 'lv_coord_t' points (with 'points count' elements )"]
    pub fn lv_chart_set_points(
        chart: *mut lv_obj_t,
        ser: *mut lv_chart_series_t,
        y_array: *mut lv_coord_t,
    );
}
extern "C" {
    #[doc = " Shift all data right and set the most right data on a data line"]
    #[doc = " @param chart pointer to chart object"]
    #[doc = " @param ser pointer to a data series on 'chart'"]
    #[doc = " @param y the new value of the most right data"]
    pub fn lv_chart_set_next(chart: *mut lv_obj_t, ser: *mut lv_chart_series_t, y: lv_coord_t);
}
extern "C" {
    #[doc = " Set update mode of the chart object."]
    #[doc = " @param chart pointer to a chart object"]
    #[doc = " @param update mode"]
    pub fn lv_chart_set_update_mode(chart: *mut lv_obj_t, update_mode: lv_chart_update_mode_t);
}
extern "C" {
    #[doc = " Set the length of the tick marks on the x axis"]
    #[doc = " @param chart pointer to the chart"]
    #[doc = " @param major_tick_len the length of the major tick or `LV_CHART_TICK_LENGTH_AUTO` to set automatically"]
    #[doc = "                       (where labels are added)"]
    #[doc = " @param minor_tick_len the length of the minor tick, `LV_CHART_TICK_LENGTH_AUTO` to set automatically"]
    #[doc = "                       (where no labels are added)"]
    pub fn lv_chart_set_x_tick_length(chart: *mut lv_obj_t, major_tick_len: u8, minor_tick_len: u8);
}
extern "C" {
    #[doc = " Set the length of the tick marks on the y axis"]
    #[doc = " @param chart pointer to the chart"]
    #[doc = " @param major_tick_len the length of the major tick or `LV_CHART_TICK_LENGTH_AUTO` to set automatically"]
    #[doc = "                       (where labels are added)"]
    #[doc = " @param minor_tick_len the length of the minor tick, `LV_CHART_TICK_LENGTH_AUTO` to set automatically"]
    #[doc = "                       (where no labels are added)"]
    pub fn lv_chart_set_y_tick_length(chart: *mut lv_obj_t, major_tick_len: u8, minor_tick_len: u8);
}
extern "C" {
    #[doc = " Set the length of the tick marks on the secondary y axis"]
    #[doc = " @param chart pointer to the chart"]
    #[doc = " @param major_tick_len the length of the major tick or `LV_CHART_TICK_LENGTH_AUTO` to set automatically"]
    #[doc = "                       (where labels are added)"]
    #[doc = " @param minor_tick_len the length of the minor tick, `LV_CHART_TICK_LENGTH_AUTO` to set automatically"]
    #[doc = "                       (where no labels are added)"]
    pub fn lv_chart_set_secondary_y_tick_length(
        chart: *mut lv_obj_t,
        major_tick_len: u8,
        minor_tick_len: u8,
    );
}
extern "C" {
    #[doc = " Set the x-axis tick count and labels of a chart"]
    #[doc = " @param chart             pointer to a chart object"]
    #[doc = " @param list_of_values    list of string values, terminated with \\n, except the last"]
    #[doc = " @param num_tick_marks    if list_of_values is NULL: total number of ticks per axis"]
    #[doc = "                          else number of ticks between two value labels"]
    #[doc = " @param options           extra options"]
    pub fn lv_chart_set_x_tick_texts(
        chart: *mut lv_obj_t,
        list_of_values: *const cty::c_char,
        num_tick_marks: u8,
        options: lv_chart_axis_options_t,
    );
}
extern "C" {
    #[doc = " Set the secondary y-axis tick count and labels of a chart"]
    #[doc = " @param chart             pointer to a chart object"]
    #[doc = " @param list_of_values    list of string values, terminated with \\n, except the last"]
    #[doc = " @param num_tick_marks    if list_of_values is NULL: total number of ticks per axis"]
    #[doc = "                          else number of ticks between two value labels"]
    #[doc = " @param options           extra options"]
    pub fn lv_chart_set_secondary_y_tick_texts(
        chart: *mut lv_obj_t,
        list_of_values: *const cty::c_char,
        num_tick_marks: u8,
        options: lv_chart_axis_options_t,
    );
}
extern "C" {
    #[doc = " Set the y-axis tick count and labels of a chart"]
    #[doc = " @param chart             pointer to a chart object"]
    #[doc = " @param list_of_values    list of string values, terminated with \\n, except the last"]
    #[doc = " @param num_tick_marks    if list_of_values is NULL: total number of ticks per axis"]
    #[doc = "                          else number of ticks between two value labels"]
    #[doc = " @param options           extra options"]
    pub fn lv_chart_set_y_tick_texts(
        chart: *mut lv_obj_t,
        list_of_values: *const cty::c_char,
        num_tick_marks: u8,
        options: lv_chart_axis_options_t,
    );
}
extern "C" {
    #[doc = " Set the margin around the chart, used for axes value and ticks"]
    #[doc = " @param chart     pointer to an chart object"]
    #[doc = " @param margin    value of the margin [px]"]
    pub fn lv_chart_set_margin(chart: *mut lv_obj_t, margin: u16);
}
extern "C" {
    #[doc = " Get the type of a chart"]
    #[doc = " @param chart pointer to chart object"]
    #[doc = " @return type of the chart (from 'lv_chart_t' enum)"]
    pub fn lv_chart_get_type(chart: *const lv_obj_t) -> lv_chart_type_t;
}
extern "C" {
    #[doc = " Get the data point number per data line on chart"]
    #[doc = " @param chart pointer to chart object"]
    #[doc = " @return point number on each data line"]
    pub fn lv_chart_get_point_cnt(chart: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get the opacity of the data series"]
    #[doc = " @param chart pointer to chart object"]
    #[doc = " @return the opacity of the data series"]
    pub fn lv_chart_get_series_opa(chart: *const lv_obj_t) -> lv_opa_t;
}
extern "C" {
    #[doc = " Get the data series width"]
    #[doc = " @param chart pointer to chart object"]
    #[doc = " @return the width the data series (lines or points)"]
    pub fn lv_chart_get_series_width(chart: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get the dark effect level on the bottom of the points or columns"]
    #[doc = " @param chart pointer to chart object"]
    #[doc = " @return dark effect level (LV_OPA_TRANSP to turn off)"]
    pub fn lv_chart_get_series_darking(chart: *const lv_obj_t) -> lv_opa_t;
}
extern "C" {
    #[doc = " Get the margin around the chart, used for axes value and labels"]
    #[doc = " @param chart pointer to an chart object"]
    #[doc = " @param return value of the margin"]
    pub fn lv_chart_get_margin(chart: *mut lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Refresh a chart if its data line has changed"]
    #[doc = " @param chart pointer to chart object"]
    pub fn lv_chart_refresh(chart: *mut lv_obj_t);
}
#[doc = " Internal table cell format structure."]
#[doc = ""]
#[doc = " Use the `lv_table` APIs instead."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union lv_table_cell_format_t {
    pub s: lv_table_cell_format_t__bindgen_ty_1,
    pub format_byte: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct lv_table_cell_format_t__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl lv_table_cell_format_t__bindgen_ty_1 {
    #[inline]
    pub fn align(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_align(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn right_merge(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_right_merge(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn crop(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_crop(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        align: u8,
        right_merge: u8,
        type_: u8,
        crop: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let align: u8 = unsafe { ::core::mem::transmute(align) };
            align as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let right_merge: u8 = unsafe { ::core::mem::transmute(right_merge) };
            right_merge as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let type_: u8 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let crop: u8 = unsafe { ::core::mem::transmute(crop) };
            crop as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_table_ext_t {
    pub col_cnt: u16,
    pub row_cnt: u16,
    pub cell_data: *mut *mut cty::c_char,
    pub cell_style: [*const lv_style_t; 4usize],
    pub col_w: [lv_coord_t; 12usize],
}
pub const LV_TABLE_STYLE_BG: _bindgen_ty_44 = 0;
pub const LV_TABLE_STYLE_CELL1: _bindgen_ty_44 = 1;
pub const LV_TABLE_STYLE_CELL2: _bindgen_ty_44 = 2;
pub const LV_TABLE_STYLE_CELL3: _bindgen_ty_44 = 3;
pub const LV_TABLE_STYLE_CELL4: _bindgen_ty_44 = 4;
pub type _bindgen_ty_44 = u32;
pub type lv_table_style_t = u8;
extern "C" {
    #[doc = " Create a table object"]
    #[doc = " @param par pointer to an object, it will be the parent of the new table"]
    #[doc = " @param copy pointer to a table object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created table"]
    pub fn lv_table_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set the value of a cell."]
    #[doc = " @param table pointer to a Table object"]
    #[doc = " @param row id of the row [0 .. row_cnt -1]"]
    #[doc = " @param col id of the column [0 .. col_cnt -1]"]
    #[doc = " @param txt text to display in the cell. It will be copied and saved so this variable is not"]
    #[doc = " required after this function call."]
    pub fn lv_table_set_cell_value(
        table: *mut lv_obj_t,
        row: u16,
        col: u16,
        txt: *const cty::c_char,
    );
}
extern "C" {
    #[doc = " Set the number of rows"]
    #[doc = " @param table table pointer to a Table object"]
    #[doc = " @param row_cnt number of rows"]
    pub fn lv_table_set_row_cnt(table: *mut lv_obj_t, row_cnt: u16);
}
extern "C" {
    #[doc = " Set the number of columns"]
    #[doc = " @param table table pointer to a Table object"]
    #[doc = " @param col_cnt number of columns. Must be < LV_TABLE_COL_MAX"]
    pub fn lv_table_set_col_cnt(table: *mut lv_obj_t, col_cnt: u16);
}
extern "C" {
    #[doc = " Set the width of a column"]
    #[doc = " @param table table pointer to a Table object"]
    #[doc = " @param col_id id of the column [0 .. LV_TABLE_COL_MAX -1]"]
    #[doc = " @param w width of the column"]
    pub fn lv_table_set_col_width(table: *mut lv_obj_t, col_id: u16, w: lv_coord_t);
}
extern "C" {
    #[doc = " Set the text align in a cell"]
    #[doc = " @param table pointer to a Table object"]
    #[doc = " @param row id of the row [0 .. row_cnt -1]"]
    #[doc = " @param col id of the column [0 .. col_cnt -1]"]
    #[doc = " @param align LV_LABEL_ALIGN_LEFT or LV_LABEL_ALIGN_CENTER or LV_LABEL_ALIGN_RIGHT"]
    pub fn lv_table_set_cell_align(
        table: *mut lv_obj_t,
        row: u16,
        col: u16,
        align: lv_label_align_t,
    );
}
extern "C" {
    #[doc = " Set the type of a cell."]
    #[doc = " @param table pointer to a Table object"]
    #[doc = " @param row id of the row [0 .. row_cnt -1]"]
    #[doc = " @param col id of the column [0 .. col_cnt -1]"]
    #[doc = " @param type 1,2,3 or 4. The cell style will be chosen accordingly."]
    pub fn lv_table_set_cell_type(table: *mut lv_obj_t, row: u16, col: u16, type_: u8);
}
extern "C" {
    #[doc = " Set the cell crop. (Don't adjust the height of the cell according to its content)"]
    #[doc = " @param table pointer to a Table object"]
    #[doc = " @param row id of the row [0 .. row_cnt -1]"]
    #[doc = " @param col id of the column [0 .. col_cnt -1]"]
    #[doc = " @param crop true: crop the cell content; false: set the cell height to the content."]
    pub fn lv_table_set_cell_crop(table: *mut lv_obj_t, row: u16, col: u16, crop: bool);
}
extern "C" {
    #[doc = " Merge a cell with the right neighbor. The value of the cell to the right won't be displayed."]
    #[doc = " @param table table pointer to a Table object"]
    #[doc = " @param row id of the row [0 .. row_cnt -1]"]
    #[doc = " @param col id of the column [0 .. col_cnt -1]"]
    #[doc = " @param en true: merge right; false: don't merge right"]
    pub fn lv_table_set_cell_merge_right(table: *mut lv_obj_t, row: u16, col: u16, en: bool);
}
extern "C" {
    #[doc = " Set a style of a table."]
    #[doc = " @param table pointer to table object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_table_set_style(
        table: *mut lv_obj_t,
        type_: lv_table_style_t,
        style: *const lv_style_t,
    );
}
extern "C" {
    #[doc = " Get the value of a cell."]
    #[doc = " @param table pointer to a Table object"]
    #[doc = " @param row id of the row [0 .. row_cnt -1]"]
    #[doc = " @param col id of the column [0 .. col_cnt -1]"]
    #[doc = " @return text in the cell"]
    pub fn lv_table_get_cell_value(table: *mut lv_obj_t, row: u16, col: u16) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Get the number of rows."]
    #[doc = " @param table table pointer to a Table object"]
    #[doc = " @return number of rows."]
    pub fn lv_table_get_row_cnt(table: *mut lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get the number of columns."]
    #[doc = " @param table table pointer to a Table object"]
    #[doc = " @return number of columns."]
    pub fn lv_table_get_col_cnt(table: *mut lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get the width of a column"]
    #[doc = " @param table table pointer to a Table object"]
    #[doc = " @param col_id id of the column [0 .. LV_TABLE_COL_MAX -1]"]
    #[doc = " @return width of the column"]
    pub fn lv_table_get_col_width(table: *mut lv_obj_t, col_id: u16) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get the text align of a cell"]
    #[doc = " @param table pointer to a Table object"]
    #[doc = " @param row id of the row [0 .. row_cnt -1]"]
    #[doc = " @param col id of the column [0 .. col_cnt -1]"]
    #[doc = " @return LV_LABEL_ALIGN_LEFT (default in case of error) or LV_LABEL_ALIGN_CENTER or"]
    #[doc = " LV_LABEL_ALIGN_RIGHT"]
    pub fn lv_table_get_cell_align(table: *mut lv_obj_t, row: u16, col: u16) -> lv_label_align_t;
}
extern "C" {
    #[doc = " Get the type of a cell"]
    #[doc = " @param table pointer to a Table object"]
    #[doc = " @param row id of the row [0 .. row_cnt -1]"]
    #[doc = " @param col id of the column [0 .. col_cnt -1]"]
    #[doc = " @return 1,2,3 or 4"]
    pub fn lv_table_get_cell_type(table: *mut lv_obj_t, row: u16, col: u16) -> lv_label_align_t;
}
extern "C" {
    #[doc = " Get the crop property of a cell"]
    #[doc = " @param table pointer to a Table object"]
    #[doc = " @param row id of the row [0 .. row_cnt -1]"]
    #[doc = " @param col id of the column [0 .. col_cnt -1]"]
    #[doc = " @return true: text crop enabled; false: disabled"]
    pub fn lv_table_get_cell_crop(table: *mut lv_obj_t, row: u16, col: u16) -> lv_label_align_t;
}
extern "C" {
    #[doc = " Get the cell merge attribute."]
    #[doc = " @param table table pointer to a Table object"]
    #[doc = " @param row id of the row [0 .. row_cnt -1]"]
    #[doc = " @param col id of the column [0 .. col_cnt -1]"]
    #[doc = " @return true: merge right; false: don't merge right"]
    pub fn lv_table_get_cell_merge_right(table: *mut lv_obj_t, row: u16, col: u16) -> bool;
}
extern "C" {
    #[doc = " Get style of a table."]
    #[doc = " @param table pointer to table object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to the style"]
    pub fn lv_table_get_style(table: *const lv_obj_t, type_: lv_table_style_t)
        -> *const lv_style_t;
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_cb_ext_t {
    pub bg_btn: lv_btn_ext_t,
    pub bullet: *mut lv_obj_t,
    pub label: *mut lv_obj_t,
}
#[doc = "< Style of object background."]
pub const LV_CB_STYLE_BG: _bindgen_ty_45 = 0;
#[doc = "< Style of box (released)."]
pub const LV_CB_STYLE_BOX_REL: _bindgen_ty_45 = 1;
#[doc = "< Style of box (pressed)."]
pub const LV_CB_STYLE_BOX_PR: _bindgen_ty_45 = 2;
#[doc = "< Style of box (released but checked)."]
pub const LV_CB_STYLE_BOX_TGL_REL: _bindgen_ty_45 = 3;
#[doc = "< Style of box (pressed and checked)."]
pub const LV_CB_STYLE_BOX_TGL_PR: _bindgen_ty_45 = 4;
#[doc = "< Style of disabled box"]
pub const LV_CB_STYLE_BOX_INA: _bindgen_ty_45 = 5;
#[doc = " Checkbox styles."]
pub type _bindgen_ty_45 = u32;
pub type lv_cb_style_t = u8;
extern "C" {
    #[doc = " Create a check box objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new check box"]
    #[doc = " @param copy pointer to a check box object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created check box"]
    pub fn lv_cb_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set the text of a check box. `txt` will be copied and may be deallocated"]
    #[doc = " after this function returns."]
    #[doc = " @param cb pointer to a check box"]
    #[doc = " @param txt the text of the check box. NULL to refresh with the current text."]
    pub fn lv_cb_set_text(cb: *mut lv_obj_t, txt: *const cty::c_char);
}
extern "C" {
    #[doc = " Set the text of a check box. `txt` must not be deallocated during the life"]
    #[doc = " of this checkbox."]
    #[doc = " @param cb pointer to a check box"]
    #[doc = " @param txt the text of the check box. NULL to refresh with the current text."]
    pub fn lv_cb_set_static_text(cb: *mut lv_obj_t, txt: *const cty::c_char);
}
extern "C" {
    #[doc = " Set a style of a check box"]
    #[doc = " @param cb pointer to check box object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_cb_set_style(cb: *mut lv_obj_t, type_: lv_cb_style_t, style: *const lv_style_t);
}
extern "C" {
    #[doc = " Get the text of a check box"]
    #[doc = " @param cb pointer to check box object"]
    #[doc = " @return pointer to the text of the check box"]
    pub fn lv_cb_get_text(cb: *const lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Get a style of a button"]
    #[doc = " @param cb pointer to check box object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to the style"]
    pub fn lv_cb_get_style(cb: *const lv_obj_t, type_: lv_cb_style_t) -> *const lv_style_t;
}
pub const LV_CPICKER_TYPE_RECT: _bindgen_ty_46 = 0;
pub const LV_CPICKER_TYPE_DISC: _bindgen_ty_46 = 1;
#[doc = "      TYPEDEFS"]
pub type _bindgen_ty_46 = u32;
pub type lv_cpicker_type_t = u8;
pub const LV_CPICKER_COLOR_MODE_HUE: _bindgen_ty_47 = 0;
pub const LV_CPICKER_COLOR_MODE_SATURATION: _bindgen_ty_47 = 1;
pub const LV_CPICKER_COLOR_MODE_VALUE: _bindgen_ty_47 = 2;
pub type _bindgen_ty_47 = u32;
pub type lv_cpicker_color_mode_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_cpicker_ext_t {
    pub hsv: lv_color_hsv_t,
    pub indic: lv_cpicker_ext_t__bindgen_ty_1,
    pub last_click_time: u32,
    pub last_change_time: u32,
    pub last_press_point: lv_point_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_cpicker_ext_t__bindgen_ty_1 {
    pub style: *mut lv_style_t,
    pub pos: lv_point_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl lv_cpicker_ext_t__bindgen_ty_1 {
    #[inline]
    pub fn colored(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_colored(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(colored: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let colored: u8 = unsafe { ::core::mem::transmute(colored) };
            colored as u64
        });
        __bindgen_bitfield_unit
    }
}
impl lv_cpicker_ext_t {
    #[inline]
    pub fn color_mode(&self) -> lv_cpicker_color_mode_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_color_mode(&mut self, val: lv_cpicker_color_mode_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn color_mode_fixed(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_color_mode_fixed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> lv_cpicker_type_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: lv_cpicker_type_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn preview(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_preview(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        color_mode: lv_cpicker_color_mode_t,
        color_mode_fixed: u8,
        type_: lv_cpicker_type_t,
        preview: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let color_mode: u8 = unsafe { ::core::mem::transmute(color_mode) };
            color_mode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let color_mode_fixed: u8 = unsafe { ::core::mem::transmute(color_mode_fixed) };
            color_mode_fixed as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let type_: u8 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let preview: u8 = unsafe { ::core::mem::transmute(preview) };
            preview as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_CPICKER_STYLE_MAIN: _bindgen_ty_48 = 0;
pub const LV_CPICKER_STYLE_INDICATOR: _bindgen_ty_48 = 1;
pub type _bindgen_ty_48 = u32;
pub type lv_cpicker_style_t = u8;
extern "C" {
    #[doc = " Create a colorpicker objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new colorpicker"]
    #[doc = " @param copy pointer to a colorpicker object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created colorpicker"]
    pub fn lv_cpicker_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set a new type for a colorpicker"]
    #[doc = " @param cpicker pointer to a colorpicker object"]
    #[doc = " @param type new type of the colorpicker (from 'lv_cpicker_type_t' enum)"]
    pub fn lv_cpicker_set_type(cpicker: *mut lv_obj_t, type_: lv_cpicker_type_t);
}
extern "C" {
    #[doc = " Set a style of a colorpicker."]
    #[doc = " @param cpicker pointer to colorpicker object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_cpicker_set_style(
        cpicker: *mut lv_obj_t,
        type_: lv_cpicker_style_t,
        style: *mut lv_style_t,
    );
}
extern "C" {
    #[doc = " Set the current hue of a colorpicker."]
    #[doc = " @param cpicker pointer to colorpicker object"]
    #[doc = " @param hue current selected hue [0..360]"]
    #[doc = " @return true if changed, otherwise false"]
    pub fn lv_cpicker_set_hue(cpicker: *mut lv_obj_t, hue: u16) -> bool;
}
extern "C" {
    #[doc = " Set the current saturation of a colorpicker."]
    #[doc = " @param cpicker pointer to colorpicker object"]
    #[doc = " @param saturation current selected saturation [0..100]"]
    #[doc = " @return true if changed, otherwise false"]
    pub fn lv_cpicker_set_saturation(cpicker: *mut lv_obj_t, saturation: u8) -> bool;
}
extern "C" {
    #[doc = " Set the current value of a colorpicker."]
    #[doc = " @param cpicker pointer to colorpicker object"]
    #[doc = " @param val current selected value [0..100]"]
    #[doc = " @return true if changed, otherwise false"]
    pub fn lv_cpicker_set_value(cpicker: *mut lv_obj_t, val: u8) -> bool;
}
extern "C" {
    #[doc = " Set the current hsv of a colorpicker."]
    #[doc = " @param cpicker pointer to colorpicker object"]
    #[doc = " @param hsv current selected hsv"]
    #[doc = " @return true if changed, otherwise false"]
    pub fn lv_cpicker_set_hsv(cpicker: *mut lv_obj_t, hsv: lv_color_hsv_t) -> bool;
}
extern "C" {
    #[doc = " Set the current color of a colorpicker."]
    #[doc = " @param cpicker pointer to colorpicker object"]
    #[doc = " @param color current selected color"]
    #[doc = " @return true if changed, otherwise false"]
    pub fn lv_cpicker_set_color(cpicker: *mut lv_obj_t, color: lv_color_t) -> bool;
}
extern "C" {
    #[doc = " Set the current color mode."]
    #[doc = " @param cpicker pointer to colorpicker object"]
    #[doc = " @param mode color mode (hue/sat/val)"]
    pub fn lv_cpicker_set_color_mode(cpicker: *mut lv_obj_t, mode: lv_cpicker_color_mode_t);
}
extern "C" {
    #[doc = " Set if the color mode is changed on long press on center"]
    #[doc = " @param cpicker pointer to colorpicker object"]
    #[doc = " @param fixed color mode cannot be changed on long press"]
    pub fn lv_cpicker_set_color_mode_fixed(cpicker: *mut lv_obj_t, fixed: bool);
}
extern "C" {
    #[doc = " Make the indicator to be colored to the current color"]
    #[doc = " @param cpicker pointer to colorpicker object"]
    #[doc = " @param en true: color the indicator; false: not color the indicator"]
    pub fn lv_cpicker_set_indic_colored(cpicker: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Add a color preview in the middle of the DISC type color picker"]
    #[doc = " @param cpicker pointer to colorpicker object"]
    #[doc = " @param en true: enable preview; false: disable preview"]
    pub fn lv_cpicker_set_preview(cpicker: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Get the current color mode."]
    #[doc = " @param cpicker pointer to colorpicker object"]
    #[doc = " @return color mode (hue/sat/val)"]
    pub fn lv_cpicker_get_color_mode(cpicker: *mut lv_obj_t) -> lv_cpicker_color_mode_t;
}
extern "C" {
    #[doc = " Get if the color mode is changed on long press on center"]
    #[doc = " @param cpicker pointer to colorpicker object"]
    #[doc = " @return mode cannot be changed on long press"]
    pub fn lv_cpicker_get_color_mode_fixed(cpicker: *mut lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get style of a colorpicker."]
    #[doc = " @param cpicker pointer to colorpicker object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return pointer to the style"]
    pub fn lv_cpicker_get_style(
        cpicker: *const lv_obj_t,
        type_: lv_cpicker_style_t,
    ) -> *const lv_style_t;
}
extern "C" {
    #[doc = " Get the current hue of a colorpicker."]
    #[doc = " @param cpicker pointer to colorpicker object"]
    #[doc = " @return current selected hue"]
    pub fn lv_cpicker_get_hue(cpicker: *mut lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get the current saturation of a colorpicker."]
    #[doc = " @param cpicker pointer to colorpicker object"]
    #[doc = " @return current selected saturation"]
    pub fn lv_cpicker_get_saturation(cpicker: *mut lv_obj_t) -> u8;
}
extern "C" {
    #[doc = " Get the current hue of a colorpicker."]
    #[doc = " @param cpicker pointer to colorpicker object"]
    #[doc = " @return current selected value"]
    pub fn lv_cpicker_get_value(cpicker: *mut lv_obj_t) -> u8;
}
extern "C" {
    #[doc = " Get the current selected hsv of a colorpicker."]
    #[doc = " @param cpicker pointer to colorpicker object"]
    #[doc = " @return current selected hsv"]
    pub fn lv_cpicker_get_hsv(cpicker: *mut lv_obj_t) -> lv_color_hsv_t;
}
extern "C" {
    #[doc = " Get the current selected color of a colorpicker."]
    #[doc = " @param cpicker pointer to colorpicker object"]
    #[doc = " @return current selected color"]
    pub fn lv_cpicker_get_color(cpicker: *mut lv_obj_t) -> lv_color_t;
}
extern "C" {
    #[doc = " Whether the indicator is colored to the current color or not"]
    #[doc = " @param cpicker pointer to colorpicker object"]
    #[doc = " @return true: color the indicator; false: not color the indicator"]
    pub fn lv_cpicker_get_indic_colored(cpicker: *mut lv_obj_t) -> bool;
}
extern "C" {
    #[doc = "  Whether the preview is enabled or not"]
    #[doc = " @param cpicker pointer to colorpicker object"]
    #[doc = " @return en true: preview is enabled; false: preview is disabled"]
    pub fn lv_cpicker_get_preview(cpicker: *mut lv_obj_t) -> bool;
}
#[doc = " Data of bar"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_bar_ext_t {
    pub cur_value: i16,
    pub min_value: i16,
    pub max_value: i16,
    pub anim_start: lv_anim_value_t,
    pub anim_end: lv_anim_value_t,
    pub anim_state: lv_anim_value_t,
    pub anim_time: lv_anim_value_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub style_indic: *const lv_style_t,
}
impl lv_bar_ext_t {
    #[inline]
    pub fn sym(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sym(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(sym: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sym: u8 = unsafe { ::core::mem::transmute(sym) };
            sym as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_BAR_STYLE_BG: _bindgen_ty_49 = 0;
#[doc = " Bar background style."]
pub const LV_BAR_STYLE_INDIC: _bindgen_ty_49 = 1;
#[doc = " Bar styles."]
pub type _bindgen_ty_49 = u32;
pub type lv_bar_style_t = u8;
extern "C" {
    #[doc = " Create a bar objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new bar"]
    #[doc = " @param copy pointer to a bar object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created bar"]
    pub fn lv_bar_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set a new value on the bar"]
    #[doc = " @param bar pointer to a bar object"]
    #[doc = " @param value new value"]
    #[doc = " @param anim LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
    pub fn lv_bar_set_value(bar: *mut lv_obj_t, value: i16, anim: lv_anim_enable_t);
}
extern "C" {
    #[doc = " Set minimum and the maximum values of a bar"]
    #[doc = " @param bar pointer to the bar object"]
    #[doc = " @param min minimum value"]
    #[doc = " @param max maximum value"]
    pub fn lv_bar_set_range(bar: *mut lv_obj_t, min: i16, max: i16);
}
extern "C" {
    #[doc = " Make the bar symmetric to zero. The indicator will grow from zero instead of the minimum"]
    #[doc = " position."]
    #[doc = " @param bar pointer to a bar object"]
    #[doc = " @param en true: enable disable symmetric behavior; false: disable"]
    pub fn lv_bar_set_sym(bar: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Set the animation time of the bar"]
    #[doc = " @param bar pointer to a bar object"]
    #[doc = " @param anim_time the animation time in milliseconds."]
    pub fn lv_bar_set_anim_time(bar: *mut lv_obj_t, anim_time: u16);
}
extern "C" {
    #[doc = " Set a style of a bar"]
    #[doc = " @param bar pointer to a bar object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_bar_set_style(bar: *mut lv_obj_t, type_: lv_bar_style_t, style: *const lv_style_t);
}
extern "C" {
    #[doc = " Get the value of a bar"]
    #[doc = " @param bar pointer to a bar object"]
    #[doc = " @return the value of the bar"]
    pub fn lv_bar_get_value(bar: *const lv_obj_t) -> i16;
}
extern "C" {
    #[doc = " Get the minimum value of a bar"]
    #[doc = " @param bar pointer to a bar object"]
    #[doc = " @return the minimum value of the bar"]
    pub fn lv_bar_get_min_value(bar: *const lv_obj_t) -> i16;
}
extern "C" {
    #[doc = " Get the maximum value of a bar"]
    #[doc = " @param bar pointer to a bar object"]
    #[doc = " @return the maximum value of the bar"]
    pub fn lv_bar_get_max_value(bar: *const lv_obj_t) -> i16;
}
extern "C" {
    #[doc = " Get whether the bar is symmetric or not."]
    #[doc = " @param bar pointer to a bar object"]
    #[doc = " @return true: symmetric is enabled; false: disable"]
    pub fn lv_bar_get_sym(bar: *mut lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get the animation time of the bar"]
    #[doc = " @param bar pointer to a bar object"]
    #[doc = " @return the animation time in milliseconds."]
    pub fn lv_bar_get_anim_time(bar: *mut lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get a style of a bar"]
    #[doc = " @param bar pointer to a bar object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to a style"]
    pub fn lv_bar_get_style(bar: *const lv_obj_t, type_: lv_bar_style_t) -> *const lv_style_t;
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_slider_ext_t {
    pub bar: lv_bar_ext_t,
    pub style_knob: *const lv_style_t,
    pub drag_value: i16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 5usize],
}
impl lv_slider_ext_t {
    #[inline]
    pub fn knob_in(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_knob_in(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(knob_in: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let knob_in: u8 = unsafe { ::core::mem::transmute(knob_in) };
            knob_in as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_SLIDER_STYLE_BG: _bindgen_ty_50 = 0;
#[doc = " Slider background style."]
pub const LV_SLIDER_STYLE_INDIC: _bindgen_ty_50 = 1;
#[doc = " Slider indicator (filled area) style."]
pub const LV_SLIDER_STYLE_KNOB: _bindgen_ty_50 = 2;
#[doc = " Built-in styles of slider"]
pub type _bindgen_ty_50 = u32;
pub type lv_slider_style_t = u8;
extern "C" {
    #[doc = " Create a slider objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new slider"]
    #[doc = " @param copy pointer to a slider object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created slider"]
    pub fn lv_slider_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set the 'knob in' attribute of a slider"]
    #[doc = " @param slider pointer to slider object"]
    #[doc = " @param in true: the knob is drawn always in the slider;"]
    #[doc = "           false: the knob can be out on the edges"]
    pub fn lv_slider_set_knob_in(slider: *mut lv_obj_t, in_: bool);
}
extern "C" {
    #[doc = " Set a style of a slider"]
    #[doc = " @param slider pointer to a slider object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_slider_set_style(
        slider: *mut lv_obj_t,
        type_: lv_slider_style_t,
        style: *const lv_style_t,
    );
}
extern "C" {
    #[doc = " Get the value of a slider"]
    #[doc = " @param slider pointer to a slider object"]
    #[doc = " @return the value of the slider"]
    pub fn lv_slider_get_value(slider: *const lv_obj_t) -> i16;
}
extern "C" {
    #[doc = " Give the slider is being dragged or not"]
    #[doc = " @param slider pointer to a slider object"]
    #[doc = " @return true: drag in progress false: not dragged"]
    pub fn lv_slider_is_dragged(slider: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get the 'knob in' attribute of a slider"]
    #[doc = " @param slider pointer to slider object"]
    #[doc = " @return true: the knob is drawn always in the slider;"]
    #[doc = "         false: the knob can be out on the edges"]
    pub fn lv_slider_get_knob_in(slider: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get a style of a slider"]
    #[doc = " @param slider pointer to a slider object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to a style"]
    pub fn lv_slider_get_style(
        slider: *const lv_obj_t,
        type_: lv_slider_style_t,
    ) -> *const lv_style_t;
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_led_ext_t {
    pub bright: u8,
}
pub const LV_LED_STYLE_MAIN: _bindgen_ty_51 = 0;
pub type _bindgen_ty_51 = u32;
pub type lv_led_style_t = u8;
extern "C" {
    #[doc = " Create a led objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new led"]
    #[doc = " @param copy pointer to a led object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created led"]
    pub fn lv_led_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set the brightness of a LED object"]
    #[doc = " @param led pointer to a LED object"]
    #[doc = " @param bright 0 (max. dark) ... 255 (max. light)"]
    pub fn lv_led_set_bright(led: *mut lv_obj_t, bright: u8);
}
extern "C" {
    #[doc = " Light on a LED"]
    #[doc = " @param led pointer to a LED object"]
    pub fn lv_led_on(led: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Light off a LED"]
    #[doc = " @param led pointer to a LED object"]
    pub fn lv_led_off(led: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Toggle the state of a LED"]
    #[doc = " @param led pointer to a LED object"]
    pub fn lv_led_toggle(led: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Get the brightness of a LEd object"]
    #[doc = " @param led pointer to LED object"]
    #[doc = " @return bright 0 (max. dark) ... 255 (max. light)"]
    pub fn lv_led_get_bright(led: *const lv_obj_t) -> u8;
}
#[doc = "< Button hidden"]
pub const LV_BTNM_CTRL_HIDDEN: _bindgen_ty_52 = 8;
#[doc = "< Do not repeat press this button."]
pub const LV_BTNM_CTRL_NO_REPEAT: _bindgen_ty_52 = 16;
#[doc = "< Disable this button."]
pub const LV_BTNM_CTRL_INACTIVE: _bindgen_ty_52 = 32;
#[doc = "< Button *can* be toggled."]
pub const LV_BTNM_CTRL_TGL_ENABLE: _bindgen_ty_52 = 64;
#[doc = "< Button is currently toggled (e.g. checked)."]
pub const LV_BTNM_CTRL_TGL_STATE: _bindgen_ty_52 = 128;
#[doc = "< 1: Send LV_EVENT_SELECTED on CLICK, 0: Send LV_EVENT_SELECTED on PRESS"]
pub const LV_BTNM_CTRL_CLICK_TRIG: _bindgen_ty_52 = 256;
#[doc = " Type to store button control bits (disabled, hidden etc.)"]
pub type _bindgen_ty_52 = u32;
pub type lv_btnm_ctrl_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_btnm_ext_t {
    pub map_p: *mut *const cty::c_char,
    pub button_areas: *mut lv_area_t,
    pub ctrl_bits: *mut lv_btnm_ctrl_t,
    pub styles_btn: [*const lv_style_t; 5usize],
    pub btn_cnt: u16,
    pub btn_id_pr: u16,
    pub btn_id_act: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
impl lv_btnm_ext_t {
    #[inline]
    pub fn recolor(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_recolor(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn one_toggle(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_one_toggle(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(recolor: u8, one_toggle: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let recolor: u8 = unsafe { ::core::mem::transmute(recolor) };
            recolor as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let one_toggle: u8 = unsafe { ::core::mem::transmute(one_toggle) };
            one_toggle as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_BTNM_STYLE_BG: _bindgen_ty_53 = 0;
pub const LV_BTNM_STYLE_BTN_REL: _bindgen_ty_53 = 1;
pub const LV_BTNM_STYLE_BTN_PR: _bindgen_ty_53 = 2;
pub const LV_BTNM_STYLE_BTN_TGL_REL: _bindgen_ty_53 = 3;
pub const LV_BTNM_STYLE_BTN_TGL_PR: _bindgen_ty_53 = 4;
pub const LV_BTNM_STYLE_BTN_INA: _bindgen_ty_53 = 5;
pub type _bindgen_ty_53 = u32;
pub type lv_btnm_style_t = u8;
extern "C" {
    #[doc = " Create a button matrix objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new button matrix"]
    #[doc = " @param copy pointer to a button matrix object, if not NULL then the new object will be copied"]
    #[doc = " from it"]
    #[doc = " @return pointer to the created button matrix"]
    pub fn lv_btnm_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set a new map. Buttons will be created/deleted according to the map. The"]
    #[doc = " button matrix keeps a reference to the map and so the string array must not"]
    #[doc = " be deallocated during the life of the matrix."]
    #[doc = " @param btnm pointer to a button matrix object"]
    #[doc = " @param map pointer a string array. The last string has to be: \"\". Use \"\\n\" to make a line break."]
    pub fn lv_btnm_set_map(btnm: *const lv_obj_t, map: *mut *const cty::c_char);
}
extern "C" {
    #[doc = " Set the button control map (hidden, disabled etc.) for a button matrix. The"]
    #[doc = " control map array will be copied and so may be deallocated after this"]
    #[doc = " function returns."]
    #[doc = " @param btnm pointer to a button matrix object"]
    #[doc = " @param ctrl_map pointer to an array of `lv_btn_ctrl_t` control bytes. The"]
    #[doc = "                 length of the array and position of the elements must match"]
    #[doc = "                 the number and order of the individual buttons (i.e. excludes"]
    #[doc = "                 newline entries)."]
    #[doc = "                 An element of the map should look like e.g.:"]
    #[doc = "                 `ctrl_map[0] = width | LV_BTNM_CTRL_NO_REPEAT |  LV_BTNM_CTRL_TGL_ENABLE`"]
    pub fn lv_btnm_set_ctrl_map(btnm: *const lv_obj_t, ctrl_map: *const lv_btnm_ctrl_t);
}
extern "C" {
    #[doc = " Set the pressed button i.e. visually highlight it."]
    #[doc = " Mainly used a when the btnm is in a group to show the selected button"]
    #[doc = " @param btnm pointer to button matrix object"]
    #[doc = " @param id index of the currently pressed button (`LV_BTNM_BTN_NONE` to unpress)"]
    pub fn lv_btnm_set_pressed(btnm: *const lv_obj_t, id: u16);
}
extern "C" {
    #[doc = " Set a style of a button matrix"]
    #[doc = " @param btnm pointer to a button matrix object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_btnm_set_style(btnm: *mut lv_obj_t, type_: lv_btnm_style_t, style: *const lv_style_t);
}
extern "C" {
    #[doc = " Enable recoloring of button's texts"]
    #[doc = " @param btnm pointer to button matrix object"]
    #[doc = " @param en true: enable recoloring; false: disable"]
    pub fn lv_btnm_set_recolor(btnm: *const lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Set the attributes of a button of the button matrix"]
    #[doc = " @param btnm pointer to button matrix object"]
    #[doc = " @param btn_id 0 based index of the button to modify. (Not counting new lines)"]
    pub fn lv_btnm_set_btn_ctrl(btnm: *const lv_obj_t, btn_id: u16, ctrl: lv_btnm_ctrl_t);
}
extern "C" {
    #[doc = " Clear the attributes of a button of the button matrix"]
    #[doc = " @param btnm pointer to button matrix object"]
    #[doc = " @param btn_id 0 based index of the button to modify. (Not counting new lines)"]
    pub fn lv_btnm_clear_btn_ctrl(btnm: *const lv_obj_t, btn_id: u16, ctrl: lv_btnm_ctrl_t);
}
extern "C" {
    #[doc = " Set the attributes of all buttons of a button matrix"]
    #[doc = " @param btnm pointer to a button matrix object"]
    #[doc = " @param ctrl attribute(s) to set from `lv_btnm_ctrl_t`. Values can be ORed."]
    pub fn lv_btnm_set_btn_ctrl_all(btnm: *mut lv_obj_t, ctrl: lv_btnm_ctrl_t);
}
extern "C" {
    #[doc = " Clear the attributes of all buttons of a button matrix"]
    #[doc = " @param btnm pointer to a button matrix object"]
    #[doc = " @param ctrl attribute(s) to set from `lv_btnm_ctrl_t`. Values can be ORed."]
    #[doc = " @param en true: set the attributes; false: clear the attributes"]
    pub fn lv_btnm_clear_btn_ctrl_all(btnm: *mut lv_obj_t, ctrl: lv_btnm_ctrl_t);
}
extern "C" {
    #[doc = " Set a single buttons relative width."]
    #[doc = " This method will cause the matrix be regenerated and is a relatively"]
    #[doc = " expensive operation. It is recommended that initial width be specified using"]
    #[doc = " `lv_btnm_set_ctrl_map` and this method only be used for dynamic changes."]
    #[doc = " @param btnm pointer to button matrix object"]
    #[doc = " @param btn_id 0 based index of the button to modify."]
    #[doc = " @param width Relative width compared to the buttons in the same row. [1..7]"]
    pub fn lv_btnm_set_btn_width(btnm: *const lv_obj_t, btn_id: u16, width: u8);
}
extern "C" {
    #[doc = " Make the button matrix like a selector widget (only one button may be toggled at a time)."]
    #[doc = ""]
    #[doc = " Toggling must be enabled on the buttons you want to be selected with `lv_btnm_set_ctrl` or"]
    #[doc = " `lv_btnm_set_btn_ctrl_all`."]
    #[doc = ""]
    #[doc = " @param btnm Button matrix object"]
    #[doc = " @param one_toggle Whether \"one toggle\" mode is enabled"]
    pub fn lv_btnm_set_one_toggle(btnm: *mut lv_obj_t, one_toggle: bool);
}
extern "C" {
    #[doc = " Get the current map of a button matrix"]
    #[doc = " @param btnm pointer to a button matrix object"]
    #[doc = " @return the current map"]
    pub fn lv_btnm_get_map_array(btnm: *const lv_obj_t) -> *mut *const cty::c_char;
}
extern "C" {
    #[doc = " Check whether the button's text can use recolor or not"]
    #[doc = " @param btnm pointer to button matrix object"]
    #[doc = " @return true: text recolor enable; false: disabled"]
    pub fn lv_btnm_get_recolor(btnm: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get the index of the lastly \"activated\" button by the user (pressed, released etc)"]
    #[doc = " Useful in the the `event_cb` to get the text of the button, check if hidden etc."]
    #[doc = " @param btnm pointer to button matrix object"]
    #[doc = " @return  index of the last released button (LV_BTNM_BTN_NONE: if unset)"]
    pub fn lv_btnm_get_active_btn(btnm: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get the text of the lastly \"activated\" button by the user (pressed, released etc)"]
    #[doc = " Useful in the the `event_cb`"]
    #[doc = " @param btnm pointer to button matrix object"]
    #[doc = " @return text of the last released button (NULL: if unset)"]
    pub fn lv_btnm_get_active_btn_text(btnm: *const lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Get the pressed button's index."]
    #[doc = " The button be really pressed by the user or manually set to pressed with `lv_btnm_set_pressed`"]
    #[doc = " @param btnm pointer to button matrix object"]
    #[doc = " @return  index of the pressed button (LV_BTNM_BTN_NONE: if unset)"]
    pub fn lv_btnm_get_pressed_btn(btnm: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get the button's text"]
    #[doc = " @param btnm pointer to button matrix object"]
    #[doc = " @param btn_id the index a button not counting new line characters. (The return value of"]
    #[doc = " lv_btnm_get_pressed/released)"]
    #[doc = " @return  text of btn_index` button"]
    pub fn lv_btnm_get_btn_text(btnm: *const lv_obj_t, btn_id: u16) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Get the whether a control value is enabled or disabled for button of a button matrix"]
    #[doc = " @param btnm pointer to a button matrix object"]
    #[doc = " @param btn_id the index a button not counting new line characters. (E.g. the return value of"]
    #[doc = " lv_btnm_get_pressed/released)"]
    #[doc = " @param ctrl control values to check (ORed value can be used)"]
    #[doc = " @return true: long press repeat is disabled; false: long press repeat enabled"]
    pub fn lv_btnm_get_btn_ctrl(btnm: *mut lv_obj_t, btn_id: u16, ctrl: lv_btnm_ctrl_t) -> bool;
}
extern "C" {
    #[doc = " Get a style of a button matrix"]
    #[doc = " @param btnm pointer to a button matrix object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to a style"]
    pub fn lv_btnm_get_style(btnm: *const lv_obj_t, type_: lv_btnm_style_t) -> *const lv_style_t;
}
extern "C" {
    #[doc = " Find whether \"one toggle\" mode is enabled."]
    #[doc = " @param btnm Button matrix object"]
    #[doc = " @return whether \"one toggle\" mode is enabled"]
    pub fn lv_btnm_get_one_toggle(btnm: *const lv_obj_t) -> bool;
}
pub const LV_KB_MODE_TEXT: _bindgen_ty_54 = 0;
pub const LV_KB_MODE_NUM: _bindgen_ty_54 = 1;
pub const LV_KB_MODE_TEXT_UPPER: _bindgen_ty_54 = 2;
#[doc = " Current keyboard mode."]
pub type _bindgen_ty_54 = u32;
pub type lv_kb_mode_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_kb_ext_t {
    pub btnm: lv_btnm_ext_t,
    pub ta: *mut lv_obj_t,
    pub mode: lv_kb_mode_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl lv_kb_ext_t {
    #[inline]
    pub fn cursor_mng(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cursor_mng(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(cursor_mng: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cursor_mng: u8 = unsafe { ::core::mem::transmute(cursor_mng) };
            cursor_mng as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_KB_STYLE_BG: _bindgen_ty_55 = 0;
pub const LV_KB_STYLE_BTN_REL: _bindgen_ty_55 = 1;
pub const LV_KB_STYLE_BTN_PR: _bindgen_ty_55 = 2;
pub const LV_KB_STYLE_BTN_TGL_REL: _bindgen_ty_55 = 3;
pub const LV_KB_STYLE_BTN_TGL_PR: _bindgen_ty_55 = 4;
pub const LV_KB_STYLE_BTN_INA: _bindgen_ty_55 = 5;
pub type _bindgen_ty_55 = u32;
pub type lv_kb_style_t = u8;
extern "C" {
    #[doc = " Create a keyboard objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new keyboard"]
    #[doc = " @param copy pointer to a keyboard object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created keyboard"]
    pub fn lv_kb_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Assign a Text Area to the Keyboard. The pressed characters will be put there."]
    #[doc = " @param kb pointer to a Keyboard object"]
    #[doc = " @param ta pointer to a Text Area object to write there"]
    pub fn lv_kb_set_ta(kb: *mut lv_obj_t, ta: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Set a new a mode (text or number map)"]
    #[doc = " @param kb pointer to a Keyboard object"]
    #[doc = " @param mode the mode from 'lv_kb_mode_t'"]
    pub fn lv_kb_set_mode(kb: *mut lv_obj_t, mode: lv_kb_mode_t);
}
extern "C" {
    #[doc = " Automatically hide or show the cursor of the current Text Area"]
    #[doc = " @param kb pointer to a Keyboard object"]
    #[doc = " @param en true: show cursor on the current text area, false: hide cursor"]
    pub fn lv_kb_set_cursor_manage(kb: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Set a style of a keyboard"]
    #[doc = " @param kb pointer to a keyboard object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_kb_set_style(kb: *mut lv_obj_t, type_: lv_kb_style_t, style: *const lv_style_t);
}
extern "C" {
    #[doc = " Assign a Text Area to the Keyboard. The pressed characters will be put there."]
    #[doc = " @param kb pointer to a Keyboard object"]
    #[doc = " @return pointer to the assigned Text Area object"]
    pub fn lv_kb_get_ta(kb: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set a new a mode (text or number map)"]
    #[doc = " @param kb pointer to a Keyboard object"]
    #[doc = " @return the current mode from 'lv_kb_mode_t'"]
    pub fn lv_kb_get_mode(kb: *const lv_obj_t) -> lv_kb_mode_t;
}
extern "C" {
    #[doc = " Get the current cursor manage mode."]
    #[doc = " @param kb pointer to a Keyboard object"]
    #[doc = " @return true: show cursor on the current text area, false: hide cursor"]
    pub fn lv_kb_get_cursor_manage(kb: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get a style of a keyboard"]
    #[doc = " @param kb pointer to a keyboard object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to a style"]
    pub fn lv_kb_get_style(kb: *const lv_obj_t, type_: lv_kb_style_t) -> *const lv_style_t;
}
extern "C" {
    #[doc = " Default keyboard event to add characters to the Text area and change the map."]
    #[doc = " If a custom `event_cb` is added to the keyboard this function be called from it to handle the"]
    #[doc = " button clicks"]
    #[doc = " @param kb pointer to a  keyboard"]
    #[doc = " @param event the triggering event"]
    pub fn lv_kb_def_event_cb(kb: *mut lv_obj_t, event: lv_event_t);
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_ddlist_ext_t {
    pub page: lv_page_ext_t,
    pub label: *mut lv_obj_t,
    pub sel_style: *const lv_style_t,
    pub option_cnt: u16,
    pub sel_opt_id: u16,
    pub sel_opt_id_ori: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub fix_height: lv_coord_t,
}
impl lv_ddlist_ext_t {
    #[inline]
    pub fn opened(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_opened(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn force_sel(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_sel(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn draw_arrow(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_draw_arrow(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stay_open(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_stay_open(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        opened: u8,
        force_sel: u8,
        draw_arrow: u8,
        stay_open: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let opened: u8 = unsafe { ::core::mem::transmute(opened) };
            opened as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let force_sel: u8 = unsafe { ::core::mem::transmute(force_sel) };
            force_sel as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let draw_arrow: u8 = unsafe { ::core::mem::transmute(draw_arrow) };
            draw_arrow as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let stay_open: u8 = unsafe { ::core::mem::transmute(stay_open) };
            stay_open as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_DDLIST_STYLE_BG: _bindgen_ty_56 = 0;
pub const LV_DDLIST_STYLE_SEL: _bindgen_ty_56 = 1;
pub const LV_DDLIST_STYLE_SB: _bindgen_ty_56 = 2;
pub type _bindgen_ty_56 = u32;
pub type lv_ddlist_style_t = u8;
extern "C" {
    #[doc = " GLOBAL PROTOTYPES"]
    #[doc = " Create a drop down list objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new drop down list"]
    #[doc = " @param copy pointer to a drop down list object, if not NULL then the new object will be copied"]
    #[doc = " from it"]
    #[doc = " @return pointer to the created drop down list"]
    pub fn lv_ddlist_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set the options in a drop down list from a string"]
    #[doc = " @param ddlist pointer to drop down list object"]
    #[doc = " @param options a string with '\\n' separated options. E.g. \"One\\nTwo\\nThree\""]
    pub fn lv_ddlist_set_options(ddlist: *mut lv_obj_t, options: *const cty::c_char);
}
extern "C" {
    #[doc = " Set the selected option"]
    #[doc = " @param ddlist pointer to drop down list object"]
    #[doc = " @param sel_opt id of the selected option (0 ... number of option - 1);"]
    pub fn lv_ddlist_set_selected(ddlist: *mut lv_obj_t, sel_opt: u16);
}
extern "C" {
    #[doc = " Set a fix height for the drop down list"]
    #[doc = " If 0 then the opened ddlist will be auto. sized else the set height will be applied."]
    #[doc = " @param ddlist pointer to a drop down list"]
    #[doc = " @param h the height when the list is opened (0: auto size)"]
    pub fn lv_ddlist_set_fix_height(ddlist: *mut lv_obj_t, h: lv_coord_t);
}
extern "C" {
    #[doc = " Set a fix width for the drop down list"]
    #[doc = " @param ddlist pointer to a drop down list"]
    #[doc = " @param w the width when the list is opened (0: auto size)"]
    pub fn lv_ddlist_set_fix_width(ddlist: *mut lv_obj_t, w: lv_coord_t);
}
extern "C" {
    #[doc = " Set arrow draw in a drop down list"]
    #[doc = " @param ddlist pointer to drop down list object"]
    #[doc = " @param en enable/disable a arrow draw. E.g. \"true\" for draw."]
    pub fn lv_ddlist_set_draw_arrow(ddlist: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Leave the list opened when a new value is selected"]
    #[doc = " @param ddlist pointer to drop down list object"]
    #[doc = " @param en enable/disable \"stay open\" feature"]
    pub fn lv_ddlist_set_stay_open(ddlist: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Set a style of a drop down list"]
    #[doc = " @param ddlist pointer to a drop down list object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_ddlist_set_style(
        ddlist: *mut lv_obj_t,
        type_: lv_ddlist_style_t,
        style: *const lv_style_t,
    );
}
extern "C" {
    #[doc = " Set the alignment of the labels in a drop down list"]
    #[doc = " @param ddlist pointer to a drop down list object"]
    #[doc = " @param align alignment of labels"]
    pub fn lv_ddlist_set_align(ddlist: *mut lv_obj_t, align: lv_label_align_t);
}
extern "C" {
    #[doc = " Get the options of a drop down list"]
    #[doc = " @param ddlist pointer to drop down list object"]
    #[doc = " @return the options separated by '\\n'-s (E.g. \"Option1\\nOption2\\nOption3\")"]
    pub fn lv_ddlist_get_options(ddlist: *const lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Get the selected option"]
    #[doc = " @param ddlist pointer to drop down list object"]
    #[doc = " @return id of the selected option (0 ... number of option - 1);"]
    pub fn lv_ddlist_get_selected(ddlist: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get the current selected option as a string"]
    #[doc = " @param ddlist pointer to ddlist object"]
    #[doc = " @param buf pointer to an array to store the string"]
    #[doc = " @param buf_size size of `buf` in bytes. 0: to ignore it."]
    pub fn lv_ddlist_get_selected_str(
        ddlist: *const lv_obj_t,
        buf: *mut cty::c_char,
        buf_size: u16,
    );
}
extern "C" {
    #[doc = " Get the fix height value."]
    #[doc = " @param ddlist pointer to a drop down list object"]
    #[doc = " @return the height if the ddlist is opened (0: auto size)"]
    pub fn lv_ddlist_get_fix_height(ddlist: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get arrow draw in a drop down list"]
    #[doc = " @param ddlist pointer to drop down list object"]
    pub fn lv_ddlist_get_draw_arrow(ddlist: *mut lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get whether the drop down list stay open after selecting a  value or not"]
    #[doc = " @param ddlist pointer to drop down list object"]
    pub fn lv_ddlist_get_stay_open(ddlist: *mut lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get a style of a drop down list"]
    #[doc = " @param ddlist pointer to a drop down list object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to a style"]
    pub fn lv_ddlist_get_style(
        ddlist: *const lv_obj_t,
        type_: lv_ddlist_style_t,
    ) -> *const lv_style_t;
}
extern "C" {
    #[doc = " Get the alignment of the labels in a drop down list"]
    #[doc = " @param ddlist pointer to a drop down list object"]
    #[doc = " @return alignment of labels"]
    pub fn lv_ddlist_get_align(ddlist: *const lv_obj_t) -> lv_label_align_t;
}
extern "C" {
    #[doc = " Open the drop down list with or without animation"]
    #[doc = " @param ddlist pointer to drop down list object"]
    #[doc = " @param anim_en LV_ANIM_ON: use animation; LV_ANOM_OFF: not use animations"]
    pub fn lv_ddlist_open(ddlist: *mut lv_obj_t, anim: lv_anim_enable_t);
}
extern "C" {
    #[doc = " Close (Collapse) the drop down list"]
    #[doc = " @param ddlist pointer to drop down list object"]
    #[doc = " @param anim_en LV_ANIM_ON: use animation; LV_ANOM_OFF: not use animations"]
    pub fn lv_ddlist_close(ddlist: *mut lv_obj_t, anim: lv_anim_enable_t);
}
#[doc = "< Normal mode (roller ends at the end of the options)."]
pub const LV_ROLLER_MODE_NORMAL: _bindgen_ty_57 = 0;
#[doc = "< Infinite mode (roller can be scrolled forever)."]
pub const LV_ROLLER_MODE_INIFINITE: _bindgen_ty_57 = 1;
#[doc = " Roller mode."]
pub type _bindgen_ty_57 = u32;
pub type lv_roller_mode_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_roller_ext_t {
    pub ddlist: lv_ddlist_ext_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl lv_roller_ext_t {
    #[inline]
    pub fn mode(&self) -> lv_roller_mode_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mode(&mut self, val: lv_roller_mode_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mode: lv_roller_mode_t) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mode: u8 = unsafe { ::core::mem::transmute(mode) };
            mode as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_ROLLER_STYLE_BG: _bindgen_ty_58 = 0;
pub const LV_ROLLER_STYLE_SEL: _bindgen_ty_58 = 1;
pub type _bindgen_ty_58 = u32;
pub type lv_roller_style_t = u8;
extern "C" {
    #[doc = " Create a roller object"]
    #[doc = " @param par pointer to an object, it will be the parent of the new roller"]
    #[doc = " @param copy pointer to a roller object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created roller"]
    pub fn lv_roller_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set the options on a roller"]
    #[doc = " @param roller pointer to roller object"]
    #[doc = " @param options a string with '\\n' separated options. E.g. \"One\\nTwo\\nThree\""]
    #[doc = " @param mode `LV_ROLLER_MODE_NORMAL` or `LV_ROLLER_MODE_INFINITE`"]
    pub fn lv_roller_set_options(
        roller: *mut lv_obj_t,
        options: *const cty::c_char,
        mode: lv_roller_mode_t,
    );
}
extern "C" {
    #[doc = " Set the align of the roller's options (left, right or center[default])"]
    #[doc = " @param roller - pointer to a roller object"]
    #[doc = " @param align - one of lv_label_align_t values (left, right, center)"]
    pub fn lv_roller_set_align(roller: *mut lv_obj_t, align: lv_label_align_t);
}
extern "C" {
    #[doc = " Set the selected option"]
    #[doc = " @param roller pointer to a roller object"]
    #[doc = " @param sel_opt id of the selected option (0 ... number of option - 1);"]
    #[doc = " @param anim LV_ANOM_ON: set with animation; LV_ANIM_OFF set immediately"]
    pub fn lv_roller_set_selected(roller: *mut lv_obj_t, sel_opt: u16, anim: lv_anim_enable_t);
}
extern "C" {
    #[doc = " Set the height to show the given number of rows (options)"]
    #[doc = " @param roller pointer to a roller object"]
    #[doc = " @param row_cnt number of desired visible rows"]
    pub fn lv_roller_set_visible_row_count(roller: *mut lv_obj_t, row_cnt: u8);
}
extern "C" {
    #[doc = " Set a style of a roller"]
    #[doc = " @param roller pointer to a roller object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_roller_set_style(
        roller: *mut lv_obj_t,
        type_: lv_roller_style_t,
        style: *const lv_style_t,
    );
}
extern "C" {
    #[doc = " Get the id of the selected option"]
    #[doc = " @param roller pointer to a roller object"]
    #[doc = " @return id of the selected option (0 ... number of option - 1);"]
    pub fn lv_roller_get_selected(roller: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get the align attribute. Default alignment after _create is LV_LABEL_ALIGN_CENTER"]
    #[doc = " @param roller pointer to a roller object"]
    #[doc = " @return LV_LABEL_ALIGN_LEFT, LV_LABEL_ALIGN_RIGHT or LV_LABEL_ALIGN_CENTER"]
    pub fn lv_roller_get_align(roller: *const lv_obj_t) -> lv_label_align_t;
}
extern "C" {
    #[doc = " Get the auto width set attribute"]
    #[doc = " @param roller pointer to a roller object"]
    #[doc = " @return true: auto size enabled; false: manual width settings enabled"]
    pub fn lv_roller_get_hor_fit(roller: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get a style of a roller"]
    #[doc = " @param roller pointer to a roller object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to a style"]
    pub fn lv_roller_get_style(
        roller: *const lv_obj_t,
        type_: lv_roller_style_t,
    ) -> *const lv_style_t;
}
#[doc = "< No cursor"]
pub const LV_CURSOR_NONE: _bindgen_ty_59 = 0;
#[doc = "< Vertical line"]
pub const LV_CURSOR_LINE: _bindgen_ty_59 = 1;
#[doc = "< Rectangle"]
pub const LV_CURSOR_BLOCK: _bindgen_ty_59 = 2;
#[doc = "< Outline around character"]
pub const LV_CURSOR_OUTLINE: _bindgen_ty_59 = 3;
#[doc = "< Horizontal line under character"]
pub const LV_CURSOR_UNDERLINE: _bindgen_ty_59 = 4;
#[doc = "< This flag can be ORed to any of the other values to temporarily hide the cursor"]
pub const LV_CURSOR_HIDDEN: _bindgen_ty_59 = 8;
#[doc = " Style of text area's cursor."]
pub type _bindgen_ty_59 = u32;
pub type lv_cursor_type_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_ta_ext_t {
    pub page: lv_page_ext_t,
    pub label: *mut lv_obj_t,
    pub placeholder: *mut lv_obj_t,
    pub pwd_tmp: *mut cty::c_char,
    pub accapted_chars: *const cty::c_char,
    pub max_length: u16,
    pub pwd_show_time: u16,
    pub cursor: lv_ta_ext_t__bindgen_ty_1,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_ta_ext_t__bindgen_ty_1 {
    pub style: *const lv_style_t,
    pub valid_x: lv_coord_t,
    pub pos: u16,
    pub blink_time: u16,
    pub area: lv_area_t,
    pub txt_byte_pos: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl lv_ta_ext_t__bindgen_ty_1 {
    #[inline]
    pub fn type_(&self) -> lv_cursor_type_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: lv_cursor_type_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn state(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn click_pos(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_click_pos(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: lv_cursor_type_t,
        state: u8,
        click_pos: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let type_: u8 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let state: u8 = unsafe { ::core::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let click_pos: u8 = unsafe { ::core::mem::transmute(click_pos) };
            click_pos as u64
        });
        __bindgen_bitfield_unit
    }
}
impl lv_ta_ext_t {
    #[inline]
    pub fn pwd_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pwd_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn one_line(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_one_line(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(pwd_mode: u8, one_line: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pwd_mode: u8 = unsafe { ::core::mem::transmute(pwd_mode) };
            pwd_mode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let one_line: u8 = unsafe { ::core::mem::transmute(one_line) };
            one_line as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< Text area background style"]
pub const LV_TA_STYLE_BG: _bindgen_ty_60 = 0;
#[doc = "< Scrollbar style"]
pub const LV_TA_STYLE_SB: _bindgen_ty_60 = 1;
#[doc = "< Cursor style"]
pub const LV_TA_STYLE_CURSOR: _bindgen_ty_60 = 2;
#[doc = "< Edge flash style"]
pub const LV_TA_STYLE_EDGE_FLASH: _bindgen_ty_60 = 3;
#[doc = "< Placeholder style"]
pub const LV_TA_STYLE_PLACEHOLDER: _bindgen_ty_60 = 4;
#[doc = " Possible text areas tyles."]
pub type _bindgen_ty_60 = u32;
pub type lv_ta_style_t = u8;
extern "C" {
    #[doc = " Create a text area objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new text area"]
    #[doc = " @param copy pointer to a text area object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created text area"]
    pub fn lv_ta_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Insert a character to the current cursor position."]
    #[doc = " To add a wide char, e.g. '' use `lv_txt_encoded_conv_wc('')`"]
    #[doc = " @param ta pointer to a text area object"]
    #[doc = " @param c a character (e.g. 'a')"]
    pub fn lv_ta_add_char(ta: *mut lv_obj_t, c: u32);
}
extern "C" {
    #[doc = " Insert a text to the current cursor position"]
    #[doc = " @param ta pointer to a text area object"]
    #[doc = " @param txt a '\\0' terminated string to insert"]
    pub fn lv_ta_add_text(ta: *mut lv_obj_t, txt: *const cty::c_char);
}
extern "C" {
    #[doc = " Delete a the left character from the current cursor position"]
    #[doc = " @param ta pointer to a text area object"]
    pub fn lv_ta_del_char(ta: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Delete the right character from the current cursor position"]
    #[doc = " @param ta pointer to a text area object"]
    pub fn lv_ta_del_char_forward(ta: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Set the text of a text area"]
    #[doc = " @param ta pointer to a text area"]
    #[doc = " @param txt pointer to the text"]
    pub fn lv_ta_set_text(ta: *mut lv_obj_t, txt: *const cty::c_char);
}
extern "C" {
    #[doc = " Set the placeholder text of a text area"]
    #[doc = " @param ta pointer to a text area"]
    #[doc = " @param txt pointer to the text"]
    pub fn lv_ta_set_placeholder_text(ta: *mut lv_obj_t, txt: *const cty::c_char);
}
extern "C" {
    #[doc = " Set the cursor position"]
    #[doc = " @param obj pointer to a text area object"]
    #[doc = " @param pos the new cursor position in character index"]
    #[doc = "             < 0 : index from the end of the text"]
    #[doc = "             LV_TA_CURSOR_LAST: go after the last character"]
    pub fn lv_ta_set_cursor_pos(ta: *mut lv_obj_t, pos: i16);
}
extern "C" {
    #[doc = " Set the cursor type."]
    #[doc = " @param ta pointer to a text area object"]
    #[doc = " @param cur_type: element of 'lv_cursor_type_t'"]
    pub fn lv_ta_set_cursor_type(ta: *mut lv_obj_t, cur_type: lv_cursor_type_t);
}
extern "C" {
    #[doc = " Enable/Disable the positioning of the the cursor by clicking the text on the text area."]
    #[doc = " @param ta pointer to a text area object"]
    #[doc = " @param en true: enable click positions; false: disable"]
    pub fn lv_ta_set_cursor_click_pos(ta: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Enable/Disable password mode"]
    #[doc = " @param ta pointer to a text area object"]
    #[doc = " @param en true: enable, false: disable"]
    pub fn lv_ta_set_pwd_mode(ta: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Configure the text area to one line or back to normal"]
    #[doc = " @param ta pointer to a Text area object"]
    #[doc = " @param en true: one line, false: normal"]
    pub fn lv_ta_set_one_line(ta: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Set the alignment of the text area."]
    #[doc = " In one line mode the text can be scrolled only with `LV_LABEL_ALIGN_LEFT`."]
    #[doc = " This function should be called if the size of text area changes."]
    #[doc = " @param ta pointer to a text are object"]
    #[doc = " @param align the desired alignment from `lv_label_align_t`. (LV_LABEL_ALIGN_LEFT/CENTER/RIGHT)"]
    pub fn lv_ta_set_text_align(ta: *mut lv_obj_t, align: lv_label_align_t);
}
extern "C" {
    #[doc = " Set a list of characters. Only these characters will be accepted by the text area"]
    #[doc = " @param ta pointer to  Text Area"]
    #[doc = " @param list list of characters. Only the pointer is saved. E.g. \"+-.,0123456789\""]
    pub fn lv_ta_set_accepted_chars(ta: *mut lv_obj_t, list: *const cty::c_char);
}
extern "C" {
    #[doc = " Set max length of a Text Area."]
    #[doc = " @param ta pointer to  Text Area"]
    #[doc = " @param num the maximal number of characters can be added (`lv_ta_set_text` ignores it)"]
    pub fn lv_ta_set_max_length(ta: *mut lv_obj_t, num: u16);
}
extern "C" {
    #[doc = " In `LV_EVENT_INSERT` the text which planned to be inserted can be replaced by an other text."]
    #[doc = " It can be used to add automatic formatting to the text area."]
    #[doc = " @param ta pointer to a text area."]
    #[doc = " @param txt pointer to a new string to insert. If `\"\"` no text will be added."]
    #[doc = "            The variable must be live after the `event_cb` exists. (Should be `global` or"]
    #[doc = " `static`)"]
    pub fn lv_ta_set_insert_replace(ta: *mut lv_obj_t, txt: *const cty::c_char);
}
extern "C" {
    #[doc = " Set a style of a text area"]
    #[doc = " @param ta pointer to a text area object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_ta_set_style(ta: *mut lv_obj_t, type_: lv_ta_style_t, style: *const lv_style_t);
}
extern "C" {
    #[doc = " Enable/disable selection mode."]
    #[doc = " @param ta pointer to a text area object"]
    #[doc = " @param en true or false to enable/disable selection mode"]
    pub fn lv_ta_set_text_sel(ta: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Set how long show the password before changing it to '*'"]
    #[doc = " @param ta pointer to Text area"]
    #[doc = " @param time show time in milliseconds. 0: hide immediately."]
    pub fn lv_ta_set_pwd_show_time(ta: *mut lv_obj_t, time: u16);
}
extern "C" {
    #[doc = " Set cursor blink animation time"]
    #[doc = " @param ta pointer to Text area"]
    #[doc = " @param time blink period. 0: disable blinking"]
    pub fn lv_ta_set_cursor_blink_time(ta: *mut lv_obj_t, time: u16);
}
extern "C" {
    #[doc = " Get the text of a text area. In password mode it gives the real text (not '*'s)."]
    #[doc = " @param ta pointer to a text area object"]
    #[doc = " @return pointer to the text"]
    pub fn lv_ta_get_text(ta: *const lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Get the placeholder text of a text area"]
    #[doc = " @param ta pointer to a text area object"]
    #[doc = " @return pointer to the text"]
    pub fn lv_ta_get_placeholder_text(ta: *mut lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Get the label of a text area"]
    #[doc = " @param ta pointer to a text area object"]
    #[doc = " @return pointer to the label object"]
    pub fn lv_ta_get_label(ta: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Get the current cursor position in character index"]
    #[doc = " @param ta pointer to a text area object"]
    #[doc = " @return the cursor position"]
    pub fn lv_ta_get_cursor_pos(ta: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get the current cursor type."]
    #[doc = " @param ta pointer to a text area object"]
    #[doc = " @return element of 'lv_cursor_type_t'"]
    pub fn lv_ta_get_cursor_type(ta: *const lv_obj_t) -> lv_cursor_type_t;
}
extern "C" {
    #[doc = " Get whether the cursor click positioning is enabled or not."]
    #[doc = " @param ta pointer to a text area object"]
    #[doc = " @return true: enable click positions; false: disable"]
    pub fn lv_ta_get_cursor_click_pos(ta: *mut lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get the password mode attribute"]
    #[doc = " @param ta pointer to a text area object"]
    #[doc = " @return true: password mode is enabled, false: disabled"]
    pub fn lv_ta_get_pwd_mode(ta: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get the one line configuration attribute"]
    #[doc = " @param ta pointer to a text area object"]
    #[doc = " @return true: one line configuration is enabled, false: disabled"]
    pub fn lv_ta_get_one_line(ta: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get a list of accepted characters."]
    #[doc = " @param ta pointer to  Text Area"]
    #[doc = " @return list of accented characters."]
    pub fn lv_ta_get_accepted_chars(ta: *mut lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Set max length of a Text Area."]
    #[doc = " @param ta pointer to  Text Area"]
    #[doc = " @return the maximal number of characters to be add"]
    pub fn lv_ta_get_max_length(ta: *mut lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get a style of a text area"]
    #[doc = " @param ta pointer to a text area object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to a style"]
    pub fn lv_ta_get_style(ta: *const lv_obj_t, type_: lv_ta_style_t) -> *const lv_style_t;
}
extern "C" {
    #[doc = " Find whether text is selected or not."]
    #[doc = " @param ta Text area object"]
    #[doc = " @return whether text is selected or not"]
    pub fn lv_ta_text_is_selected(ta: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Find whether selection mode is enabled."]
    #[doc = " @param ta pointer to a text area object"]
    #[doc = " @return true: selection mode is enabled, false: disabled"]
    pub fn lv_ta_get_text_sel_en(ta: *mut lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Set how long show the password before changing it to '*'"]
    #[doc = " @param ta pointer to Text area"]
    #[doc = " @return show time in milliseconds. 0: hide immediately."]
    pub fn lv_ta_get_pwd_show_time(ta: *mut lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Set cursor blink animation time"]
    #[doc = " @param ta pointer to Text area"]
    #[doc = " @return time blink period. 0: disable blinking"]
    pub fn lv_ta_get_cursor_blink_time(ta: *mut lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Clear the selection on the text area."]
    #[doc = " @param ta Text area object"]
    pub fn lv_ta_clear_selection(ta: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Move the cursor one character right"]
    #[doc = " @param ta pointer to a text area object"]
    pub fn lv_ta_cursor_right(ta: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Move the cursor one character left"]
    #[doc = " @param ta pointer to a text area object"]
    pub fn lv_ta_cursor_left(ta: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Move the cursor one line down"]
    #[doc = " @param ta pointer to a text area object"]
    pub fn lv_ta_cursor_down(ta: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Move the cursor one line up"]
    #[doc = " @param ta pointer to a text area object"]
    pub fn lv_ta_cursor_up(ta: *mut lv_obj_t);
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_canvas_ext_t {
    pub img: lv_img_ext_t,
    pub dsc: lv_img_dsc_t,
}
pub const LV_CANVAS_STYLE_MAIN: _bindgen_ty_61 = 0;
pub type _bindgen_ty_61 = u32;
pub type lv_canvas_style_t = u8;
extern "C" {
    #[doc = " Create a canvas object"]
    #[doc = " @param par pointer to an object, it will be the parent of the new canvas"]
    #[doc = " @param copy pointer to a canvas object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created canvas"]
    pub fn lv_canvas_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set a buffer for the canvas."]
    #[doc = " @param buf a buffer where the content of the canvas will be."]
    #[doc = " The required size is (lv_img_color_format_get_px_size(cf) * w * h) / 8)"]
    #[doc = " It can be allocated with `lv_mem_alloc()` or"]
    #[doc = " it can be statically allocated array (e.g. static lv_color_t buf[100*50]) or"]
    #[doc = " it can be an address in RAM or external SRAM"]
    #[doc = " @param canvas pointer to a canvas object"]
    #[doc = " @param w width of the canvas"]
    #[doc = " @param h height of the canvas"]
    #[doc = " @param cf color format. `LV_IMG_CF_...`"]
    pub fn lv_canvas_set_buffer(
        canvas: *mut lv_obj_t,
        buf: *mut cty::c_void,
        w: lv_coord_t,
        h: lv_coord_t,
        cf: lv_img_cf_t,
    );
}
extern "C" {
    #[doc = " Set the color of a pixel on the canvas"]
    #[doc = " @param canvas"]
    #[doc = " @param x x coordinate of the point to set"]
    #[doc = " @param y x coordinate of the point to set"]
    #[doc = " @param c color of the point"]
    pub fn lv_canvas_set_px(canvas: *mut lv_obj_t, x: lv_coord_t, y: lv_coord_t, c: lv_color_t);
}
extern "C" {
    #[doc = " Set the palette color of a canvas with index format. Valid only for `LV_IMG_CF_INDEXED1/2/4/8`"]
    #[doc = " @param canvas pointer to canvas object"]
    #[doc = " @param id the palette color to set:"]
    #[doc = "   - for `LV_IMG_CF_INDEXED1`: 0..1"]
    #[doc = "   - for `LV_IMG_CF_INDEXED2`: 0..3"]
    #[doc = "   - for `LV_IMG_CF_INDEXED4`: 0..15"]
    #[doc = "   - for `LV_IMG_CF_INDEXED8`: 0..255"]
    #[doc = " @param c the color to set"]
    pub fn lv_canvas_set_palette(canvas: *mut lv_obj_t, id: u8, c: lv_color_t);
}
extern "C" {
    #[doc = " Set a style of a canvas."]
    #[doc = " @param canvas pointer to canvas object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_canvas_set_style(
        canvas: *mut lv_obj_t,
        type_: lv_canvas_style_t,
        style: *const lv_style_t,
    );
}
extern "C" {
    #[doc = " Get the color of a pixel on the canvas"]
    #[doc = " @param canvas"]
    #[doc = " @param x x coordinate of the point to set"]
    #[doc = " @param y x coordinate of the point to set"]
    #[doc = " @return color of the point"]
    pub fn lv_canvas_get_px(canvas: *mut lv_obj_t, x: lv_coord_t, y: lv_coord_t) -> lv_color_t;
}
extern "C" {
    #[doc = " Get the image of the canvas as a pointer to an `lv_img_dsc_t` variable."]
    #[doc = " @param canvas pointer to a canvas object"]
    #[doc = " @return pointer to the image descriptor."]
    pub fn lv_canvas_get_img(canvas: *mut lv_obj_t) -> *mut lv_img_dsc_t;
}
extern "C" {
    #[doc = " Get style of a canvas."]
    #[doc = " @param canvas pointer to canvas object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to the style"]
    pub fn lv_canvas_get_style(
        canvas: *const lv_obj_t,
        type_: lv_canvas_style_t,
    ) -> *const lv_style_t;
}
extern "C" {
    #[doc = " Copy a buffer to the canvas"]
    #[doc = " @param canvas pointer to a canvas object"]
    #[doc = " @param to_copy buffer to copy. The color format has to match with the canvas's buffer color"]
    #[doc = " format"]
    #[doc = " @param x left side of the destination position"]
    #[doc = " @param y top side of the destination position"]
    #[doc = " @param w width of the buffer to copy"]
    #[doc = " @param h height of the buffer to copy"]
    pub fn lv_canvas_copy_buf(
        canvas: *mut lv_obj_t,
        to_copy: *const cty::c_void,
        x: lv_coord_t,
        y: lv_coord_t,
        w: lv_coord_t,
        h: lv_coord_t,
    );
}
extern "C" {
    #[doc = " Rotate and image and store the result on a canvas."]
    #[doc = " @param canvas pointer to a canvas object"]
    #[doc = " @param img pointer to an image descriptor."]
    #[doc = "             Can be the image descriptor of an other canvas too (`lv_canvas_get_img()`)."]
    #[doc = " @param angle the angle of rotation (0..360);"]
    #[doc = " @param offset_x offset X to tell where to put the result data on destination canvas"]
    #[doc = " @param offset_y offset X to tell where to put the result data on destination canvas"]
    #[doc = " @param pivot_x pivot X of rotation. Relative to the source canvas"]
    #[doc = "                Set to `source width / 2` to rotate around the center"]
    #[doc = " @param pivot_y pivot Y of rotation. Relative to the source canvas"]
    #[doc = "                Set to `source height / 2` to rotate around the center"]
    pub fn lv_canvas_rotate(
        canvas: *mut lv_obj_t,
        img: *mut lv_img_dsc_t,
        angle: i16,
        offset_x: lv_coord_t,
        offset_y: lv_coord_t,
        pivot_x: i32,
        pivot_y: i32,
    );
}
extern "C" {
    #[doc = " Fill the canvas with color"]
    #[doc = " @param canvas pointer to a canvas"]
    #[doc = " @param color the background color"]
    pub fn lv_canvas_fill_bg(canvas: *mut lv_obj_t, color: lv_color_t);
}
extern "C" {
    #[doc = " Draw a rectangle on the canvas"]
    #[doc = " @param canvas pointer to a canvas object"]
    #[doc = " @param x left coordinate of the rectangle"]
    #[doc = " @param y top coordinate of the rectangle"]
    #[doc = " @param w width of the rectangle"]
    #[doc = " @param h height of the rectangle"]
    #[doc = " @param style style of the rectangle (`body` properties are used except `padding`)"]
    pub fn lv_canvas_draw_rect(
        canvas: *mut lv_obj_t,
        x: lv_coord_t,
        y: lv_coord_t,
        w: lv_coord_t,
        h: lv_coord_t,
        style: *const lv_style_t,
    );
}
extern "C" {
    #[doc = " Draw a text on the canvas."]
    #[doc = " @param canvas pointer to a canvas object"]
    #[doc = " @param x left coordinate of the text"]
    #[doc = " @param y top coordinate of the text"]
    #[doc = " @param max_w max width of the text. The text will be wrapped to fit into this size"]
    #[doc = " @param style style of the text (`text` properties are used)"]
    #[doc = " @param txt text to display"]
    #[doc = " @param align align of the text (`LV_LABEL_ALIGN_LEFT/RIGHT/CENTER`)"]
    pub fn lv_canvas_draw_text(
        canvas: *mut lv_obj_t,
        x: lv_coord_t,
        y: lv_coord_t,
        max_w: lv_coord_t,
        style: *const lv_style_t,
        txt: *const cty::c_char,
        align: lv_label_align_t,
    );
}
extern "C" {
    #[doc = " Draw an image on the canvas"]
    #[doc = " @param canvas pointer to a canvas object"]
    #[doc = " @param src image source. Can be a pointer an `lv_img_dsc_t` variable or a path an image."]
    #[doc = " @param style style of the image (`image` properties are used)"]
    pub fn lv_canvas_draw_img(
        canvas: *mut lv_obj_t,
        x: lv_coord_t,
        y: lv_coord_t,
        src: *const cty::c_void,
        style: *const lv_style_t,
    );
}
extern "C" {
    #[doc = " Draw a line on the canvas"]
    #[doc = " @param canvas pointer to a canvas object"]
    #[doc = " @param points point of the line"]
    #[doc = " @param point_cnt number of points"]
    #[doc = " @param style style of the line (`line` properties are used)"]
    pub fn lv_canvas_draw_line(
        canvas: *mut lv_obj_t,
        points: *const lv_point_t,
        point_cnt: u32,
        style: *const lv_style_t,
    );
}
extern "C" {
    #[doc = " Draw a polygon on the canvas"]
    #[doc = " @param canvas pointer to a canvas object"]
    #[doc = " @param points point of the polygon"]
    #[doc = " @param point_cnt number of points"]
    #[doc = " @param style style of the polygon (`body.main_color` and `body.opa` is used)"]
    pub fn lv_canvas_draw_polygon(
        canvas: *mut lv_obj_t,
        points: *const lv_point_t,
        point_cnt: u32,
        style: *const lv_style_t,
    );
}
extern "C" {
    #[doc = " Draw an arc on the canvas"]
    #[doc = " @param canvas pointer to a canvas object"]
    #[doc = " @param x origo x  of the arc"]
    #[doc = " @param y origo y of the arc"]
    #[doc = " @param r radius of the arc"]
    #[doc = " @param start_angle start angle in degrees"]
    #[doc = " @param end_angle end angle in degrees"]
    #[doc = " @param style style of the polygon (`body.main_color` and `body.opa` is used)"]
    pub fn lv_canvas_draw_arc(
        canvas: *mut lv_obj_t,
        x: lv_coord_t,
        y: lv_coord_t,
        r: lv_coord_t,
        start_angle: i32,
        end_angle: i32,
        style: *const lv_style_t,
    );
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_win_ext_t {
    pub page: *mut lv_obj_t,
    pub header: *mut lv_obj_t,
    pub title: *mut lv_obj_t,
    pub style_btn_rel: *const lv_style_t,
    pub style_btn_pr: *const lv_style_t,
    pub btn_size: lv_coord_t,
}
#[doc = "< Window object background style."]
pub const LV_WIN_STYLE_BG: _bindgen_ty_62 = 0;
#[doc = "< Window content style."]
pub const LV_WIN_STYLE_CONTENT: _bindgen_ty_62 = 1;
#[doc = "< Window scrollbar style."]
pub const LV_WIN_STYLE_SB: _bindgen_ty_62 = 2;
#[doc = "< Window titlebar background style."]
pub const LV_WIN_STYLE_HEADER: _bindgen_ty_62 = 3;
#[doc = "< Same meaning as ordinary button styles."]
pub const LV_WIN_STYLE_BTN_REL: _bindgen_ty_62 = 4;
pub const LV_WIN_STYLE_BTN_PR: _bindgen_ty_62 = 5;
#[doc = " Window styles."]
pub type _bindgen_ty_62 = u32;
pub type lv_win_style_t = u8;
extern "C" {
    #[doc = " Create a window objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new window"]
    #[doc = " @param copy pointer to a window object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created window"]
    pub fn lv_win_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Delete all children of the scrl object, without deleting scrl child."]
    #[doc = " @param win pointer to an object"]
    pub fn lv_win_clean(win: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Add control button to the header of the window"]
    #[doc = " @param win pointer to a window object"]
    #[doc = " @param img_src an image source ('lv_img_t' variable, path to file or a symbol)"]
    #[doc = " @return pointer to the created button object"]
    pub fn lv_win_add_btn(win: *mut lv_obj_t, img_src: *const cty::c_void) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Can be assigned to a window control button to close the window"]
    #[doc = " @param btn pointer to the control button on teh widows header"]
    #[doc = " @param evet the event type"]
    pub fn lv_win_close_event_cb(btn: *mut lv_obj_t, event: lv_event_t);
}
extern "C" {
    #[doc = " Set the title of a window"]
    #[doc = " @param win pointer to a window object"]
    #[doc = " @param title string of the new title"]
    pub fn lv_win_set_title(win: *mut lv_obj_t, title: *const cty::c_char);
}
extern "C" {
    #[doc = " Set the control button size of a window"]
    #[doc = " @param win pointer to a window object"]
    #[doc = " @return control button size"]
    pub fn lv_win_set_btn_size(win: *mut lv_obj_t, size: lv_coord_t);
}
extern "C" {
    #[doc = " Set the size of the content area."]
    #[doc = " @param win pointer to a window object"]
    #[doc = " @param w width"]
    #[doc = " @param h height (the window will be higher with the height of the header)"]
    pub fn lv_win_set_content_size(win: *mut lv_obj_t, w: lv_coord_t, h: lv_coord_t);
}
extern "C" {
    #[doc = " Set the layout of the window"]
    #[doc = " @param win pointer to a window object"]
    #[doc = " @param layout the layout from 'lv_layout_t'"]
    pub fn lv_win_set_layout(win: *mut lv_obj_t, layout: lv_layout_t);
}
extern "C" {
    #[doc = " Set the scroll bar mode of a window"]
    #[doc = " @param win pointer to a window object"]
    #[doc = " @param sb_mode the new scroll bar mode from  'lv_sb_mode_t'"]
    pub fn lv_win_set_sb_mode(win: *mut lv_obj_t, sb_mode: lv_sb_mode_t);
}
extern "C" {
    #[doc = " Set focus animation duration on `lv_win_focus()`"]
    #[doc = " @param win pointer to a window object"]
    #[doc = " @param anim_time duration of animation [ms]"]
    pub fn lv_win_set_anim_time(win: *mut lv_obj_t, anim_time: u16);
}
extern "C" {
    #[doc = " Set a style of a window"]
    #[doc = " @param win pointer to a window object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_win_set_style(win: *mut lv_obj_t, type_: lv_win_style_t, style: *const lv_style_t);
}
extern "C" {
    #[doc = " Set drag status of a window. If set to 'true' window can be dragged like on a PC."]
    #[doc = " @param win pointer to a window object"]
    #[doc = " @param en whether dragging is enabled"]
    pub fn lv_win_set_drag(win: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Get the title of a window"]
    #[doc = " @param win pointer to a window object"]
    #[doc = " @return title string of the window"]
    pub fn lv_win_get_title(win: *const lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Get the content holder object of window (`lv_page`) to allow additional customization"]
    #[doc = " @param win pointer to a window object"]
    #[doc = " @return the Page object where the window's content is"]
    pub fn lv_win_get_content(win: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Get the control button size of a window"]
    #[doc = " @param win pointer to a window object"]
    #[doc = " @return control button size"]
    pub fn lv_win_get_btn_size(win: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get the pointer of a widow from one of  its control button."]
    #[doc = " It is useful in the action of the control buttons where only button is known."]
    #[doc = " @param ctrl_btn pointer to a control button of a window"]
    #[doc = " @return pointer to the window of 'ctrl_btn'"]
    pub fn lv_win_get_from_btn(ctrl_btn: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Get the layout of a window"]
    #[doc = " @param win pointer to a window object"]
    #[doc = " @return the layout of the window (from 'lv_layout_t')"]
    pub fn lv_win_get_layout(win: *mut lv_obj_t) -> lv_layout_t;
}
extern "C" {
    #[doc = " Get the scroll bar mode of a window"]
    #[doc = " @param win pointer to a window object"]
    #[doc = " @return the scroll bar mode of the window (from 'lv_sb_mode_t')"]
    pub fn lv_win_get_sb_mode(win: *mut lv_obj_t) -> lv_sb_mode_t;
}
extern "C" {
    #[doc = " Get focus animation duration"]
    #[doc = " @param win pointer to a window object"]
    #[doc = " @return duration of animation [ms]"]
    pub fn lv_win_get_anim_time(win: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get width of the content area (page scrollable) of the window"]
    #[doc = " @param win pointer to a window object"]
    #[doc = " @return the width of the content area"]
    pub fn lv_win_get_width(win: *mut lv_obj_t) -> lv_coord_t;
}
extern "C" {
    #[doc = " Get a style of a window"]
    #[doc = " @param win pointer to a button object"]
    #[doc = " @param type which style window be get"]
    #[doc = " @return style pointer to a style"]
    pub fn lv_win_get_style(win: *const lv_obj_t, type_: lv_win_style_t) -> *const lv_style_t;
}
extern "C" {
    #[doc = " Focus on an object. It ensures that the object will be visible in the window."]
    #[doc = " @param win pointer to a window object"]
    #[doc = " @param obj pointer to an object to focus (must be in the window)"]
    #[doc = " @param anim_en LV_ANIM_ON focus with an animation; LV_ANIM_OFF focus without animation"]
    pub fn lv_win_focus(win: *mut lv_obj_t, obj: *mut lv_obj_t, anim_en: lv_anim_enable_t);
}
pub const LV_TABVIEW_BTNS_POS_TOP: _bindgen_ty_63 = 0;
pub const LV_TABVIEW_BTNS_POS_BOTTOM: _bindgen_ty_63 = 1;
pub const LV_TABVIEW_BTNS_POS_LEFT: _bindgen_ty_63 = 2;
pub const LV_TABVIEW_BTNS_POS_RIGHT: _bindgen_ty_63 = 3;
#[doc = " Position of tabview buttons."]
pub type _bindgen_ty_63 = u32;
pub type lv_tabview_btns_pos_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_tabview_ext_t {
    pub btns: *mut lv_obj_t,
    pub indic: *mut lv_obj_t,
    pub content: *mut lv_obj_t,
    pub tab_name_ptr: *mut *const cty::c_char,
    pub point_last: lv_point_t,
    pub tab_cur: u16,
    pub tab_cnt: u16,
    pub anim_time: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 5usize],
}
impl lv_tabview_ext_t {
    #[inline]
    pub fn slide_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slide_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn draging(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_draging(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_hor(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_hor(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scroll_ver(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scroll_ver(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn btns_hide(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_btns_hide(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn btns_pos(&self) -> lv_tabview_btns_pos_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_btns_pos(&mut self, val: lv_tabview_btns_pos_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slide_enable: u8,
        draging: u8,
        drag_hor: u8,
        scroll_ver: u8,
        btns_hide: u8,
        btns_pos: lv_tabview_btns_pos_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slide_enable: u8 = unsafe { ::core::mem::transmute(slide_enable) };
            slide_enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let draging: u8 = unsafe { ::core::mem::transmute(draging) };
            draging as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let drag_hor: u8 = unsafe { ::core::mem::transmute(drag_hor) };
            drag_hor as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let scroll_ver: u8 = unsafe { ::core::mem::transmute(scroll_ver) };
            scroll_ver as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let btns_hide: u8 = unsafe { ::core::mem::transmute(btns_hide) };
            btns_hide as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let btns_pos: u8 = unsafe { ::core::mem::transmute(btns_pos) };
            btns_pos as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_TABVIEW_STYLE_BG: _bindgen_ty_64 = 0;
pub const LV_TABVIEW_STYLE_INDIC: _bindgen_ty_64 = 1;
pub const LV_TABVIEW_STYLE_BTN_BG: _bindgen_ty_64 = 2;
pub const LV_TABVIEW_STYLE_BTN_REL: _bindgen_ty_64 = 3;
pub const LV_TABVIEW_STYLE_BTN_PR: _bindgen_ty_64 = 4;
pub const LV_TABVIEW_STYLE_BTN_TGL_REL: _bindgen_ty_64 = 5;
pub const LV_TABVIEW_STYLE_BTN_TGL_PR: _bindgen_ty_64 = 6;
pub type _bindgen_ty_64 = u32;
pub type lv_tabview_style_t = u8;
extern "C" {
    #[doc = " Create a Tab view object"]
    #[doc = " @param par pointer to an object, it will be the parent of the new tab"]
    #[doc = " @param copy pointer to a tab object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created tab"]
    pub fn lv_tabview_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Delete all children of the scrl object, without deleting scrl child."]
    #[doc = " @param tabview pointer to an object"]
    pub fn lv_tabview_clean(tabview: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Add a new tab with the given name"]
    #[doc = " @param tabview pointer to Tab view object where to ass the new tab"]
    #[doc = " @param name the text on the tab button"]
    #[doc = " @return pointer to the created page object (lv_page). You can create your content here"]
    pub fn lv_tabview_add_tab(tabview: *mut lv_obj_t, name: *const cty::c_char) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set a new tab"]
    #[doc = " @param tabview pointer to Tab view object"]
    #[doc = " @param id index of a tab to load"]
    #[doc = " @param anim LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
    pub fn lv_tabview_set_tab_act(tabview: *mut lv_obj_t, id: u16, anim: lv_anim_enable_t);
}
extern "C" {
    #[doc = " Enable horizontal sliding with touch pad"]
    #[doc = " @param tabview pointer to Tab view object"]
    #[doc = " @param en true: enable sliding; false: disable sliding"]
    pub fn lv_tabview_set_sliding(tabview: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Set the animation time of tab view when a new tab is loaded"]
    #[doc = " @param tabview pointer to Tab view object"]
    #[doc = " @param anim_time time of animation in milliseconds"]
    pub fn lv_tabview_set_anim_time(tabview: *mut lv_obj_t, anim_time: u16);
}
extern "C" {
    #[doc = " Set the style of a tab view"]
    #[doc = " @param tabview pointer to a tan view object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to the new style"]
    pub fn lv_tabview_set_style(
        tabview: *mut lv_obj_t,
        type_: lv_tabview_style_t,
        style: *const lv_style_t,
    );
}
extern "C" {
    #[doc = " Set the position of tab select buttons"]
    #[doc = " @param tabview pointer to a tab view object"]
    #[doc = " @param btns_pos which button position"]
    pub fn lv_tabview_set_btns_pos(tabview: *mut lv_obj_t, btns_pos: lv_tabview_btns_pos_t);
}
extern "C" {
    #[doc = " Set whether tab buttons are hidden"]
    #[doc = " @param tabview pointer to a tab view object"]
    #[doc = " @param en whether tab buttons are hidden"]
    pub fn lv_tabview_set_btns_hidden(tabview: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Get the index of the currently active tab"]
    #[doc = " @param tabview pointer to Tab view object"]
    #[doc = " @return the active tab index"]
    pub fn lv_tabview_get_tab_act(tabview: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get the number of tabs"]
    #[doc = " @param tabview pointer to Tab view object"]
    #[doc = " @return tab count"]
    pub fn lv_tabview_get_tab_count(tabview: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get the page (content area) of a tab"]
    #[doc = " @param tabview pointer to Tab view object"]
    #[doc = " @param id index of the tab (>= 0)"]
    #[doc = " @return pointer to page (lv_page) object"]
    pub fn lv_tabview_get_tab(tabview: *const lv_obj_t, id: u16) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Get horizontal sliding is enabled or not"]
    #[doc = " @param tabview pointer to Tab view object"]
    #[doc = " @return true: enable sliding; false: disable sliding"]
    pub fn lv_tabview_get_sliding(tabview: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get the animation time of tab view when a new tab is loaded"]
    #[doc = " @param tabview pointer to Tab view object"]
    #[doc = " @return time of animation in milliseconds"]
    pub fn lv_tabview_get_anim_time(tabview: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get a style of a tab view"]
    #[doc = " @param tabview pointer to a ab view object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to a style"]
    pub fn lv_tabview_get_style(
        tabview: *const lv_obj_t,
        type_: lv_tabview_style_t,
    ) -> *const lv_style_t;
}
extern "C" {
    #[doc = " Get position of tab select buttons"]
    #[doc = " @param tabview pointer to a ab view object"]
    pub fn lv_tabview_get_btns_pos(tabview: *const lv_obj_t) -> lv_tabview_btns_pos_t;
}
extern "C" {
    #[doc = " Get whether tab buttons are hidden"]
    #[doc = " @param tabview pointer to a tab view object"]
    #[doc = " @return whether tab buttons are hidden"]
    pub fn lv_tabview_get_btns_hidden(tabview: *const lv_obj_t) -> bool;
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_tileview_ext_t {
    pub page: lv_page_ext_t,
    pub valid_pos: *const lv_point_t,
    pub valid_pos_cnt: u16,
    pub anim_time: u16,
    pub act_id: lv_point_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl lv_tileview_ext_t {
    #[inline]
    pub fn drag_top_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_top_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_bottom_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_bottom_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_left_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_left_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_right_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_right_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_hor(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_hor(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_ver(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_ver(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        drag_top_en: u8,
        drag_bottom_en: u8,
        drag_left_en: u8,
        drag_right_en: u8,
        drag_hor: u8,
        drag_ver: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let drag_top_en: u8 = unsafe { ::core::mem::transmute(drag_top_en) };
            drag_top_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let drag_bottom_en: u8 = unsafe { ::core::mem::transmute(drag_bottom_en) };
            drag_bottom_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let drag_left_en: u8 = unsafe { ::core::mem::transmute(drag_left_en) };
            drag_left_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let drag_right_en: u8 = unsafe { ::core::mem::transmute(drag_right_en) };
            drag_right_en as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let drag_hor: u8 = unsafe { ::core::mem::transmute(drag_hor) };
            drag_hor as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let drag_ver: u8 = unsafe { ::core::mem::transmute(drag_ver) };
            drag_ver as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_TILEVIEW_STYLE_MAIN: _bindgen_ty_65 = 0;
pub type _bindgen_ty_65 = u32;
pub type lv_tileview_style_t = u8;
extern "C" {
    #[doc = " Create a tileview objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new tileview"]
    #[doc = " @param copy pointer to a tileview object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created tileview"]
    pub fn lv_tileview_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Register an object on the tileview. The register object will able to slide the tileview"]
    #[doc = " @param tileview pointer to a Tileview object"]
    #[doc = " @param element pointer to an object"]
    pub fn lv_tileview_add_element(tileview: *mut lv_obj_t, element: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Set the valid position's indices. The scrolling will be possible only to these positions."]
    #[doc = " @param tileview pointer to a Tileview object"]
    #[doc = " @param valid_pos array width the indices. E.g. `lv_point_t p[] = {{0,0}, {1,0}, {1,1}`."]
    #[doc = "  Only the pointer is saved so can't be a local variable."]
    #[doc = " @param valid_pos_cnt numner of elements in `valid_pos` array"]
    pub fn lv_tileview_set_valid_positions(
        tileview: *mut lv_obj_t,
        valid_pos: *const lv_point_t,
        valid_pos_cnt: u16,
    );
}
extern "C" {
    #[doc = " Set the tile to be shown"]
    #[doc = " @param tileview pointer to a tileview object"]
    #[doc = " @param x column id (0, 1, 2...)"]
    #[doc = " @param y line id (0, 1, 2...)"]
    #[doc = " @param anim LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
    pub fn lv_tileview_set_tile_act(
        tileview: *mut lv_obj_t,
        x: lv_coord_t,
        y: lv_coord_t,
        anim: lv_anim_enable_t,
    );
}
extern "C" {
    #[doc = " Set a style of a tileview."]
    #[doc = " @param tileview pointer to tileview object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_tileview_set_style(
        tileview: *mut lv_obj_t,
        type_: lv_tileview_style_t,
        style: *const lv_style_t,
    );
}
extern "C" {
    #[doc = " Get style of a tileview."]
    #[doc = " @param tileview pointer to tileview object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to the style"]
    pub fn lv_tileview_get_style(
        tileview: *const lv_obj_t,
        type_: lv_tileview_style_t,
    ) -> *const lv_style_t;
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_mbox_ext_t {
    pub bg: lv_cont_ext_t,
    pub text: *mut lv_obj_t,
    pub btnm: *mut lv_obj_t,
    pub anim_time: u16,
}
pub const LV_MBOX_STYLE_BG: _bindgen_ty_66 = 0;
#[doc = "< Same meaning as ordinary button styles."]
pub const LV_MBOX_STYLE_BTN_BG: _bindgen_ty_66 = 1;
pub const LV_MBOX_STYLE_BTN_REL: _bindgen_ty_66 = 2;
pub const LV_MBOX_STYLE_BTN_PR: _bindgen_ty_66 = 3;
pub const LV_MBOX_STYLE_BTN_TGL_REL: _bindgen_ty_66 = 4;
pub const LV_MBOX_STYLE_BTN_TGL_PR: _bindgen_ty_66 = 5;
pub const LV_MBOX_STYLE_BTN_INA: _bindgen_ty_66 = 6;
#[doc = " Message box styles."]
pub type _bindgen_ty_66 = u32;
pub type lv_mbox_style_t = u8;
extern "C" {
    #[doc = " Create a message box objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new message box"]
    #[doc = " @param copy pointer to a message box object, if not NULL then the new object will be copied from"]
    #[doc = " it"]
    #[doc = " @return pointer to the created message box"]
    pub fn lv_mbox_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Add button to the message box"]
    #[doc = " @param mbox pointer to message box object"]
    #[doc = " @param btn_map button descriptor (button matrix map)."]
    #[doc = "                E.g.  a const char *txt[] = {\"ok\", \"close\", \"\"} (Can not be local variable)"]
    pub fn lv_mbox_add_btns(mbox: *mut lv_obj_t, btn_mapaction: *mut *const cty::c_char);
}
extern "C" {
    #[doc = " Set the text of the message box"]
    #[doc = " @param mbox pointer to a message box"]
    #[doc = " @param txt a '\\0' terminated character string which will be the message box text"]
    pub fn lv_mbox_set_text(mbox: *mut lv_obj_t, txt: *const cty::c_char);
}
extern "C" {
    #[doc = " Set animation duration"]
    #[doc = " @param mbox pointer to a message box object"]
    #[doc = " @param anim_time animation length in  milliseconds (0: no animation)"]
    pub fn lv_mbox_set_anim_time(mbox: *mut lv_obj_t, anim_time: u16);
}
extern "C" {
    #[doc = " Automatically delete the message box after a given time"]
    #[doc = " @param mbox pointer to a message box object"]
    #[doc = " @param delay a time (in milliseconds) to wait before delete the message box"]
    pub fn lv_mbox_start_auto_close(mbox: *mut lv_obj_t, delay: u16);
}
extern "C" {
    #[doc = " Stop the auto. closing of message box"]
    #[doc = " @param mbox pointer to a message box object"]
    pub fn lv_mbox_stop_auto_close(mbox: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Set a style of a message box"]
    #[doc = " @param mbox pointer to a message box object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_mbox_set_style(mbox: *mut lv_obj_t, type_: lv_mbox_style_t, style: *const lv_style_t);
}
extern "C" {
    #[doc = " Set whether recoloring is enabled. Must be called after `lv_mbox_add_btns`."]
    #[doc = " @param btnm pointer to button matrix object"]
    #[doc = " @param en whether recoloring is enabled"]
    pub fn lv_mbox_set_recolor(mbox: *mut lv_obj_t, en: bool);
}
extern "C" {
    #[doc = " Get the text of the message box"]
    #[doc = " @param mbox pointer to a message box object"]
    #[doc = " @return pointer to the text of the message box"]
    pub fn lv_mbox_get_text(mbox: *const lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Get the index of the lastly \"activated\" button by the user (pressed, released etc)"]
    #[doc = " Useful in the the `event_cb`."]
    #[doc = " @param btnm pointer to button matrix object"]
    #[doc = " @return  index of the last released button (LV_BTNM_BTN_NONE: if unset)"]
    pub fn lv_mbox_get_active_btn(mbox: *mut lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get the text of the lastly \"activated\" button by the user (pressed, released etc)"]
    #[doc = " Useful in the the `event_cb`."]
    #[doc = " @param btnm pointer to button matrix object"]
    #[doc = " @return text of the last released button (NULL: if unset)"]
    pub fn lv_mbox_get_active_btn_text(mbox: *mut lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    #[doc = " Get the animation duration (close animation time)"]
    #[doc = " @param mbox pointer to a message box object"]
    #[doc = " @return animation length in  milliseconds (0: no animation)"]
    pub fn lv_mbox_get_anim_time(mbox: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get a style of a message box"]
    #[doc = " @param mbox pointer to a message box object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to a style"]
    pub fn lv_mbox_get_style(mbox: *const lv_obj_t, type_: lv_mbox_style_t) -> *const lv_style_t;
}
extern "C" {
    #[doc = " Get whether recoloring is enabled"]
    #[doc = " @param mbox pointer to a message box object"]
    #[doc = " @return whether recoloring is enabled"]
    pub fn lv_mbox_get_recolor(mbox: *const lv_obj_t) -> bool;
}
extern "C" {
    #[doc = " Get message box button matrix"]
    #[doc = " @param mbox pointer to a message box object"]
    #[doc = " @return pointer to button matrix object"]
    #[doc = " @remarks return value will be NULL unless `lv_mbox_add_btns` has been already called"]
    pub fn lv_mbox_get_btnm(mbox: *mut lv_obj_t) -> *mut lv_obj_t;
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_lmeter_ext_t {
    pub scale_angle: u16,
    pub angle_ofs: u16,
    pub line_cnt: u16,
    pub cur_value: i16,
    pub min_value: i16,
    pub max_value: i16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
impl lv_lmeter_ext_t {
    #[inline]
    pub fn mirrored(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mirrored(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mirrored: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mirrored: u8 = unsafe { ::core::mem::transmute(mirrored) };
            mirrored as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_LMETER_STYLE_MAIN: _bindgen_ty_67 = 0;
pub type _bindgen_ty_67 = u32;
pub type lv_lmeter_style_t = u8;
extern "C" {
    #[doc = " Create a line meter objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new line meter"]
    #[doc = " @param copy pointer to a line meter object, if not NULL then the new object will be copied from"]
    #[doc = " it"]
    #[doc = " @return pointer to the created line meter"]
    pub fn lv_lmeter_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set a new value on the line meter"]
    #[doc = " @param lmeter pointer to a line meter object"]
    #[doc = " @param value new value"]
    pub fn lv_lmeter_set_value(lmeter: *mut lv_obj_t, value: i16);
}
extern "C" {
    #[doc = " Set minimum and the maximum values of a line meter"]
    #[doc = " @param lmeter pointer to he line meter object"]
    #[doc = " @param min minimum value"]
    #[doc = " @param max maximum value"]
    pub fn lv_lmeter_set_range(lmeter: *mut lv_obj_t, min: i16, max: i16);
}
extern "C" {
    #[doc = " Set the scale settings of a line meter"]
    #[doc = " @param lmeter pointer to a line meter object"]
    #[doc = " @param angle angle of the scale (0..360)"]
    #[doc = " @param line_cnt number of lines"]
    pub fn lv_lmeter_set_scale(lmeter: *mut lv_obj_t, angle: u16, line_cnt: u16);
}
extern "C" {
    #[doc = " Set the set an offset for the line meter's angles to rotate it."]
    #[doc = " @param lmeter pointer to a line meter object"]
    #[doc = " @param angle angle offset (0..360), rotates clockwise"]
    pub fn lv_lmeter_set_angle_offset(lmeter: *mut lv_obj_t, angle: u16);
}
extern "C" {
    #[doc = " Set the orientation of the meter growth, clockwise or counterclockwise (mirrored)"]
    #[doc = " @param lmeter pointer to a line meter object"]
    #[doc = " @param mirror mirror setting"]
    pub fn lv_lmeter_set_mirror(lmeter: *mut lv_obj_t, mirror: bool);
}
extern "C" {
    #[doc = " Get the value of a line meter"]
    #[doc = " @param lmeter pointer to a line meter object"]
    #[doc = " @return the value of the line meter"]
    pub fn lv_lmeter_get_value(lmeter: *const lv_obj_t) -> i16;
}
extern "C" {
    #[doc = " Get the minimum value of a line meter"]
    #[doc = " @param lmeter pointer to a line meter object"]
    #[doc = " @return the minimum value of the line meter"]
    pub fn lv_lmeter_get_min_value(lmeter: *const lv_obj_t) -> i16;
}
extern "C" {
    #[doc = " Get the maximum value of a line meter"]
    #[doc = " @param lmeter pointer to a line meter object"]
    #[doc = " @return the maximum value of the line meter"]
    pub fn lv_lmeter_get_max_value(lmeter: *const lv_obj_t) -> i16;
}
extern "C" {
    #[doc = " Get the scale number of a line meter"]
    #[doc = " @param lmeter pointer to a line meter object"]
    #[doc = " @return number of the scale units"]
    pub fn lv_lmeter_get_line_count(lmeter: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get the scale angle of a line meter"]
    #[doc = " @param lmeter pointer to a line meter object"]
    #[doc = " @return angle of the scale"]
    pub fn lv_lmeter_get_scale_angle(lmeter: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " get the set an offset for the line meter."]
    #[doc = " @param lmeter pointer to a line meter object"]
    #[doc = " @return angle offset (0..360)"]
    pub fn lv_lmeter_get_angle_offset(lmeter: *mut lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " get the mirror setting for the line meter"]
    #[doc = " @param lmeter pointer to a line meter object"]
    #[doc = " @return mirror (true or false)"]
    pub fn lv_lmeter_get_mirror(lmeter: *mut lv_obj_t) -> bool;
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_gauge_ext_t {
    pub lmeter: lv_lmeter_ext_t,
    pub values: *mut i16,
    pub needle_colors: *const lv_color_t,
    pub needle_count: u8,
    pub label_count: u8,
}
pub const LV_GAUGE_STYLE_MAIN: _bindgen_ty_68 = 0;
pub type _bindgen_ty_68 = u32;
pub type lv_gauge_style_t = u8;
extern "C" {
    #[doc = " Create a gauge objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new gauge"]
    #[doc = " @param copy pointer to a gauge object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created gauge"]
    pub fn lv_gauge_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set the number of needles"]
    #[doc = " @param gauge pointer to gauge object"]
    #[doc = " @param needle_cnt new count of needles"]
    #[doc = " @param colors an array of colors for needles (with 'num' elements)"]
    pub fn lv_gauge_set_needle_count(
        gauge: *mut lv_obj_t,
        needle_cnt: u8,
        colors: *const lv_color_t,
    );
}
extern "C" {
    #[doc = " Set the value of a needle"]
    #[doc = " @param gauge pointer to a gauge"]
    #[doc = " @param needle_id the id of the needle"]
    #[doc = " @param value the new value"]
    pub fn lv_gauge_set_value(gauge: *mut lv_obj_t, needle_id: u8, value: i16);
}
extern "C" {
    #[doc = " Set the scale settings of a gauge"]
    #[doc = " @param gauge pointer to a gauge object"]
    #[doc = " @param angle angle of the scale (0..360)"]
    #[doc = " @param line_cnt count of scale lines."]
    #[doc = " The get a given \"subdivision\" lines between label, `line_cnt` = (sub_div + 1) * (label_cnt - 1) +"]
    #[doc = " 1"]
    #[doc = " @param label_cnt count of scale labels."]
    pub fn lv_gauge_set_scale(gauge: *mut lv_obj_t, angle: u16, line_cnt: u8, label_cnt: u8);
}
extern "C" {
    #[doc = " Get the value of a needle"]
    #[doc = " @param gauge pointer to gauge object"]
    #[doc = " @param needle the id of the needle"]
    #[doc = " @return the value of the needle [min,max]"]
    pub fn lv_gauge_get_value(gauge: *const lv_obj_t, needle: u8) -> i16;
}
extern "C" {
    #[doc = " Get the count of needles on a gauge"]
    #[doc = " @param gauge pointer to gauge"]
    #[doc = " @return count of needles"]
    pub fn lv_gauge_get_needle_count(gauge: *const lv_obj_t) -> u8;
}
extern "C" {
    #[doc = " Set the number of labels (and the thicker lines too)"]
    #[doc = " @param gauge pointer to a gauge object"]
    #[doc = " @return count of labels"]
    pub fn lv_gauge_get_label_count(gauge: *const lv_obj_t) -> u8;
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_sw_ext_t {
    pub slider: lv_slider_ext_t,
    #[doc = "< Style of the knob when the switch is OFF"]
    pub style_knob_off: *const lv_style_t,
    #[doc = "< Style of the knob when the switch is ON (NULL to use the same as OFF)"]
    pub style_knob_on: *const lv_style_t,
    pub start_x: lv_coord_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub anim_time: u16,
}
impl lv_sw_ext_t {
    #[inline]
    pub fn changed(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_changed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slided(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slided(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(changed: u8, slided: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let changed: u8 = unsafe { ::core::mem::transmute(changed) };
            changed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slided: u8 = unsafe { ::core::mem::transmute(slided) };
            slided as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< Switch background."]
pub const LV_SW_STYLE_BG: _bindgen_ty_69 = 0;
#[doc = "< Switch fill area."]
pub const LV_SW_STYLE_INDIC: _bindgen_ty_69 = 1;
#[doc = "< Switch knob (when off)."]
pub const LV_SW_STYLE_KNOB_OFF: _bindgen_ty_69 = 2;
#[doc = "< Switch knob (when on)."]
pub const LV_SW_STYLE_KNOB_ON: _bindgen_ty_69 = 3;
#[doc = " Switch styles."]
pub type _bindgen_ty_69 = u32;
pub type lv_sw_style_t = u8;
extern "C" {
    #[doc = " Create a switch objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new switch"]
    #[doc = " @param copy pointer to a switch object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created switch"]
    pub fn lv_sw_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Turn ON the switch"]
    #[doc = " @param sw pointer to a switch object"]
    #[doc = " @param anim LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
    pub fn lv_sw_on(sw: *mut lv_obj_t, anim: lv_anim_enable_t);
}
extern "C" {
    #[doc = " Turn OFF the switch"]
    #[doc = " @param sw pointer to a switch object"]
    #[doc = " @param anim LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
    pub fn lv_sw_off(sw: *mut lv_obj_t, anim: lv_anim_enable_t);
}
extern "C" {
    #[doc = " Toggle the position of the switch"]
    #[doc = " @param sw pointer to a switch object"]
    #[doc = " @param anim LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately"]
    #[doc = " @return resulting state of the switch."]
    pub fn lv_sw_toggle(sw: *mut lv_obj_t, anim: lv_anim_enable_t) -> bool;
}
extern "C" {
    #[doc = " Set a style of a switch"]
    #[doc = " @param sw pointer to a switch object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_sw_set_style(sw: *mut lv_obj_t, type_: lv_sw_style_t, style: *const lv_style_t);
}
extern "C" {
    #[doc = " Set the animation time of the switch"]
    #[doc = " @param sw pointer to a  switch object"]
    #[doc = " @param anim_time animation time"]
    #[doc = " @return style pointer to a style"]
    pub fn lv_sw_set_anim_time(sw: *mut lv_obj_t, anim_time: u16);
}
extern "C" {
    #[doc = " Get a style of a switch"]
    #[doc = " @param sw pointer to a  switch object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to a style"]
    pub fn lv_sw_get_style(sw: *const lv_obj_t, type_: lv_sw_style_t) -> *const lv_style_t;
}
extern "C" {
    #[doc = " Get the animation time of the switch"]
    #[doc = " @param sw pointer to a  switch object"]
    #[doc = " @return style pointer to a style"]
    pub fn lv_sw_get_anim_time(sw: *const lv_obj_t) -> u16;
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_arc_ext_t {
    pub angle_start: lv_coord_t,
    pub angle_end: lv_coord_t,
}
pub const LV_ARC_STYLE_MAIN: _bindgen_ty_70 = 0;
pub type _bindgen_ty_70 = u32;
pub type lv_arc_style_t = u8;
extern "C" {
    #[doc = " Create a arc objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new arc"]
    #[doc = " @param copy pointer to a arc object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created arc"]
    pub fn lv_arc_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set the start and end angles of an arc. 0 deg: bottom, 90 deg: right etc."]
    #[doc = " @param arc pointer to an arc object"]
    #[doc = " @param start the start angle [0..360]"]
    #[doc = " @param end the end angle [0..360]"]
    pub fn lv_arc_set_angles(arc: *mut lv_obj_t, start: u16, end: u16);
}
extern "C" {
    #[doc = " Set a style of a arc."]
    #[doc = " @param arc pointer to arc object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_arc_set_style(arc: *mut lv_obj_t, type_: lv_arc_style_t, style: *const lv_style_t);
}
extern "C" {
    #[doc = " Get the start angle of an arc."]
    #[doc = " @param arc pointer to an arc object"]
    #[doc = " @return the start angle [0..360]"]
    pub fn lv_arc_get_angle_start(arc: *mut lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get the end angle of an arc."]
    #[doc = " @param arc pointer to an arc object"]
    #[doc = " @return the end angle [0..360]"]
    pub fn lv_arc_get_angle_end(arc: *mut lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get style of a arc."]
    #[doc = " @param arc pointer to arc object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to the style"]
    pub fn lv_arc_get_style(arc: *const lv_obj_t, type_: lv_arc_style_t) -> *const lv_style_t;
}
pub const LV_PRELOAD_TYPE_SPINNING_ARC: _bindgen_ty_71 = 0;
pub const LV_PRELOAD_TYPE_FILLSPIN_ARC: _bindgen_ty_71 = 1;
pub const LV_PRELOAD_TYPE_CONSTANT_ARC: _bindgen_ty_71 = 2;
#[doc = " Type of preloader."]
pub type _bindgen_ty_71 = u32;
pub type lv_preload_type_t = u8;
pub const LV_PRELOAD_DIR_FORWARD: _bindgen_ty_72 = 0;
pub const LV_PRELOAD_DIR_BACKWARD: _bindgen_ty_72 = 1;
#[doc = " Direction the preloader should spin."]
pub type _bindgen_ty_72 = u32;
pub type lv_preload_dir_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_preload_ext_t {
    pub arc: lv_arc_ext_t,
    pub arc_length: lv_anim_value_t,
    pub time: u16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
impl lv_preload_ext_t {
    #[inline]
    pub fn anim_type(&self) -> lv_preload_type_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_anim_type(&mut self, val: lv_preload_type_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn anim_dir(&self) -> lv_preload_dir_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_anim_dir(&mut self, val: lv_preload_dir_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        anim_type: lv_preload_type_t,
        anim_dir: lv_preload_dir_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let anim_type: u8 = unsafe { ::core::mem::transmute(anim_type) };
            anim_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let anim_dir: u8 = unsafe { ::core::mem::transmute(anim_dir) };
            anim_dir as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_PRELOAD_STYLE_MAIN: _bindgen_ty_73 = 0;
pub type _bindgen_ty_73 = u32;
pub type lv_preload_style_t = u8;
extern "C" {
    #[doc = " Create a pre loader objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new pre loader"]
    #[doc = " @param copy pointer to a pre loader object, if not NULL then the new object will be copied from"]
    #[doc = " it"]
    #[doc = " @return pointer to the created pre loader"]
    pub fn lv_preload_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set the length of the spinning  arc in degrees"]
    #[doc = " @param preload pointer to a preload object"]
    #[doc = " @param deg length of the arc"]
    pub fn lv_preload_set_arc_length(preload: *mut lv_obj_t, deg: lv_anim_value_t);
}
extern "C" {
    #[doc = " Set the spin time of the arc"]
    #[doc = " @param preload pointer to a preload object"]
    #[doc = " @param time time of one round in milliseconds"]
    pub fn lv_preload_set_spin_time(preload: *mut lv_obj_t, time: u16);
}
extern "C" {
    #[doc = " Set a style of a pre loader."]
    #[doc = " @param preload pointer to pre loader object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_preload_set_style(
        preload: *mut lv_obj_t,
        type_: lv_preload_style_t,
        style: *const lv_style_t,
    );
}
extern "C" {
    #[doc = " Set the animation type of a preloader."]
    #[doc = " @param preload pointer to pre loader object"]
    #[doc = " @param type animation type of the preload"]
    pub fn lv_preload_set_type(preload: *mut lv_obj_t, type_: lv_preload_type_t);
}
extern "C" {
    #[doc = " Set the animation direction of a preloader"]
    #[doc = " @param preload pointer to pre loader object"]
    #[doc = " @param direction animation direction of the preload"]
    pub fn lv_preload_set_dir(preload: *mut lv_obj_t, dir: lv_preload_dir_t);
}
extern "C" {
    #[doc = " Get the arc length [degree] of the a pre loader"]
    #[doc = " @param preload pointer to a pre loader object"]
    pub fn lv_preload_get_arc_length(preload: *const lv_obj_t) -> lv_anim_value_t;
}
extern "C" {
    #[doc = " Get the spin time of the arc"]
    #[doc = " @param preload pointer to a pre loader object [milliseconds]"]
    pub fn lv_preload_get_spin_time(preload: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get style of a pre loader."]
    #[doc = " @param preload pointer to pre loader object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to the style"]
    pub fn lv_preload_get_style(
        preload: *const lv_obj_t,
        type_: lv_preload_style_t,
    ) -> *const lv_style_t;
}
extern "C" {
    #[doc = " Get the animation type of a preloader."]
    #[doc = " @param preload pointer to pre loader object"]
    #[doc = " @return animation type"]
    pub fn lv_preload_get_type(preload: *mut lv_obj_t) -> lv_preload_type_t;
}
extern "C" {
    #[doc = " Get the animation direction of a preloader"]
    #[doc = " @param preload pointer to pre loader object"]
    #[doc = " @return animation direction"]
    pub fn lv_preload_get_dir(preload: *mut lv_obj_t) -> lv_preload_dir_t;
}
extern "C" {
    #[doc = " Animator function  (exec_cb) to rotate the arc of spinner."]
    #[doc = " @param ptr pointer to preloader"]
    #[doc = " @param val the current desired value [0..360]"]
    pub fn lv_preload_spinner_anim(ptr: *mut cty::c_void, val: lv_anim_value_t);
}
#[doc = " Represents a date on the calendar object (platform-agnostic)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_calendar_date_t {
    pub year: u16,
    pub month: i8,
    pub day: i8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_calendar_ext_t {
    pub today: lv_calendar_date_t,
    pub showed_date: lv_calendar_date_t,
    pub highlighted_dates: *mut lv_calendar_date_t,
    pub btn_pressing: i8,
    pub highlighted_dates_num: u16,
    pub pressed_date: lv_calendar_date_t,
    pub day_names: *mut *const cty::c_char,
    pub month_names: *mut *const cty::c_char,
    pub style_header: *const lv_style_t,
    pub style_header_pr: *const lv_style_t,
    pub style_day_names: *const lv_style_t,
    pub style_highlighted_days: *const lv_style_t,
    pub style_inactive_days: *const lv_style_t,
    pub style_week_box: *const lv_style_t,
    pub style_today_box: *const lv_style_t,
}
#[doc = "< Background and \"normal\" date numbers style"]
pub const LV_CALENDAR_STYLE_BG: _bindgen_ty_74 = 0;
pub const LV_CALENDAR_STYLE_HEADER: _bindgen_ty_74 = 1;
#[doc = " Calendar header style"]
pub const LV_CALENDAR_STYLE_HEADER_PR: _bindgen_ty_74 = 2;
#[doc = " Calendar header style (when pressed)"]
pub const LV_CALENDAR_STYLE_DAY_NAMES: _bindgen_ty_74 = 3;
#[doc = " Day name style"]
pub const LV_CALENDAR_STYLE_HIGHLIGHTED_DAYS: _bindgen_ty_74 = 4;
#[doc = " Highlighted day style"]
pub const LV_CALENDAR_STYLE_INACTIVE_DAYS: _bindgen_ty_74 = 5;
#[doc = " Inactive day style"]
pub const LV_CALENDAR_STYLE_WEEK_BOX: _bindgen_ty_74 = 6;
#[doc = " Week highlight style"]
pub const LV_CALENDAR_STYLE_TODAY_BOX: _bindgen_ty_74 = 7;
#[doc = " Calendar styles"]
pub type _bindgen_ty_74 = u32;
pub type lv_calendar_style_t = u8;
extern "C" {
    #[doc = " Create a calendar objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new calendar"]
    #[doc = " @param copy pointer to a calendar object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created calendar"]
    pub fn lv_calendar_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set the today's date"]
    #[doc = " @param calendar pointer to a calendar object"]
    #[doc = " @param today pointer to an `lv_calendar_date_t` variable containing the date of today. The value"]
    #[doc = " will be saved it can be local variable too."]
    pub fn lv_calendar_set_today_date(calendar: *mut lv_obj_t, today: *mut lv_calendar_date_t);
}
extern "C" {
    #[doc = " Set the currently showed"]
    #[doc = " @param calendar pointer to a calendar object"]
    #[doc = " @param showed pointer to an `lv_calendar_date_t` variable containing the date to show. The value"]
    #[doc = " will be saved it can be local variable too."]
    pub fn lv_calendar_set_showed_date(calendar: *mut lv_obj_t, showed: *mut lv_calendar_date_t);
}
extern "C" {
    #[doc = " Set the the highlighted dates"]
    #[doc = " @param calendar pointer to a calendar object"]
    #[doc = " @param highlighted pointer to an `lv_calendar_date_t` array containing the dates. ONLY A POINTER"]
    #[doc = " WILL BE SAVED! CAN'T BE LOCAL ARRAY."]
    #[doc = " @param date_num number of dates in the array"]
    pub fn lv_calendar_set_highlighted_dates(
        calendar: *mut lv_obj_t,
        highlighted: *mut lv_calendar_date_t,
        date_num: u16,
    );
}
extern "C" {
    #[doc = " Set the name of the days"]
    #[doc = " @param calendar pointer to a calendar object"]
    #[doc = " @param day_names pointer to an array with the names. E.g. `const char * days[7] = {\"Sun\", \"Mon\","]
    #[doc = " ...}` Only the pointer will be saved so this variable can't be local which will be destroyed"]
    #[doc = " later."]
    pub fn lv_calendar_set_day_names(calendar: *mut lv_obj_t, day_names: *mut *const cty::c_char);
}
extern "C" {
    #[doc = " Set the name of the month"]
    #[doc = " @param calendar pointer to a calendar object"]
    #[doc = " @param month_names pointer to an array with the names. E.g. `const char * days[12] = {\"Jan\", \"Feb\","]
    #[doc = " ...}` Only the pointer will be saved so this variable can't be local which will be destroyed"]
    #[doc = " later."]
    pub fn lv_calendar_set_month_names(
        calendar: *mut lv_obj_t,
        month_names: *mut *const cty::c_char,
    );
}
extern "C" {
    #[doc = " Set a style of a calendar."]
    #[doc = " @param calendar pointer to calendar object"]
    #[doc = " @param type which style should be set"]
    #[doc = " @param style pointer to a style"]
    pub fn lv_calendar_set_style(
        calendar: *mut lv_obj_t,
        type_: lv_calendar_style_t,
        style: *const lv_style_t,
    );
}
extern "C" {
    #[doc = " Get the today's date"]
    #[doc = " @param calendar pointer to a calendar object"]
    #[doc = " @return return pointer to an `lv_calendar_date_t` variable containing the date of today."]
    pub fn lv_calendar_get_today_date(calendar: *const lv_obj_t) -> *mut lv_calendar_date_t;
}
extern "C" {
    #[doc = " Get the currently showed"]
    #[doc = " @param calendar pointer to a calendar object"]
    #[doc = " @return pointer to an `lv_calendar_date_t` variable containing the date is being shown."]
    pub fn lv_calendar_get_showed_date(calendar: *const lv_obj_t) -> *mut lv_calendar_date_t;
}
extern "C" {
    #[doc = " Get the the pressed date."]
    #[doc = " @param calendar pointer to a calendar object"]
    #[doc = " @return pointer to an `lv_calendar_date_t` variable containing the pressed date."]
    #[doc = "         `NULL` if not date pressed (e.g. the header)"]
    pub fn lv_calendar_get_pressed_date(calendar: *const lv_obj_t) -> *mut lv_calendar_date_t;
}
extern "C" {
    #[doc = " Get the the highlighted dates"]
    #[doc = " @param calendar pointer to a calendar object"]
    #[doc = " @return pointer to an `lv_calendar_date_t` array containing the dates."]
    pub fn lv_calendar_get_highlighted_dates(calendar: *const lv_obj_t) -> *mut lv_calendar_date_t;
}
extern "C" {
    #[doc = " Get the number of the highlighted dates"]
    #[doc = " @param calendar pointer to a calendar object"]
    #[doc = " @return number of highlighted days"]
    pub fn lv_calendar_get_highlighted_dates_num(calendar: *const lv_obj_t) -> u16;
}
extern "C" {
    #[doc = " Get the name of the days"]
    #[doc = " @param calendar pointer to a calendar object"]
    #[doc = " @return pointer to the array of day names"]
    pub fn lv_calendar_get_day_names(calendar: *const lv_obj_t) -> *mut *const cty::c_char;
}
extern "C" {
    #[doc = " Get the name of the month"]
    #[doc = " @param calendar pointer to a calendar object"]
    #[doc = " @return pointer to the array of month names"]
    pub fn lv_calendar_get_month_names(calendar: *const lv_obj_t) -> *mut *const cty::c_char;
}
extern "C" {
    #[doc = " Get style of a calendar."]
    #[doc = " @param calendar pointer to calendar object"]
    #[doc = " @param type which style should be get"]
    #[doc = " @return style pointer to the style"]
    pub fn lv_calendar_get_style(
        calendar: *const lv_obj_t,
        type_: lv_calendar_style_t,
    ) -> *const lv_style_t;
}
#[doc = "      TYPEDEFS"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_spinbox_ext_t {
    pub ta: lv_ta_ext_t,
    pub value: i32,
    pub range_max: i32,
    pub range_min: i32,
    pub step: i32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl lv_spinbox_ext_t {
    #[inline]
    pub fn digit_count(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_digit_count(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn dec_point_pos(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_dec_point_pos(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn digit_padding_left(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_digit_padding_left(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        digit_count: u16,
        dec_point_pos: u16,
        digit_padding_left: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let digit_count: u16 = unsafe { ::core::mem::transmute(digit_count) };
            digit_count as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let dec_point_pos: u16 = unsafe { ::core::mem::transmute(dec_point_pos) };
            dec_point_pos as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let digit_padding_left: u16 = unsafe { ::core::mem::transmute(digit_padding_left) };
            digit_padding_left as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_SPINBOX_STYLE_BG: _bindgen_ty_75 = 0;
pub const LV_SPINBOX_STYLE_SB: _bindgen_ty_75 = 1;
pub const LV_SPINBOX_STYLE_CURSOR: _bindgen_ty_75 = 2;
pub type _bindgen_ty_75 = u32;
pub type lv_spinbox_style_t = u8;
extern "C" {
    #[doc = " Create a spinbox objects"]
    #[doc = " @param par pointer to an object, it will be the parent of the new spinbox"]
    #[doc = " @param copy pointer to a spinbox object, if not NULL then the new object will be copied from it"]
    #[doc = " @return pointer to the created spinbox"]
    pub fn lv_spinbox_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    #[doc = " Set spinbox value"]
    #[doc = " @param spinbox pointer to spinbox"]
    #[doc = " @param i value to be set"]
    pub fn lv_spinbox_set_value(spinbox: *mut lv_obj_t, i: i32);
}
extern "C" {
    #[doc = " Set spinbox digit format (digit count and decimal format)"]
    #[doc = " @param spinbox pointer to spinbox"]
    #[doc = " @param digit_count number of digit excluding the decimal separator and the sign"]
    #[doc = " @param separator_position number of digit before the decimal point. If 0, decimal point is not"]
    #[doc = " shown"]
    pub fn lv_spinbox_set_digit_format(
        spinbox: *mut lv_obj_t,
        digit_count: u8,
        separator_position: u8,
    );
}
extern "C" {
    #[doc = " Set spinbox step"]
    #[doc = " @param spinbox pointer to spinbox"]
    #[doc = " @param step steps on increment/decrement"]
    pub fn lv_spinbox_set_step(spinbox: *mut lv_obj_t, step: u32);
}
extern "C" {
    #[doc = " Set spinbox value range"]
    #[doc = " @param spinbox pointer to spinbox"]
    #[doc = " @param range_min maximum value, inclusive"]
    #[doc = " @param range_max minimum value, inclusive"]
    pub fn lv_spinbox_set_range(spinbox: *mut lv_obj_t, range_min: i32, range_max: i32);
}
extern "C" {
    #[doc = " Set spinbox left padding in digits count (added between sign and first digit)"]
    #[doc = " @param spinbox pointer to spinbox"]
    #[doc = " @param cb Callback function called on value change event"]
    pub fn lv_spinbox_set_padding_left(spinbox: *mut lv_obj_t, padding: u8);
}
extern "C" {
    #[doc = " Get the spinbox numeral value (user has to convert to float according to its digit format)"]
    #[doc = " @param spinbox pointer to spinbox"]
    #[doc = " @return value integer value of the spinbox"]
    pub fn lv_spinbox_get_value(spinbox: *mut lv_obj_t) -> i32;
}
extern "C" {
    #[doc = " Select next lower digit for edition by dividing the step by 10"]
    #[doc = " @param spinbox pointer to spinbox"]
    pub fn lv_spinbox_step_next(spinbox: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Select next higher digit for edition by multiplying the step by 10"]
    #[doc = " @param spinbox pointer to spinbox"]
    pub fn lv_spinbox_step_prev(spinbox: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Increment spinbox value by one step"]
    #[doc = " @param spinbox pointer to spinbox"]
    pub fn lv_spinbox_increment(spinbox: *mut lv_obj_t);
}
extern "C" {
    #[doc = " Decrement spinbox value by one step"]
    #[doc = " @param spinbox pointer to spinbox"]
    pub fn lv_spinbox_decrement(spinbox: *mut lv_obj_t);
}
#[doc = " When loading images from the network it can take a long time to download and decode the image."]
#[doc = ""]
#[doc = " To avoid repeating this heavy load images can be cached."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_img_cache_entry_t {
    #[doc = "< Image information"]
    pub dec_dsc: lv_img_decoder_dsc_t,
    #[doc = " Count the cache entries's life. Add `time_tio_open` to `life` when the entry is used."]
    #[doc = " Decrement all lifes by one every in every ::lv_img_cache_open."]
    #[doc = " If life == 0 the entry can be reused"]
    pub life: i32,
}
extern "C" {
    #[doc = " Open an image using the image decoder interface and cache it."]
    #[doc = " The image will be left open meaning if the image decoder open callback allocated memory then it will remain."]
    #[doc = " The image is closed if a new image is opened and the new image takes its place in the cache."]
    #[doc = " @param src source of the image. Path to file or pointer to an `lv_img_dsc_t` variable"]
    #[doc = " @param style style of the image"]
    #[doc = " @return pointer to the cache entry or NULL if can open the image"]
    pub fn lv_img_cache_open(
        src: *const cty::c_void,
        style: *const lv_style_t,
    ) -> *mut lv_img_cache_entry_t;
}
extern "C" {
    #[doc = " Set the number of images to be cached."]
    #[doc = " More cached images mean more opened image at same time which might mean more memory usage."]
    #[doc = " E.g. if 20 PNG or JPG images are open in the RAM they consume memory while opened in the cache."]
    #[doc = " @param new_entry_cnt number of image to cache"]
    pub fn lv_img_cache_set_size(new_slot_num: u16);
}
extern "C" {
    #[doc = " Invalidate an image source in the cache."]
    #[doc = " Useful if the image source is updated therefore it needs to be cached again."]
    #[doc = " @param src an image source path to a file or pointer to an `lv_img_dsc_t` variable."]
    pub fn lv_img_cache_invalidate_src(src: *const cty::c_void);
}
extern "C" {
    pub fn _LV_COLOR_MAKE(r: u8, g: u8, b: u8) -> lv_color_t;
}
extern "C" {
    pub fn _LV_COLOR_GET_R(color: lv_color_t) -> u16;
}
extern "C" {
    pub fn _LV_COLOR_GET_G(color: lv_color_t) -> u16;
}
extern "C" {
    pub fn _LV_COLOR_GET_B(color: lv_color_t) -> u16;
}
extern "C" {
    pub fn _LV_COLOR_GET_A(color: lv_color_t) -> u16;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: cty::c_uint,
    pub fp_offset: cty::c_uint,
    pub overflow_arg_area: *mut cty::c_void,
    pub reg_save_area: *mut cty::c_void,
}
