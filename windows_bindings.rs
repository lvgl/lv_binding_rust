/* automatically generated by rust-bindgen 0.58.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const LVGL_VERSION_MAJOR: u32 = 7;
pub const LVGL_VERSION_MINOR: u32 = 10;
pub const LVGL_VERSION_PATCH: u32 = 1;
pub const LVGL_VERSION_INFO: &'static [u8; 1usize] = b"\0";
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const LV_HOR_RES_MAX: u32 = 240;
pub const LV_VER_RES_MAX: u32 = 240;
pub const LV_COLOR_DEPTH: u32 = 16;
pub const LV_COLOR_16_SWAP: u32 = 0;
pub const LV_COLOR_SCREEN_TRANSP: u32 = 0;
pub const LV_ANTIALIAS: u32 = 1;
pub const LV_DISP_DEF_REFR_PERIOD: u32 = 30;
pub const LV_DPI: u32 = 130;
pub const LV_DISP_SMALL_LIMIT: u32 = 30;
pub const LV_DISP_MEDIUM_LIMIT: u32 = 50;
pub const LV_DISP_LARGE_LIMIT: u32 = 70;
pub const LV_MEM_CUSTOM: u32 = 0;
pub const LV_MEM_SIZE: u32 = 32768;
pub const LV_MEM_ADR: u32 = 0;
pub const LV_MEM_AUTO_DEFRAG: u32 = 1;
pub const LV_ENABLE_GC: u32 = 0;
pub const LV_INDEV_DEF_READ_PERIOD: u32 = 30;
pub const LV_INDEV_DEF_DRAG_LIMIT: u32 = 10;
pub const LV_INDEV_DEF_DRAG_THROW: u32 = 10;
pub const LV_INDEV_DEF_LONG_PRESS_TIME: u32 = 400;
pub const LV_INDEV_DEF_LONG_PRESS_REP_TIME: u32 = 100;
pub const LV_INDEV_DEF_GESTURE_LIMIT: u32 = 50;
pub const LV_INDEV_DEF_GESTURE_MIN_VELOCITY: u32 = 3;
pub const LV_USE_ANIMATION: u32 = 1;
pub const LV_USE_SHADOW: u32 = 1;
pub const LV_SHADOW_CACHE_SIZE: u32 = 0;
pub const LV_USE_BLEND_MODES: u32 = 1;
pub const LV_USE_OPA_SCALE: u32 = 1;
pub const LV_USE_IMG_TRANSFORM: u32 = 1;
pub const LV_USE_GROUP: u32 = 1;
pub const LV_USE_GPU: u32 = 1;
pub const LV_USE_GPU_STM32_DMA2D: u32 = 0;
pub const LV_USE_FILESYSTEM: u32 = 1;
pub const LV_USE_USER_DATA: u32 = 1;
pub const LV_USE_PERF_MONITOR: u32 = 0;
pub const LV_USE_API_EXTENSION_V6: u32 = 1;
pub const LV_IMG_CF_INDEXED: u32 = 1;
pub const LV_IMG_CF_ALPHA: u32 = 1;
pub const LV_IMG_CACHE_DEF_SIZE: u32 = 1;
pub const LV_TICK_CUSTOM: u32 = 0;
pub const LV_USE_LOG: u32 = 0;
pub const LV_USE_DEBUG: u32 = 1;
pub const LV_USE_ASSERT_NULL: u32 = 1;
pub const LV_USE_ASSERT_MEM: u32 = 1;
pub const LV_USE_ASSERT_MEM_INTEGRITY: u32 = 0;
pub const LV_USE_ASSERT_STR: u32 = 0;
pub const LV_USE_ASSERT_OBJ: u32 = 0;
pub const LV_USE_ASSERT_STYLE: u32 = 0;
pub const LV_FONT_MONTSERRAT_12: u32 = 0;
pub const LV_FONT_MONTSERRAT_14: u32 = 0;
pub const LV_FONT_MONTSERRAT_16: u32 = 1;
pub const LV_FONT_MONTSERRAT_18: u32 = 0;
pub const LV_FONT_MONTSERRAT_20: u32 = 0;
pub const LV_FONT_MONTSERRAT_22: u32 = 0;
pub const LV_FONT_MONTSERRAT_24: u32 = 0;
pub const LV_FONT_MONTSERRAT_26: u32 = 0;
pub const LV_FONT_MONTSERRAT_28: u32 = 0;
pub const LV_FONT_MONTSERRAT_30: u32 = 0;
pub const LV_FONT_MONTSERRAT_32: u32 = 0;
pub const LV_FONT_MONTSERRAT_34: u32 = 0;
pub const LV_FONT_MONTSERRAT_36: u32 = 0;
pub const LV_FONT_MONTSERRAT_38: u32 = 0;
pub const LV_FONT_MONTSERRAT_40: u32 = 0;
pub const LV_FONT_MONTSERRAT_42: u32 = 0;
pub const LV_FONT_MONTSERRAT_44: u32 = 0;
pub const LV_FONT_MONTSERRAT_46: u32 = 0;
pub const LV_FONT_MONTSERRAT_48: u32 = 0;
pub const LV_FONT_MONTSERRAT_12_SUBPX: u32 = 0;
pub const LV_FONT_MONTSERRAT_28_COMPRESSED: u32 = 0;
pub const LV_FONT_DEJAVU_16_PERSIAN_HEBREW: u32 = 0;
pub const LV_FONT_SIMSUN_16_CJK: u32 = 0;
pub const LV_FONT_UNSCII_8: u32 = 0;
pub const LV_FONT_FMT_TXT_LARGE: u32 = 0;
pub const LV_FONT_SUBPX_BGR: u32 = 0;
pub const LV_USE_THEME_EMPTY: u32 = 1;
pub const LV_USE_THEME_TEMPLATE: u32 = 1;
pub const LV_USE_THEME_MATERIAL: u32 = 1;
pub const LV_USE_THEME_MONO: u32 = 1;
pub const LV_TXT_BREAK_CHARS: &'static [u8; 8usize] = b" ,.;:-_\0";
pub const LV_TXT_LINE_BREAK_LONG_LEN: u32 = 0;
pub const LV_TXT_LINE_BREAK_LONG_PRE_MIN_LEN: u32 = 3;
pub const LV_TXT_LINE_BREAK_LONG_POST_MIN_LEN: u32 = 3;
pub const LV_TXT_COLOR_CMD: &'static [u8; 2usize] = b"#\0";
pub const LV_USE_BIDI: u32 = 0;
pub const LV_USE_ARABIC_PERSIAN_CHARS: u32 = 0;
pub const LV_SPRINTF_CUSTOM: u32 = 0;
pub const LV_SPRINTF_DISABLE_FLOAT: u32 = 1;
pub const LV_USE_USER_DATA_FREE: u32 = 0;
pub const LV_USE_OBJ_REALIGN: u32 = 1;
pub const LV_USE_ARC: u32 = 1;
pub const LV_USE_BAR: u32 = 1;
pub const LV_USE_BTN: u32 = 1;
pub const LV_USE_BTNMATRIX: u32 = 1;
pub const LV_USE_CALENDAR: u32 = 1;
pub const LV_USE_CANVAS: u32 = 1;
pub const LV_USE_CHECKBOX: u32 = 1;
pub const LV_USE_CHART: u32 = 1;
pub const LV_CHART_AXIS_TICK_LABEL_MAX_LEN: u32 = 256;
pub const LV_USE_CONT: u32 = 1;
pub const LV_USE_CPICKER: u32 = 1;
pub const LV_USE_DROPDOWN: u32 = 1;
pub const LV_DROPDOWN_DEF_ANIM_TIME: u32 = 200;
pub const LV_USE_GAUGE: u32 = 1;
pub const LV_USE_IMG: u32 = 1;
pub const LV_USE_IMGBTN: u32 = 1;
pub const LV_IMGBTN_TILED: u32 = 0;
pub const LV_USE_KEYBOARD: u32 = 1;
pub const LV_USE_LABEL: u32 = 1;
pub const LV_LABEL_DEF_SCROLL_SPEED: u32 = 25;
pub const LV_LABEL_WAIT_CHAR_COUNT: u32 = 3;
pub const LV_LABEL_TEXT_SEL: u32 = 0;
pub const LV_LABEL_LONG_TXT_HINT: u32 = 0;
pub const LV_USE_LED: u32 = 1;
pub const LV_LED_BRIGHT_MIN: u32 = 120;
pub const LV_LED_BRIGHT_MAX: u32 = 255;
pub const LV_USE_LINE: u32 = 1;
pub const LV_USE_LIST: u32 = 1;
pub const LV_LIST_DEF_ANIM_TIME: u32 = 100;
pub const LV_USE_LINEMETER: u32 = 1;
pub const LV_LINEMETER_PRECISE: u32 = 0;
pub const LV_USE_OBJMASK: u32 = 1;
pub const LV_USE_MSGBOX: u32 = 1;
pub const LV_USE_PAGE: u32 = 1;
pub const LV_PAGE_DEF_ANIM_TIME: u32 = 400;
pub const LV_USE_SPINNER: u32 = 1;
pub const LV_SPINNER_DEF_ARC_LENGTH: u32 = 60;
pub const LV_SPINNER_DEF_SPIN_TIME: u32 = 1000;
pub const LV_USE_ROLLER: u32 = 1;
pub const LV_ROLLER_DEF_ANIM_TIME: u32 = 200;
pub const LV_ROLLER_INF_PAGES: u32 = 7;
pub const LV_USE_SLIDER: u32 = 1;
pub const LV_USE_SPINBOX: u32 = 1;
pub const LV_USE_SWITCH: u32 = 1;
pub const LV_USE_TEXTAREA: u32 = 1;
pub const LV_TEXTAREA_DEF_CURSOR_BLINK_TIME: u32 = 400;
pub const LV_TEXTAREA_DEF_PWD_SHOW_TIME: u32 = 1500;
pub const LV_USE_TABLE: u32 = 1;
pub const LV_TABLE_COL_MAX: u32 = 12;
pub const LV_USE_TABVIEW: u32 = 1;
pub const LV_TABVIEW_DEF_ANIM_TIME: u32 = 300;
pub const LV_USE_TILEVIEW: u32 = 1;
pub const LV_TILEVIEW_DEF_ANIM_TIME: u32 = 300;
pub const LV_USE_WIN: u32 = 1;
pub const LV_MEMCPY_MEMSET_STD: u32 = 0;
pub const LV_USE_OUTLINE: u32 = 1;
pub const LV_USE_PATTERN: u32 = 1;
pub const LV_USE_VALUE_STR: u32 = 1;
pub const LV_USE_GPU_NXP_PXP: u32 = 0;
pub const LV_USE_GPU_NXP_PXP_AUTO_INIT: u32 = 0;
pub const LV_USE_GPU_NXP_VG_LITE: u32 = 0;
pub const LV_USE_API_EXTENSION_V7: u32 = 1;
pub const LV_BIG_ENDIAN_SYSTEM: u32 = 0;
pub const LV_FONT_MONTSERRAT_8: u32 = 0;
pub const LV_FONT_MONTSERRAT_10: u32 = 0;
pub const LV_FONT_UNSCII_16: u32 = 0;
pub const LV_USE_FONT_COMPRESSED: u32 = 1;
pub const LV_USE_FONT_SUBPX: u32 = 1;
pub const LV_CALENDAR_WEEK_STARTS_MONDAY: u32 = 0;
pub const LV_TABLE_CELL_STYLE_CNT: u32 = 4;
pub const LV_LOG_LEVEL_TRACE: u32 = 0;
pub const LV_LOG_LEVEL_INFO: u32 = 1;
pub const LV_LOG_LEVEL_WARN: u32 = 2;
pub const LV_LOG_LEVEL_ERROR: u32 = 3;
pub const LV_LOG_LEVEL_USER: u32 = 4;
pub const LV_LOG_LEVEL_NONE: u32 = 5;
pub const _LV_LOG_LEVEL_NUM: u32 = 6;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const LV_MEM_BUF_MAX_NUM: u32 = 16;
pub const LV_NO_TASK_READY: u32 = 4294967295;
pub const LV_TRIGO_SIN_MAX: u32 = 32767;
pub const LV_TRIGO_SHIFT: u32 = 15;
pub const LV_BEZIER_VAL_MAX: u32 = 1024;
pub const LV_BEZIER_VAL_SHIFT: u32 = 10;
pub const LV_OPA_MIN: u32 = 2;
pub const LV_OPA_MAX: u32 = 253;
pub const LV_COLOR_SIZE: u32 = 16;
pub const LV_COLOR_MIX_ROUND_OFS: u32 = 128;
pub const _LV_COLOR_HAS_MODERN_CPP: u32 = 0;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const LV_INV_BUF_SIZE: u32 = 32;
pub const LV_SYMBOL_AUDIO: &'static [u8; 4usize] = b"\xEF\x80\x81\0";
pub const LV_SYMBOL_VIDEO: &'static [u8; 4usize] = b"\xEF\x80\x88\0";
pub const LV_SYMBOL_LIST: &'static [u8; 4usize] = b"\xEF\x80\x8B\0";
pub const LV_SYMBOL_OK: &'static [u8; 4usize] = b"\xEF\x80\x8C\0";
pub const LV_SYMBOL_CLOSE: &'static [u8; 4usize] = b"\xEF\x80\x8D\0";
pub const LV_SYMBOL_POWER: &'static [u8; 4usize] = b"\xEF\x80\x91\0";
pub const LV_SYMBOL_SETTINGS: &'static [u8; 4usize] = b"\xEF\x80\x93\0";
pub const LV_SYMBOL_HOME: &'static [u8; 4usize] = b"\xEF\x80\x95\0";
pub const LV_SYMBOL_DOWNLOAD: &'static [u8; 4usize] = b"\xEF\x80\x99\0";
pub const LV_SYMBOL_DRIVE: &'static [u8; 4usize] = b"\xEF\x80\x9C\0";
pub const LV_SYMBOL_REFRESH: &'static [u8; 4usize] = b"\xEF\x80\xA1\0";
pub const LV_SYMBOL_MUTE: &'static [u8; 4usize] = b"\xEF\x80\xA6\0";
pub const LV_SYMBOL_VOLUME_MID: &'static [u8; 4usize] = b"\xEF\x80\xA7\0";
pub const LV_SYMBOL_VOLUME_MAX: &'static [u8; 4usize] = b"\xEF\x80\xA8\0";
pub const LV_SYMBOL_IMAGE: &'static [u8; 4usize] = b"\xEF\x80\xBE\0";
pub const LV_SYMBOL_EDIT: &'static [u8; 4usize] = b"\xEF\x8C\x84\0";
pub const LV_SYMBOL_PREV: &'static [u8; 4usize] = b"\xEF\x81\x88\0";
pub const LV_SYMBOL_PLAY: &'static [u8; 4usize] = b"\xEF\x81\x8B\0";
pub const LV_SYMBOL_PAUSE: &'static [u8; 4usize] = b"\xEF\x81\x8C\0";
pub const LV_SYMBOL_STOP: &'static [u8; 4usize] = b"\xEF\x81\x8D\0";
pub const LV_SYMBOL_NEXT: &'static [u8; 4usize] = b"\xEF\x81\x91\0";
pub const LV_SYMBOL_EJECT: &'static [u8; 4usize] = b"\xEF\x81\x92\0";
pub const LV_SYMBOL_LEFT: &'static [u8; 4usize] = b"\xEF\x81\x93\0";
pub const LV_SYMBOL_RIGHT: &'static [u8; 4usize] = b"\xEF\x81\x94\0";
pub const LV_SYMBOL_PLUS: &'static [u8; 4usize] = b"\xEF\x81\xA7\0";
pub const LV_SYMBOL_MINUS: &'static [u8; 4usize] = b"\xEF\x81\xA8\0";
pub const LV_SYMBOL_EYE_OPEN: &'static [u8; 4usize] = b"\xEF\x81\xAE\0";
pub const LV_SYMBOL_EYE_CLOSE: &'static [u8; 4usize] = b"\xEF\x81\xB0\0";
pub const LV_SYMBOL_WARNING: &'static [u8; 4usize] = b"\xEF\x81\xB1\0";
pub const LV_SYMBOL_SHUFFLE: &'static [u8; 4usize] = b"\xEF\x81\xB4\0";
pub const LV_SYMBOL_UP: &'static [u8; 4usize] = b"\xEF\x81\xB7\0";
pub const LV_SYMBOL_DOWN: &'static [u8; 4usize] = b"\xEF\x81\xB8\0";
pub const LV_SYMBOL_LOOP: &'static [u8; 4usize] = b"\xEF\x81\xB9\0";
pub const LV_SYMBOL_DIRECTORY: &'static [u8; 4usize] = b"\xEF\x81\xBB\0";
pub const LV_SYMBOL_UPLOAD: &'static [u8; 4usize] = b"\xEF\x82\x93\0";
pub const LV_SYMBOL_CALL: &'static [u8; 4usize] = b"\xEF\x82\x95\0";
pub const LV_SYMBOL_CUT: &'static [u8; 4usize] = b"\xEF\x83\x84\0";
pub const LV_SYMBOL_COPY: &'static [u8; 4usize] = b"\xEF\x83\x85\0";
pub const LV_SYMBOL_SAVE: &'static [u8; 4usize] = b"\xEF\x83\x87\0";
pub const LV_SYMBOL_CHARGE: &'static [u8; 4usize] = b"\xEF\x83\xA7\0";
pub const LV_SYMBOL_PASTE: &'static [u8; 4usize] = b"\xEF\x83\xAA\0";
pub const LV_SYMBOL_BELL: &'static [u8; 4usize] = b"\xEF\x83\xB3\0";
pub const LV_SYMBOL_KEYBOARD: &'static [u8; 4usize] = b"\xEF\x84\x9C\0";
pub const LV_SYMBOL_GPS: &'static [u8; 4usize] = b"\xEF\x84\xA4\0";
pub const LV_SYMBOL_FILE: &'static [u8; 4usize] = b"\xEF\x85\x9B\0";
pub const LV_SYMBOL_WIFI: &'static [u8; 4usize] = b"\xEF\x87\xAB\0";
pub const LV_SYMBOL_BATTERY_FULL: &'static [u8; 4usize] = b"\xEF\x89\x80\0";
pub const LV_SYMBOL_BATTERY_3: &'static [u8; 4usize] = b"\xEF\x89\x81\0";
pub const LV_SYMBOL_BATTERY_2: &'static [u8; 4usize] = b"\xEF\x89\x82\0";
pub const LV_SYMBOL_BATTERY_1: &'static [u8; 4usize] = b"\xEF\x89\x83\0";
pub const LV_SYMBOL_BATTERY_EMPTY: &'static [u8; 4usize] = b"\xEF\x89\x84\0";
pub const LV_SYMBOL_USB: &'static [u8; 4usize] = b"\xEF\x8A\x87\0";
pub const LV_SYMBOL_BLUETOOTH: &'static [u8; 4usize] = b"\xEF\x8A\x93\0";
pub const LV_SYMBOL_TRASH: &'static [u8; 4usize] = b"\xEF\x8B\xAD\0";
pub const LV_SYMBOL_BACKSPACE: &'static [u8; 4usize] = b"\xEF\x95\x9A\0";
pub const LV_SYMBOL_SD_CARD: &'static [u8; 4usize] = b"\xEF\x9F\x82\0";
pub const LV_SYMBOL_NEW_LINE: &'static [u8; 4usize] = b"\xEF\xA2\xA2\0";
pub const LV_SYMBOL_DUMMY: &'static [u8; 4usize] = b"\xEF\xA3\xBF\0";
pub const LV_SYMBOL_BULLET: &'static [u8; 4usize] = b"\xE2\x80\xA2\0";
pub const LV_ANIM_REPEAT_INFINITE: u32 = 65535;
pub const LV_MASK_ID_INV: i32 = -1;
pub const _LV_MASK_MAX_NUM: u32 = 16;
pub const LV_RADIUS_CIRCLE: u32 = 32767;
pub const LV_DEBUG_STYLE_SENTINEL_VALUE: u32 = 579381998;
pub const LV_DEBUG_STYLE_LIST_SENTINEL_VALUE: u32 = 2574765243;
pub const LV_STYLE_ID_MASK: u32 = 255;
pub const LV_STYLE_ATTR_NONE: u32 = 0;
pub const LV_STYLE_ATTR_INHERIT: u32 = 128;
pub const _LV_STYLE_CLOSING_PROP: u32 = 255;
pub const LV_STYLE_TRANS_NUM_MAX: u32 = 6;
pub const LV_STYLE_PROP_ALL: u32 = 255;
pub const LV_STYLE_ID_VALUE: u32 = 0;
pub const LV_STYLE_ID_COLOR: u32 = 9;
pub const LV_STYLE_ID_OPA: u32 = 12;
pub const LV_STYLE_ID_PTR: u32 = 14;
pub const LV_STYLE_STATE_POS: u32 = 8;
pub const LV_STYLE_STATE_MASK: u32 = 32512;
pub const LV_STYLE_INHERIT_MASK: u32 = 32768;
pub const LV_BIDI_LRO: &'static [u8; 4usize] = b"\xE2\x80\xAD\0";
pub const LV_BIDI_RLO: &'static [u8; 4usize] = b"\xE2\x80\xAE\0";
pub const __GNUC_VA_LIST: u32 = 1;
pub const LV_TXT_ENC_UTF8: u32 = 1;
pub const LV_TXT_ENC_ASCII: u32 = 2;
pub const LV_DRAW_LABEL_NO_TXT_SEL: u32 = 65535;
pub const LV_IMG_PX_SIZE_ALPHA_BYTE: u32 = 3;
pub const LV_IMG_ZOOM_NONE: u32 = 256;
pub const _LV_TRANSFORM_TRIGO_SHIFT: u32 = 10;
pub const _LV_ZOOM_INV_UPSCALE: u32 = 5;
pub const LV_FS_MAX_FN_LENGTH: u32 = 64;
pub const LV_FS_MAX_PATH_LENGTH: u32 = 256;
pub const LV_MAX_ANCESTOR_NUM: u32 = 8;
pub const LV_EXT_CLICK_AREA_OFF: u32 = 0;
pub const LV_EXT_CLICK_AREA_TINY: u32 = 1;
pub const LV_EXT_CLICK_AREA_FULL: u32 = 2;
pub const _LV_OBJ_PART_VIRTUAL_FIRST: u32 = 1;
pub const _LV_OBJ_PART_REAL_FIRST: u32 = 64;
pub const LV_LABEL_DOT_NUM: u32 = 3;
pub const LV_LABEL_POS_LAST: u32 = 65535;
pub const LV_LABEL_TEXT_SEL_OFF: u32 = 65535;
pub const LV_CHART_TICK_LENGTH_AUTO: u32 = 255;
pub const LV_BAR_ANIM_STATE_START: u32 = 0;
pub const LV_BAR_ANIM_STATE_END: u32 = 256;
pub const LV_BAR_ANIM_STATE_INV: i32 = -1;
pub const LV_BAR_ANIM_STATE_NORM: u32 = 8;
pub const LV_BTNMATRIX_WIDTH_MASK: u32 = 7;
pub const LV_BTNMATRIX_BTN_NONE: u32 = 65535;
pub const LV_DROPDOWN_POS_LAST: u32 = 65535;
pub const LV_TEXTAREA_CURSOR_LAST: u32 = 32767;
pub const LV_SPINBOX_MAX_DIGIT_COUNT: u32 = 10;
pub type va_list = *mut cty::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut cty::c_char, ...);
}
pub type size_t = cty::c_ulonglong;
pub type __vcrt_bool = bool;
pub type wchar_t = cty::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = cty::c_schar;
pub type int_least16_t = cty::c_short;
pub type int_least32_t = cty::c_int;
pub type int_least64_t = cty::c_longlong;
pub type uint_least8_t = cty::c_uchar;
pub type uint_least16_t = cty::c_ushort;
pub type uint_least32_t = cty::c_uint;
pub type uint_least64_t = cty::c_ulonglong;
pub type int_fast8_t = cty::c_schar;
pub type int_fast16_t = cty::c_int;
pub type int_fast32_t = cty::c_int;
pub type int_fast64_t = cty::c_longlong;
pub type uint_fast8_t = cty::c_uchar;
pub type uint_fast16_t = cty::c_uint;
pub type uint_fast32_t = cty::c_uint;
pub type uint_fast64_t = cty::c_ulonglong;
pub type intmax_t = cty::c_longlong;
pub type uintmax_t = cty::c_ulonglong;
pub type lv_coord_t = i16;
pub type lv_anim_user_data_t = *mut cty::c_void;
pub type lv_group_user_data_t = *mut cty::c_void;
pub type lv_fs_drv_user_data_t = *mut cty::c_void;
pub type lv_img_decoder_user_data_t = *mut cty::c_void;
pub type lv_disp_drv_user_data_t = *mut cty::c_void;
pub type lv_indev_drv_user_data_t = *mut cty::c_void;
pub type lv_font_user_data_t = *mut cty::c_void;
pub type lv_obj_user_data_t = *mut cty::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _silence_gcc_warning {
    _unused: [u8; 0],
}
pub type lv_log_level_t = i8;
pub type max_align_t = f64;
pub const LV_RES_INV: cty::c_int = 0;
pub const LV_RES_OK: cty::c_int = 1;
pub type _bindgen_ty_1 = cty::c_int;
pub type lv_res_t = u8;
pub type lv_uintptr_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_mem_monitor_t {
    pub total_size: u32,
    pub free_cnt: u32,
    pub free_size: u32,
    pub free_biggest_size: u32,
    pub used_cnt: u32,
    pub max_used: u32,
    pub used_pct: u8,
    pub frag_pct: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_mem_buf_t {
    pub p: *mut cty::c_void,
    pub size: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 5usize],
}
impl lv_mem_buf_t {
    #[inline]
    pub fn used(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_used(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(used: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let used: u8 = unsafe { ::core::mem::transmute(used) };
            used as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_mem_buf_arr_t = [lv_mem_buf_t; 16usize];
extern "C" {
    pub static mut _lv_mem_buf: lv_mem_buf_arr_t;
}
extern "C" {
    pub fn _lv_mem_init();
}
extern "C" {
    pub fn _lv_mem_deinit();
}
extern "C" {
    pub fn lv_mem_alloc(size: size_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lv_mem_free(data: *const cty::c_void);
}
extern "C" {
    pub fn lv_mem_realloc(data_p: *mut cty::c_void, new_size: size_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lv_mem_defrag();
}
extern "C" {
    pub fn lv_mem_test() -> lv_res_t;
}
extern "C" {
    pub fn lv_mem_monitor(mon_p: *mut lv_mem_monitor_t);
}
extern "C" {
    pub fn _lv_mem_get_size(data: *const cty::c_void) -> u32;
}
extern "C" {
    pub fn _lv_mem_buf_get(size: u32) -> *mut cty::c_void;
}
extern "C" {
    pub fn _lv_mem_buf_release(p: *mut cty::c_void);
}
extern "C" {
    pub fn _lv_mem_buf_free_all();
}
extern "C" {
    pub fn _lv_memcpy(
        dst: *mut cty::c_void,
        src: *const cty::c_void,
        len: size_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn _lv_memset(dst: *mut cty::c_void, v: u8, len: size_t);
}
extern "C" {
    pub fn _lv_memset_00(dst: *mut cty::c_void, len: size_t);
}
extern "C" {
    pub fn _lv_memset_ff(dst: *mut cty::c_void, len: size_t);
}
pub type lv_ll_node_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_ll_t {
    pub n_size: u32,
    pub head: *mut lv_ll_node_t,
    pub tail: *mut lv_ll_node_t,
}
extern "C" {
    pub fn _lv_ll_init(ll_p: *mut lv_ll_t, node_size: u32);
}
extern "C" {
    pub fn _lv_ll_ins_head(ll_p: *mut lv_ll_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn _lv_ll_ins_prev(ll_p: *mut lv_ll_t, n_act: *mut cty::c_void) -> *mut cty::c_void;
}
extern "C" {
    pub fn _lv_ll_ins_tail(ll_p: *mut lv_ll_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn _lv_ll_remove(ll_p: *mut lv_ll_t, node_p: *mut cty::c_void);
}
extern "C" {
    pub fn _lv_ll_clear(ll_p: *mut lv_ll_t);
}
extern "C" {
    pub fn _lv_ll_chg_list(
        ll_ori_p: *mut lv_ll_t,
        ll_new_p: *mut lv_ll_t,
        node: *mut cty::c_void,
        head: bool,
    );
}
extern "C" {
    pub fn _lv_ll_get_head(ll_p: *const lv_ll_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn _lv_ll_get_tail(ll_p: *const lv_ll_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn _lv_ll_get_next(ll_p: *const lv_ll_t, n_act: *const cty::c_void) -> *mut cty::c_void;
}
extern "C" {
    pub fn _lv_ll_get_prev(ll_p: *const lv_ll_t, n_act: *const cty::c_void) -> *mut cty::c_void;
}
extern "C" {
    pub fn _lv_ll_get_len(ll_p: *const lv_ll_t) -> u32;
}
extern "C" {
    pub fn _lv_ll_move_before(
        ll_p: *mut lv_ll_t,
        n_act: *mut cty::c_void,
        n_after: *mut cty::c_void,
    );
}
extern "C" {
    pub fn _lv_ll_is_empty(ll_p: *mut lv_ll_t) -> bool;
}
pub type lv_task_cb_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_task_t)>;
pub const LV_TASK_PRIO_OFF: cty::c_int = 0;
pub const LV_TASK_PRIO_LOWEST: cty::c_int = 1;
pub const LV_TASK_PRIO_LOW: cty::c_int = 2;
pub const LV_TASK_PRIO_MID: cty::c_int = 3;
pub const LV_TASK_PRIO_HIGH: cty::c_int = 4;
pub const LV_TASK_PRIO_HIGHEST: cty::c_int = 5;
pub const _LV_TASK_PRIO_NUM: cty::c_int = 6;
pub type _bindgen_ty_2 = cty::c_int;
pub type lv_task_prio_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_task_t {
    pub period: u32,
    pub last_run: u32,
    pub task_cb: lv_task_cb_t,
    pub user_data: *mut cty::c_void,
    pub repeat_count: i32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl _lv_task_t {
    #[inline]
    pub fn prio(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_prio(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(prio: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let prio: u8 = unsafe { ::core::mem::transmute(prio) };
            prio as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_task_t = _lv_task_t;
extern "C" {
    pub fn _lv_task_core_init();
}
extern "C" {
    pub fn lv_task_handler() -> u32;
}
extern "C" {
    pub fn lv_task_create_basic() -> *mut lv_task_t;
}
extern "C" {
    pub fn lv_task_create(
        task_xcb: lv_task_cb_t,
        period: u32,
        prio: lv_task_prio_t,
        user_data: *mut cty::c_void,
    ) -> *mut lv_task_t;
}
extern "C" {
    pub fn lv_task_del(task: *mut lv_task_t);
}
extern "C" {
    pub fn lv_task_set_cb(task: *mut lv_task_t, task_cb: lv_task_cb_t);
}
extern "C" {
    pub fn lv_task_set_prio(task: *mut lv_task_t, prio: lv_task_prio_t);
}
extern "C" {
    pub fn lv_task_set_period(task: *mut lv_task_t, period: u32);
}
extern "C" {
    pub fn lv_task_ready(task: *mut lv_task_t);
}
extern "C" {
    pub fn lv_task_set_repeat_count(task: *mut lv_task_t, repeat_count: i32);
}
extern "C" {
    pub fn lv_task_reset(task: *mut lv_task_t);
}
extern "C" {
    pub fn lv_task_enable(en: bool);
}
extern "C" {
    pub fn lv_task_get_idle() -> u8;
}
extern "C" {
    pub fn lv_task_get_next(task: *mut lv_task_t) -> *mut lv_task_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_sqrt_res_t {
    pub i: u16,
    pub f: u16,
}
extern "C" {
    pub fn _lv_trigo_sin(angle: i16) -> i16;
}
extern "C" {
    pub fn _lv_bezier3(t: u32, u0: u32, u1: u32, u2: u32, u3: u32) -> u32;
}
extern "C" {
    pub fn _lv_atan2(x: cty::c_int, y: cty::c_int) -> u16;
}
extern "C" {
    pub fn _lv_sqrt(x: u32, q: *mut lv_sqrt_res_t, mask: u32);
}
extern "C" {
    pub fn _lv_pow(base: i64, exp: i8) -> i64;
}
extern "C" {
    pub fn _lv_map(x: i32, min_in: i32, max_in: i32, min: i32, max: i32) -> i32;
}
pub type lv_async_cb_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>;
extern "C" {
    pub fn lv_async_call(async_xcb: lv_async_cb_t, user_data: *mut cty::c_void) -> lv_res_t;
}
pub const LV_OPA_TRANSP: cty::c_int = 0;
pub const LV_OPA_0: cty::c_int = 0;
pub const LV_OPA_10: cty::c_int = 25;
pub const LV_OPA_20: cty::c_int = 51;
pub const LV_OPA_30: cty::c_int = 76;
pub const LV_OPA_40: cty::c_int = 102;
pub const LV_OPA_50: cty::c_int = 127;
pub const LV_OPA_60: cty::c_int = 153;
pub const LV_OPA_70: cty::c_int = 178;
pub const LV_OPA_80: cty::c_int = 204;
pub const LV_OPA_90: cty::c_int = 229;
pub const LV_OPA_100: cty::c_int = 255;
pub const LV_OPA_COVER: cty::c_int = 255;
pub type _bindgen_ty_3 = cty::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union lv_color1_t {
    pub full: u8,
    pub ch: lv_color1_t__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Copy, Clone)]
pub union lv_color1_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl lv_color1_t__bindgen_ty_1 {
    #[inline]
    pub fn blue(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_blue(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn green(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_green(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn red(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_red(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(blue: u8, green: u8, red: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let blue: u8 = unsafe { ::core::mem::transmute(blue) };
            blue as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let green: u8 = unsafe { ::core::mem::transmute(green) };
            green as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let red: u8 = unsafe { ::core::mem::transmute(red) };
            red as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lv_color8_t {
    pub ch: lv_color8_t__bindgen_ty_1,
    pub full: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct lv_color8_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl lv_color8_t__bindgen_ty_1 {
    #[inline]
    pub fn blue(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_blue(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn green(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_green(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn red(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_red(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(blue: u8, green: u8, red: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let blue: u8 = unsafe { ::core::mem::transmute(blue) };
            blue as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let green: u8 = unsafe { ::core::mem::transmute(green) };
            green as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let red: u8 = unsafe { ::core::mem::transmute(red) };
            red as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lv_color16_t {
    pub ch: lv_color16_t__bindgen_ty_1,
    pub full: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct lv_color16_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl lv_color16_t__bindgen_ty_1 {
    #[inline]
    pub fn blue(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_blue(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn green(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_green(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn red(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_red(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(blue: u16, green: u16, red: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let blue: u16 = unsafe { ::core::mem::transmute(blue) };
            blue as u64
        });
        __bindgen_bitfield_unit.set(5usize, 6u8, {
            let green: u16 = unsafe { ::core::mem::transmute(green) };
            green as u64
        });
        __bindgen_bitfield_unit.set(11usize, 5u8, {
            let red: u16 = unsafe { ::core::mem::transmute(red) };
            red as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lv_color32_t {
    pub ch: lv_color32_t__bindgen_ty_1,
    pub full: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_color32_t__bindgen_ty_1 {
    pub blue: u8,
    pub green: u8,
    pub red: u8,
    pub alpha: u8,
}
pub type lv_color_int_t = u16;
pub type lv_color_t = lv_color16_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_color_hsv_t {
    pub h: u16,
    pub s: u8,
    pub v: u8,
}
pub type lv_opa_t = u8;
extern "C" {
    pub fn lv_color_fill(buf: *mut lv_color_t, color: lv_color_t, px_num: u32);
}
extern "C" {
    pub fn lv_color_lighten(c: lv_color_t, lvl: lv_opa_t) -> lv_color_t;
}
extern "C" {
    pub fn lv_color_darken(c: lv_color_t, lvl: lv_opa_t) -> lv_color_t;
}
extern "C" {
    pub fn lv_color_hsv_to_rgb(h: u16, s: u8, v: u8) -> lv_color_t;
}
extern "C" {
    pub fn lv_color_rgb_to_hsv(r8: u8, g8: u8, b8: u8) -> lv_color_hsv_t;
}
extern "C" {
    pub fn lv_color_to_hsv(color: lv_color_t) -> lv_color_hsv_t;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn();
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: cty::c_uint,
        _Reserved: usize,
    );
}
pub type errno_t = cty::c_int;
pub type wint_t = cty::c_ushort;
pub type wctype_t = cty::c_ushort;
pub type __time32_t = cty::c_long;
pub type __time64_t = cty::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const cty::c_ushort,
    pub _locale_mb_cur_max: cty::c_int,
    pub _locale_lc_codepage: cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: cty::c_ulong,
    pub _Byte: cty::c_ushort,
    pub _State: cty::c_ushort,
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = size_t;
extern "C" {
    pub fn _errno() -> *mut cty::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: cty::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut cty::c_int) -> errno_t;
}
extern "C" {
    pub fn __doserrno() -> *mut cty::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: cty::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut cty::c_ulong) -> errno_t;
}
extern "C" {
    pub fn memchr(
        _Buf: *const cty::c_void,
        _Val: cty::c_int,
        _MaxCount: cty::c_ulonglong,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memcmp(
        _Buf1: *const cty::c_void,
        _Buf2: *const cty::c_void,
        _Size: cty::c_ulonglong,
    ) -> cty::c_int;
}
extern "C" {
    pub fn memcpy(
        _Dst: *mut cty::c_void,
        _Src: *const cty::c_void,
        _Size: cty::c_ulonglong,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memmove(
        _Dst: *mut cty::c_void,
        _Src: *const cty::c_void,
        _Size: cty::c_ulonglong,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memset(
        _Dst: *mut cty::c_void,
        _Val: cty::c_int,
        _Size: cty::c_ulonglong,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn strchr(_Str: *const cty::c_char, _Val: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strrchr(_Str: *const cty::c_char, _Ch: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strstr(_Str: *const cty::c_char, _SubStr: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn wcschr(_Str: *const cty::c_ushort, _Ch: cty::c_ushort) -> *mut cty::c_ushort;
}
extern "C" {
    pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _memicmp(
        _Buf1: *const cty::c_void,
        _Buf2: *const cty::c_void,
        _Size: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _memicmp_l(
        _Buf1: *const cty::c_void,
        _Buf2: *const cty::c_void,
        _Size: size_t,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn memccpy(
        _Dst: *mut cty::c_void,
        _Src: *const cty::c_void,
        _Val: cty::c_int,
        _Size: cty::c_ulonglong,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memicmp(
        _Buf1: *const cty::c_void,
        _Buf2: *const cty::c_void,
        _Size: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn wcscat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(_String1: *const cty::c_ushort, _String2: *const cty::c_ushort) -> cty::c_int;
}
extern "C" {
    pub fn wcscpy(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(_String: *const wchar_t, _Control: *const wchar_t) -> size_t;
}
extern "C" {
    pub fn wcslen(_String: *const cty::c_ushort) -> cty::c_ulonglong;
}
extern "C" {
    pub fn wcsnlen(_Source: *const wchar_t, _MaxCount: size_t) -> size_t;
}
extern "C" {
    pub fn wcsncat(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: size_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncmp(
        _String1: *const cty::c_ushort,
        _String2: *const cty::c_ushort,
        _MaxCount: cty::c_ulonglong,
    ) -> cty::c_int;
}
extern "C" {
    pub fn wcsncpy(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: size_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcspbrk(_String: *const wchar_t, _Control: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsspn(_String: *const wchar_t, _Control: *const wchar_t) -> size_t;
}
extern "C" {
    pub fn wcstok(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror(_ErrorNumber: cty::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: size_t,
        _ErrorNumber: cty::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn __wcserror(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn __wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: size_t,
        _ErrorMessage: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _wcsnset_s(
        _Destination: *mut wchar_t,
        _SizeInWords: size_t,
        _Value: wchar_t,
        _MaxCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsset_s(_Destination: *mut wchar_t, _SizeInWords: size_t, _Value: wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s(_String: *mut wchar_t, _SizeInWords: size_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s_l(_String: *mut wchar_t, _SizeInWords: size_t, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s(_String: *mut wchar_t, _Size: size_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s_l(_String: *mut wchar_t, _Size: size_t, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsxfrm(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn _wcsxfrm_l(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcscoll(_String1: *const wchar_t, _String2: *const wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn _wcscoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _wcsncoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _wcsnicoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: size_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn strcpy_s(
        _Destination: *mut cty::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const cty::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strcat_s(
        _Destination: *mut cty::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const cty::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror_s(
        _Buffer: *mut cty::c_char,
        _SizeInBytes: size_t,
        _ErrorNumber: cty::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn strncat_s(
        _Destination: *mut cty::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const cty::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strncpy_s(
        _Destination: *mut cty::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const cty::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strtok_s(
        _String: *mut cty::c_char,
        _Delimiter: *const cty::c_char,
        _Context: *mut *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _memccpy(
        _Dst: *mut cty::c_void,
        _Src: *const cty::c_void,
        _Val: cty::c_int,
        _MaxCount: size_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn strcat(_Destination: *mut cty::c_char, _Source: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcmp(_Str1: *const cty::c_char, _Str2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _strcmpi(_String1: *const cty::c_char, _String2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strcoll(_String1: *const cty::c_char, _String2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _strcoll_l(
        _String1: *const cty::c_char,
        _String2: *const cty::c_char,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strcpy(_Destination: *mut cty::c_char, _Source: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcspn(_Str: *const cty::c_char, _Control: *const cty::c_char) -> cty::c_ulonglong;
}
extern "C" {
    pub fn _strdup(_Source: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _strerror(_ErrorMessage: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _strerror_s(
        _Buffer: *mut cty::c_char,
        _SizeInBytes: size_t,
        _ErrorMessage: *const cty::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror(_ErrorMessage: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn _stricmp(_String1: *const cty::c_char, _String2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _stricoll(_String1: *const cty::c_char, _String2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _stricoll_l(
        _String1: *const cty::c_char,
        _String2: *const cty::c_char,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _stricmp_l(
        _String1: *const cty::c_char,
        _String2: *const cty::c_char,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strlen(_Str: *const cty::c_char) -> cty::c_ulonglong;
}
extern "C" {
    pub fn _strlwr_s(_String: *mut cty::c_char, _Size: size_t) -> errno_t;
}
extern "C" {
    pub fn _strlwr(_String: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _strlwr_s_l(_String: *mut cty::c_char, _Size: size_t, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _strlwr_l(_String: *mut cty::c_char, _Locale: _locale_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn strncat(
        _Destination: *mut cty::c_char,
        _Source: *const cty::c_char,
        _Count: cty::c_ulonglong,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strncmp(
        _Str1: *const cty::c_char,
        _Str2: *const cty::c_char,
        _MaxCount: cty::c_ulonglong,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _strnicmp(
        _String1: *const cty::c_char,
        _String2: *const cty::c_char,
        _MaxCount: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _strnicmp_l(
        _String1: *const cty::c_char,
        _String2: *const cty::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _strnicoll(
        _String1: *const cty::c_char,
        _String2: *const cty::c_char,
        _MaxCount: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _strnicoll_l(
        _String1: *const cty::c_char,
        _String2: *const cty::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _strncoll(
        _String1: *const cty::c_char,
        _String2: *const cty::c_char,
        _MaxCount: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _strncoll_l(
        _String1: *const cty::c_char,
        _String2: *const cty::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn __strncnt(_String: *const cty::c_char, _Count: size_t) -> size_t;
}
extern "C" {
    pub fn strncpy(
        _Destination: *mut cty::c_char,
        _Source: *const cty::c_char,
        _Count: cty::c_ulonglong,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strnlen(_String: *const cty::c_char, _MaxCount: size_t) -> size_t;
}
extern "C" {
    pub fn _strnset_s(
        _String: *mut cty::c_char,
        _SizeInBytes: size_t,
        _Value: cty::c_int,
        _MaxCount: size_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strnset(
        _Destination: *mut cty::c_char,
        _Value: cty::c_int,
        _Count: size_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strpbrk(_Str: *const cty::c_char, _Control: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _strrev(_Str: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _strset_s(
        _Destination: *mut cty::c_char,
        _DestinationSize: size_t,
        _Value: cty::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _strset(_Destination: *mut cty::c_char, _Value: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strspn(_Str: *const cty::c_char, _Control: *const cty::c_char) -> cty::c_ulonglong;
}
extern "C" {
    pub fn strtok(_String: *mut cty::c_char, _Delimiter: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _strupr_s(_String: *mut cty::c_char, _Size: size_t) -> errno_t;
}
extern "C" {
    pub fn _strupr(_String: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _strupr_s_l(_String: *mut cty::c_char, _Size: size_t, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _strupr_l(_String: *mut cty::c_char, _Locale: _locale_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn strxfrm(
        _Destination: *mut cty::c_char,
        _Source: *const cty::c_char,
        _MaxCount: cty::c_ulonglong,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn _strxfrm_l(
        _Destination: *mut cty::c_char,
        _Source: *const cty::c_char,
        _MaxCount: size_t,
        _Locale: _locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(_String: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcmpi(_String1: *const cty::c_char, _String2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn stricmp(_String1: *const cty::c_char, _String2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strlwr(_String: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strnicmp(
        _String1: *const cty::c_char,
        _String2: *const cty::c_char,
        _MaxCount: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strnset(
        _String: *mut cty::c_char,
        _Value: cty::c_int,
        _MaxCount: size_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strrev(_String: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strset(_String: *mut cty::c_char, _Value: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strupr(_String: *mut cty::c_char) -> *mut cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_point_t {
    pub x: lv_coord_t,
    pub y: lv_coord_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_area_t {
    pub x1: lv_coord_t,
    pub y1: lv_coord_t,
    pub x2: lv_coord_t,
    pub y2: lv_coord_t,
}
pub const LV_ALIGN_CENTER: cty::c_int = 0;
pub const LV_ALIGN_IN_TOP_LEFT: cty::c_int = 1;
pub const LV_ALIGN_IN_TOP_MID: cty::c_int = 2;
pub const LV_ALIGN_IN_TOP_RIGHT: cty::c_int = 3;
pub const LV_ALIGN_IN_BOTTOM_LEFT: cty::c_int = 4;
pub const LV_ALIGN_IN_BOTTOM_MID: cty::c_int = 5;
pub const LV_ALIGN_IN_BOTTOM_RIGHT: cty::c_int = 6;
pub const LV_ALIGN_IN_LEFT_MID: cty::c_int = 7;
pub const LV_ALIGN_IN_RIGHT_MID: cty::c_int = 8;
pub const LV_ALIGN_OUT_TOP_LEFT: cty::c_int = 9;
pub const LV_ALIGN_OUT_TOP_MID: cty::c_int = 10;
pub const LV_ALIGN_OUT_TOP_RIGHT: cty::c_int = 11;
pub const LV_ALIGN_OUT_BOTTOM_LEFT: cty::c_int = 12;
pub const LV_ALIGN_OUT_BOTTOM_MID: cty::c_int = 13;
pub const LV_ALIGN_OUT_BOTTOM_RIGHT: cty::c_int = 14;
pub const LV_ALIGN_OUT_LEFT_TOP: cty::c_int = 15;
pub const LV_ALIGN_OUT_LEFT_MID: cty::c_int = 16;
pub const LV_ALIGN_OUT_LEFT_BOTTOM: cty::c_int = 17;
pub const LV_ALIGN_OUT_RIGHT_TOP: cty::c_int = 18;
pub const LV_ALIGN_OUT_RIGHT_MID: cty::c_int = 19;
pub const LV_ALIGN_OUT_RIGHT_BOTTOM: cty::c_int = 20;
pub type _bindgen_ty_4 = cty::c_int;
pub type lv_align_t = u8;
extern "C" {
    pub fn lv_area_set(
        area_p: *mut lv_area_t,
        x1: lv_coord_t,
        y1: lv_coord_t,
        x2: lv_coord_t,
        y2: lv_coord_t,
    );
}
extern "C" {
    pub fn lv_area_set_width(area_p: *mut lv_area_t, w: lv_coord_t);
}
extern "C" {
    pub fn lv_area_set_height(area_p: *mut lv_area_t, h: lv_coord_t);
}
extern "C" {
    pub fn _lv_area_set_pos(area_p: *mut lv_area_t, x: lv_coord_t, y: lv_coord_t);
}
extern "C" {
    pub fn lv_area_get_size(area_p: *const lv_area_t) -> u32;
}
extern "C" {
    pub fn _lv_area_intersect(
        res_p: *mut lv_area_t,
        a1_p: *const lv_area_t,
        a2_p: *const lv_area_t,
    ) -> bool;
}
extern "C" {
    pub fn _lv_area_join(a_res_p: *mut lv_area_t, a1_p: *const lv_area_t, a2_p: *const lv_area_t);
}
extern "C" {
    pub fn _lv_area_is_point_on(
        a_p: *const lv_area_t,
        p_p: *const lv_point_t,
        radius: lv_coord_t,
    ) -> bool;
}
extern "C" {
    pub fn _lv_area_is_on(a1_p: *const lv_area_t, a2_p: *const lv_area_t) -> bool;
}
extern "C" {
    pub fn _lv_area_is_in(
        ain_p: *const lv_area_t,
        aholder_p: *const lv_area_t,
        radius: lv_coord_t,
    ) -> bool;
}
extern "C" {
    pub fn _lv_area_align(
        base: *const lv_area_t,
        to_align: *const lv_area_t,
        align: lv_align_t,
        res: *mut lv_point_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_disp_buf_t {
    pub buf1: *mut cty::c_void,
    pub buf2: *mut cty::c_void,
    pub buf_act: *mut cty::c_void,
    pub size: u32,
    pub area: lv_area_t,
    pub flushing: cty::c_int,
    pub flushing_last: cty::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl lv_disp_buf_t {
    #[inline]
    pub fn last_area(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_area(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn last_part(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_last_part(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(last_area: u32, last_part: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let last_area: u32 = unsafe { ::core::mem::transmute(last_area) };
            last_area as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let last_part: u32 = unsafe { ::core::mem::transmute(last_part) };
            last_part as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _disp_drv_t {
    pub hor_res: lv_coord_t,
    pub ver_res: lv_coord_t,
    pub buffer: *mut lv_disp_buf_t,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub flush_cb: ::core::option::Option<
        unsafe extern "C" fn(
            disp_drv: *mut _disp_drv_t,
            area: *const lv_area_t,
            color_p: *mut lv_color_t,
        ),
    >,
    pub rounder_cb: ::core::option::Option<
        unsafe extern "C" fn(disp_drv: *mut _disp_drv_t, area: *mut lv_area_t),
    >,
    pub set_px_cb: ::core::option::Option<
        unsafe extern "C" fn(
            disp_drv: *mut _disp_drv_t,
            buf: *mut u8,
            buf_w: lv_coord_t,
            x: lv_coord_t,
            y: lv_coord_t,
            color: lv_color_t,
            opa: lv_opa_t,
        ),
    >,
    pub monitor_cb: ::core::option::Option<
        unsafe extern "C" fn(disp_drv: *mut _disp_drv_t, time: u32, px: u32),
    >,
    pub wait_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv: *mut _disp_drv_t)>,
    pub clean_dcache_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv: *mut _disp_drv_t)>,
    pub gpu_wait_cb: ::core::option::Option<unsafe extern "C" fn(disp_drv: *mut _disp_drv_t)>,
    pub gpu_blend_cb: ::core::option::Option<
        unsafe extern "C" fn(
            disp_drv: *mut _disp_drv_t,
            dest: *mut lv_color_t,
            src: *const lv_color_t,
            length: u32,
            opa: lv_opa_t,
        ),
    >,
    pub gpu_fill_cb: ::core::option::Option<
        unsafe extern "C" fn(
            disp_drv: *mut _disp_drv_t,
            dest_buf: *mut lv_color_t,
            dest_width: lv_coord_t,
            fill_area: *const lv_area_t,
            color: lv_color_t,
        ),
    >,
    pub color_chroma_key: lv_color_t,
    pub user_data: lv_disp_drv_user_data_t,
}
impl _disp_drv_t {
    #[inline]
    pub fn antialiasing(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_antialiasing(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rotated(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rotated(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dpi(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_dpi(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        antialiasing: u32,
        rotated: u32,
        dpi: u32,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let antialiasing: u32 = unsafe { ::core::mem::transmute(antialiasing) };
            antialiasing as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rotated: u32 = unsafe { ::core::mem::transmute(rotated) };
            rotated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 10u8, {
            let dpi: u32 = unsafe { ::core::mem::transmute(dpi) };
            dpi as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_disp_drv_t = _disp_drv_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _disp_t {
    pub driver: lv_disp_drv_t,
    pub refr_task: *mut lv_task_t,
    pub scr_ll: lv_ll_t,
    pub act_scr: *mut _lv_obj_t,
    pub prev_scr: *mut _lv_obj_t,
    pub scr_to_load: *mut _lv_obj_t,
    pub top_layer: *mut _lv_obj_t,
    pub sys_layer: *mut _lv_obj_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub bg_color: lv_color_t,
    pub bg_img: *const cty::c_void,
    pub bg_opa: lv_opa_t,
    pub inv_areas: [lv_area_t; 32usize],
    pub inv_area_joined: [u8; 32usize],
    pub _bitfield_align_2: [u16; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u32,
    pub last_activity_time: u32,
}
impl _disp_t {
    #[inline]
    pub fn del_prev(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_del_prev(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(del_prev: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let del_prev: u8 = unsafe { ::core::mem::transmute(del_prev) };
            del_prev as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn inv_p(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_inv_p(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(inv_p: u32) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let inv_p: u32 = unsafe { ::core::mem::transmute(inv_p) };
            inv_p as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_disp_t = _disp_t;
pub const lv_disp_size_t_LV_DISP_SIZE_SMALL: lv_disp_size_t = 0;
pub const lv_disp_size_t_LV_DISP_SIZE_MEDIUM: lv_disp_size_t = 1;
pub const lv_disp_size_t_LV_DISP_SIZE_LARGE: lv_disp_size_t = 2;
pub const lv_disp_size_t_LV_DISP_SIZE_EXTRA_LARGE: lv_disp_size_t = 3;
pub type lv_disp_size_t = cty::c_int;
extern "C" {
    pub fn lv_disp_drv_init(driver: *mut lv_disp_drv_t);
}
extern "C" {
    pub fn lv_disp_buf_init(
        disp_buf: *mut lv_disp_buf_t,
        buf1: *mut cty::c_void,
        buf2: *mut cty::c_void,
        size_in_px_cnt: u32,
    );
}
extern "C" {
    pub fn lv_disp_drv_register(driver: *mut lv_disp_drv_t) -> *mut lv_disp_t;
}
extern "C" {
    pub fn lv_disp_drv_update(disp: *mut lv_disp_t, new_drv: *mut lv_disp_drv_t);
}
extern "C" {
    pub fn lv_disp_remove(disp: *mut lv_disp_t);
}
extern "C" {
    pub fn lv_disp_set_default(disp: *mut lv_disp_t);
}
extern "C" {
    pub fn lv_disp_get_default() -> *mut lv_disp_t;
}
extern "C" {
    pub fn lv_disp_get_hor_res(disp: *mut lv_disp_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_disp_get_ver_res(disp: *mut lv_disp_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_disp_get_antialiasing(disp: *mut lv_disp_t) -> bool;
}
extern "C" {
    pub fn lv_disp_get_dpi(disp: *mut lv_disp_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_disp_get_size_category(disp: *mut lv_disp_t) -> lv_disp_size_t;
}
extern "C" {
    pub fn lv_disp_flush_ready(disp_drv: *mut lv_disp_drv_t);
}
extern "C" {
    pub fn lv_disp_flush_is_last(disp_drv: *mut lv_disp_drv_t) -> bool;
}
extern "C" {
    pub fn lv_disp_get_next(disp: *mut lv_disp_t) -> *mut lv_disp_t;
}
extern "C" {
    pub fn lv_disp_get_buf(disp: *mut lv_disp_t) -> *mut lv_disp_buf_t;
}
extern "C" {
    pub fn lv_disp_get_inv_buf_size(disp: *mut lv_disp_t) -> u16;
}
extern "C" {
    pub fn _lv_disp_pop_from_inv_buf(disp: *mut lv_disp_t, num: u16);
}
extern "C" {
    pub fn lv_disp_is_double_buf(disp: *mut lv_disp_t) -> bool;
}
extern "C" {
    pub fn lv_disp_is_true_double_buf(disp: *mut lv_disp_t) -> bool;
}
pub const LV_INDEV_TYPE_NONE: cty::c_int = 0;
pub const LV_INDEV_TYPE_POINTER: cty::c_int = 1;
pub const LV_INDEV_TYPE_KEYPAD: cty::c_int = 2;
pub const LV_INDEV_TYPE_BUTTON: cty::c_int = 3;
pub const LV_INDEV_TYPE_ENCODER: cty::c_int = 4;
pub type _bindgen_ty_5 = cty::c_int;
pub type lv_indev_type_t = u8;
pub const LV_INDEV_STATE_REL: cty::c_int = 0;
pub const LV_INDEV_STATE_PR: cty::c_int = 1;
pub type _bindgen_ty_6 = cty::c_int;
pub type lv_indev_state_t = u8;
pub const LV_DRAG_DIR_HOR: cty::c_int = 1;
pub const LV_DRAG_DIR_VER: cty::c_int = 2;
pub const LV_DRAG_DIR_BOTH: cty::c_int = 3;
pub const LV_DRAG_DIR_ONE: cty::c_int = 4;
pub type _bindgen_ty_7 = cty::c_int;
pub type lv_drag_dir_t = u8;
pub const LV_GESTURE_DIR_TOP: cty::c_int = 0;
pub const LV_GESTURE_DIR_BOTTOM: cty::c_int = 1;
pub const LV_GESTURE_DIR_LEFT: cty::c_int = 2;
pub const LV_GESTURE_DIR_RIGHT: cty::c_int = 3;
pub type _bindgen_ty_8 = cty::c_int;
pub type lv_gesture_dir_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_indev_data_t {
    pub point: lv_point_t,
    pub key: u32,
    pub btn_id: u32,
    pub enc_diff: i16,
    pub state: lv_indev_state_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_indev_drv_t {
    pub type_: lv_indev_type_t,
    pub read_cb: ::core::option::Option<
        unsafe extern "C" fn(indev_drv: *mut _lv_indev_drv_t, data: *mut lv_indev_data_t) -> bool,
    >,
    pub feedback_cb:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_indev_drv_t, arg2: u8)>,
    pub user_data: lv_indev_drv_user_data_t,
    pub disp: *mut _disp_t,
    pub read_task: *mut lv_task_t,
    pub drag_limit: u8,
    pub drag_throw: u8,
    pub gesture_min_velocity: u8,
    pub gesture_limit: u8,
    pub long_press_time: u16,
    pub long_press_rep_time: u16,
}
pub type lv_indev_drv_t = _lv_indev_drv_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _lv_indev_proc_t {
    pub state: lv_indev_state_t,
    pub types: _lv_indev_proc_t__bindgen_ty_1,
    pub pr_timestamp: u32,
    pub longpr_rep_timestamp: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _lv_indev_proc_t__bindgen_ty_1 {
    pub pointer: _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1,
    pub keypad: _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1 {
    pub act_point: lv_point_t,
    pub last_point: lv_point_t,
    pub vect: lv_point_t,
    pub drag_sum: lv_point_t,
    pub drag_throw_vect: lv_point_t,
    pub act_obj: *mut _lv_obj_t,
    pub last_obj: *mut _lv_obj_t,
    pub last_pressed: *mut _lv_obj_t,
    pub gesture_dir: lv_gesture_dir_t,
    pub gesture_sum: lv_point_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn drag_limit_out(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_limit_out(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_in_prog(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_in_prog(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_dir(&self) -> lv_drag_dir_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_drag_dir(&mut self, val: lv_drag_dir_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn gesture_sent(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gesture_sent(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        drag_limit_out: u8,
        drag_in_prog: u8,
        drag_dir: lv_drag_dir_t,
        gesture_sent: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let drag_limit_out: u8 = unsafe { ::core::mem::transmute(drag_limit_out) };
            drag_limit_out as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let drag_in_prog: u8 = unsafe { ::core::mem::transmute(drag_in_prog) };
            drag_in_prog as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let drag_dir: u8 = unsafe { ::core::mem::transmute(drag_dir) };
            drag_dir as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let gesture_sent: u8 = unsafe { ::core::mem::transmute(gesture_sent) };
            gesture_sent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_indev_proc_t__bindgen_ty_1__bindgen_ty_2 {
    pub last_state: lv_indev_state_t,
    pub last_key: u32,
}
impl _lv_indev_proc_t {
    #[inline]
    pub fn long_pr_sent(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_long_pr_sent(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reset_query(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reset_query(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disabled(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_disabled(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wait_until_release(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wait_until_release(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        long_pr_sent: u8,
        reset_query: u8,
        disabled: u8,
        wait_until_release: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let long_pr_sent: u8 = unsafe { ::core::mem::transmute(long_pr_sent) };
            long_pr_sent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let reset_query: u8 = unsafe { ::core::mem::transmute(reset_query) };
            reset_query as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let disabled: u8 = unsafe { ::core::mem::transmute(disabled) };
            disabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wait_until_release: u8 = unsafe { ::core::mem::transmute(wait_until_release) };
            wait_until_release as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_indev_proc_t = _lv_indev_proc_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _lv_indev_t {
    pub driver: lv_indev_drv_t,
    pub proc_: lv_indev_proc_t,
    pub cursor: *mut _lv_obj_t,
    pub group: *mut _lv_group_t,
    pub btn_points: *const lv_point_t,
}
pub type lv_indev_t = _lv_indev_t;
extern "C" {
    pub fn lv_indev_drv_init(driver: *mut lv_indev_drv_t);
}
extern "C" {
    pub fn lv_indev_drv_register(driver: *mut lv_indev_drv_t) -> *mut lv_indev_t;
}
extern "C" {
    pub fn lv_indev_drv_update(indev: *mut lv_indev_t, new_drv: *mut lv_indev_drv_t);
}
extern "C" {
    pub fn lv_indev_get_next(indev: *mut lv_indev_t) -> *mut lv_indev_t;
}
extern "C" {
    pub fn _lv_indev_read(indev: *mut lv_indev_t, data: *mut lv_indev_data_t) -> bool;
}
extern "C" {
    pub fn lv_tick_inc(tick_period: u32);
}
extern "C" {
    pub fn lv_tick_get() -> u32;
}
extern "C" {
    pub fn lv_tick_elaps(prev_tick: u32) -> u32;
}
pub const _LV_STR_SYMBOL_AUDIO: cty::c_int = 0;
pub const _LV_STR_SYMBOL_VIDEO: cty::c_int = 1;
pub const _LV_STR_SYMBOL_LIST: cty::c_int = 2;
pub const _LV_STR_SYMBOL_OK: cty::c_int = 3;
pub const _LV_STR_SYMBOL_CLOSE: cty::c_int = 4;
pub const _LV_STR_SYMBOL_POWER: cty::c_int = 5;
pub const _LV_STR_SYMBOL_SETTINGS: cty::c_int = 6;
pub const _LV_STR_SYMBOL_HOME: cty::c_int = 7;
pub const _LV_STR_SYMBOL_DOWNLOAD: cty::c_int = 8;
pub const _LV_STR_SYMBOL_DRIVE: cty::c_int = 9;
pub const _LV_STR_SYMBOL_REFRESH: cty::c_int = 10;
pub const _LV_STR_SYMBOL_MUTE: cty::c_int = 11;
pub const _LV_STR_SYMBOL_VOLUME_MID: cty::c_int = 12;
pub const _LV_STR_SYMBOL_VOLUME_MAX: cty::c_int = 13;
pub const _LV_STR_SYMBOL_IMAGE: cty::c_int = 14;
pub const _LV_STR_SYMBOL_EDIT: cty::c_int = 15;
pub const _LV_STR_SYMBOL_PREV: cty::c_int = 16;
pub const _LV_STR_SYMBOL_PLAY: cty::c_int = 17;
pub const _LV_STR_SYMBOL_PAUSE: cty::c_int = 18;
pub const _LV_STR_SYMBOL_STOP: cty::c_int = 19;
pub const _LV_STR_SYMBOL_NEXT: cty::c_int = 20;
pub const _LV_STR_SYMBOL_EJECT: cty::c_int = 21;
pub const _LV_STR_SYMBOL_LEFT: cty::c_int = 22;
pub const _LV_STR_SYMBOL_RIGHT: cty::c_int = 23;
pub const _LV_STR_SYMBOL_PLUS: cty::c_int = 24;
pub const _LV_STR_SYMBOL_MINUS: cty::c_int = 25;
pub const _LV_STR_SYMBOL_EYE_OPEN: cty::c_int = 26;
pub const _LV_STR_SYMBOL_EYE_CLOSE: cty::c_int = 27;
pub const _LV_STR_SYMBOL_WARNING: cty::c_int = 28;
pub const _LV_STR_SYMBOL_SHUFFLE: cty::c_int = 29;
pub const _LV_STR_SYMBOL_UP: cty::c_int = 30;
pub const _LV_STR_SYMBOL_DOWN: cty::c_int = 31;
pub const _LV_STR_SYMBOL_LOOP: cty::c_int = 32;
pub const _LV_STR_SYMBOL_DIRECTORY: cty::c_int = 33;
pub const _LV_STR_SYMBOL_UPLOAD: cty::c_int = 34;
pub const _LV_STR_SYMBOL_CALL: cty::c_int = 35;
pub const _LV_STR_SYMBOL_CUT: cty::c_int = 36;
pub const _LV_STR_SYMBOL_COPY: cty::c_int = 37;
pub const _LV_STR_SYMBOL_SAVE: cty::c_int = 38;
pub const _LV_STR_SYMBOL_CHARGE: cty::c_int = 39;
pub const _LV_STR_SYMBOL_PASTE: cty::c_int = 40;
pub const _LV_STR_SYMBOL_BELL: cty::c_int = 41;
pub const _LV_STR_SYMBOL_KEYBOARD: cty::c_int = 42;
pub const _LV_STR_SYMBOL_GPS: cty::c_int = 43;
pub const _LV_STR_SYMBOL_FILE: cty::c_int = 44;
pub const _LV_STR_SYMBOL_WIFI: cty::c_int = 45;
pub const _LV_STR_SYMBOL_BATTERY_FULL: cty::c_int = 46;
pub const _LV_STR_SYMBOL_BATTERY_3: cty::c_int = 47;
pub const _LV_STR_SYMBOL_BATTERY_2: cty::c_int = 48;
pub const _LV_STR_SYMBOL_BATTERY_1: cty::c_int = 49;
pub const _LV_STR_SYMBOL_BATTERY_EMPTY: cty::c_int = 50;
pub const _LV_STR_SYMBOL_USB: cty::c_int = 51;
pub const _LV_STR_SYMBOL_BLUETOOTH: cty::c_int = 52;
pub const _LV_STR_SYMBOL_TRASH: cty::c_int = 53;
pub const _LV_STR_SYMBOL_BACKSPACE: cty::c_int = 54;
pub const _LV_STR_SYMBOL_SD_CARD: cty::c_int = 55;
pub const _LV_STR_SYMBOL_NEW_LINE: cty::c_int = 56;
pub const _LV_STR_SYMBOL_DUMMY: cty::c_int = 57;
pub const _LV_STR_SYMBOL_BULLET: cty::c_int = 58;
pub type _bindgen_ty_9 = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_font_glyph_dsc_t {
    pub adv_w: u16,
    pub box_w: u16,
    pub box_h: u16,
    pub ofs_x: i16,
    pub ofs_y: i16,
    pub bpp: u8,
}
pub const LV_FONT_SUBPX_NONE: cty::c_int = 0;
pub const LV_FONT_SUBPX_HOR: cty::c_int = 1;
pub const LV_FONT_SUBPX_VER: cty::c_int = 2;
pub const LV_FONT_SUBPX_BOTH: cty::c_int = 3;
pub type _bindgen_ty_10 = cty::c_int;
pub type lv_font_subpx_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_font_struct {
    pub get_glyph_dsc: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const _lv_font_struct,
            arg2: *mut lv_font_glyph_dsc_t,
            letter: u32,
            letter_next: u32,
        ) -> bool,
    >,
    pub get_glyph_bitmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const _lv_font_struct, arg2: u32) -> *const u8,
    >,
    pub line_height: lv_coord_t,
    pub base_line: lv_coord_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub underline_position: i8,
    pub underline_thickness: i8,
    pub dsc: *mut cty::c_void,
    pub user_data: lv_font_user_data_t,
}
impl _lv_font_struct {
    #[inline]
    pub fn subpx(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_subpx(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(subpx: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let subpx: u8 = unsafe { ::core::mem::transmute(subpx) };
            subpx as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_font_t = _lv_font_struct;
extern "C" {
    pub fn lv_font_get_glyph_bitmap(font_p: *const lv_font_t, letter: u32) -> *const u8;
}
extern "C" {
    pub fn lv_font_get_glyph_dsc(
        font_p: *const lv_font_t,
        dsc_out: *mut lv_font_glyph_dsc_t,
        letter: u32,
        letter_next: u32,
    ) -> bool;
}
extern "C" {
    pub fn lv_font_get_glyph_width(font: *const lv_font_t, letter: u32, letter_next: u32) -> u16;
}
extern "C" {
    pub static mut lv_font_montserrat_16: lv_font_t;
}
pub const LV_ANIM_OFF: cty::c_int = 0;
pub const LV_ANIM_ON: cty::c_int = 1;
pub type _bindgen_ty_11 = cty::c_int;
pub type lv_anim_enable_t = u8;
pub type lv_anim_value_t = lv_coord_t;
pub type lv_anim_path_cb_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const _lv_anim_path_t, arg2: *const _lv_anim_t) -> lv_anim_value_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_anim_path_t {
    pub cb: lv_anim_path_cb_t,
    pub user_data: *mut cty::c_void,
}
pub type lv_anim_path_t = _lv_anim_path_t;
pub type lv_anim_exec_xcb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: lv_anim_value_t)>;
pub type lv_anim_custom_exec_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_anim_t, arg2: lv_anim_value_t)>;
pub type lv_anim_ready_cb_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_anim_t)>;
pub type lv_anim_start_cb_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_anim_t)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_anim_t {
    pub var: *mut cty::c_void,
    pub exec_cb: lv_anim_exec_xcb_t,
    pub start_cb: lv_anim_start_cb_t,
    pub ready_cb: lv_anim_ready_cb_t,
    pub path: lv_anim_path_t,
    pub start: i32,
    pub current: i32,
    pub end: i32,
    pub time: i32,
    pub act_time: i32,
    pub playback_delay: u32,
    pub playback_time: u32,
    pub repeat_delay: u32,
    pub repeat_cnt: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub user_data: lv_anim_user_data_t,
    pub time_orig: u32,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 11usize],
}
impl _lv_anim_t {
    #[inline]
    pub fn early_apply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_early_apply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(early_apply: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let early_apply: u8 = unsafe { ::core::mem::transmute(early_apply) };
            early_apply as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn playback_now(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_playback_now(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_run(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_run(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(playback_now: u8, has_run: u32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let playback_now: u8 = unsafe { ::core::mem::transmute(playback_now) };
            playback_now as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_run: u32 = unsafe { ::core::mem::transmute(has_run) };
            has_run as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_anim_t = _lv_anim_t;
extern "C" {
    pub fn _lv_anim_core_init();
}
extern "C" {
    pub fn lv_anim_init(a: *mut lv_anim_t);
}
extern "C" {
    pub fn lv_anim_start(a: *mut lv_anim_t);
}
extern "C" {
    pub fn lv_anim_del(var: *mut cty::c_void, exec_cb: lv_anim_exec_xcb_t) -> bool;
}
extern "C" {
    pub fn lv_anim_get(var: *mut cty::c_void, exec_cb: lv_anim_exec_xcb_t) -> *mut lv_anim_t;
}
extern "C" {
    pub fn lv_anim_count_running() -> u16;
}
extern "C" {
    pub fn lv_anim_speed_to_time(speed: u16, start: lv_anim_value_t, end: lv_anim_value_t) -> u16;
}
extern "C" {
    pub fn lv_anim_refr_now();
}
extern "C" {
    pub fn lv_anim_path_linear(path: *const lv_anim_path_t, a: *const lv_anim_t)
        -> lv_anim_value_t;
}
extern "C" {
    pub fn lv_anim_path_ease_in(
        path: *const lv_anim_path_t,
        a: *const lv_anim_t,
    ) -> lv_anim_value_t;
}
extern "C" {
    pub fn lv_anim_path_ease_out(
        path: *const lv_anim_path_t,
        a: *const lv_anim_t,
    ) -> lv_anim_value_t;
}
extern "C" {
    pub fn lv_anim_path_ease_in_out(
        path: *const lv_anim_path_t,
        a: *const lv_anim_t,
    ) -> lv_anim_value_t;
}
extern "C" {
    pub fn lv_anim_path_overshoot(
        path: *const lv_anim_path_t,
        a: *const lv_anim_t,
    ) -> lv_anim_value_t;
}
extern "C" {
    pub fn lv_anim_path_bounce(path: *const lv_anim_path_t, a: *const lv_anim_t)
        -> lv_anim_value_t;
}
extern "C" {
    pub fn lv_anim_path_step(path: *const lv_anim_path_t, a: *const lv_anim_t) -> lv_anim_value_t;
}
extern "C" {
    pub static lv_anim_path_def: lv_anim_path_t;
}
extern "C" {
    pub fn lv_debug_check_null(p: *const cty::c_void) -> bool;
}
extern "C" {
    pub fn lv_debug_check_mem_integrity() -> bool;
}
extern "C" {
    pub fn lv_debug_check_str(str_: *const cty::c_void) -> bool;
}
extern "C" {
    pub fn lv_debug_log_error(msg: *const cty::c_char, value: u64);
}
pub const LV_DRAW_MASK_RES_TRANSP: cty::c_int = 0;
pub const LV_DRAW_MASK_RES_FULL_COVER: cty::c_int = 1;
pub const LV_DRAW_MASK_RES_CHANGED: cty::c_int = 2;
pub const LV_DRAW_MASK_RES_UNKNOWN: cty::c_int = 3;
pub type _bindgen_ty_12 = cty::c_int;
pub type lv_draw_mask_res_t = u8;
pub const LV_DRAW_MASK_TYPE_LINE: cty::c_int = 0;
pub const LV_DRAW_MASK_TYPE_ANGLE: cty::c_int = 1;
pub const LV_DRAW_MASK_TYPE_RADIUS: cty::c_int = 2;
pub const LV_DRAW_MASK_TYPE_FADE: cty::c_int = 3;
pub const LV_DRAW_MASK_TYPE_MAP: cty::c_int = 4;
pub type _bindgen_ty_13 = cty::c_int;
pub type lv_draw_mask_type_t = u8;
pub const LV_DRAW_MASK_LINE_SIDE_LEFT: cty::c_int = 0;
pub const LV_DRAW_MASK_LINE_SIDE_RIGHT: cty::c_int = 1;
pub const LV_DRAW_MASK_LINE_SIDE_TOP: cty::c_int = 2;
pub const LV_DRAW_MASK_LINE_SIDE_BOTTOM: cty::c_int = 3;
pub type _bindgen_ty_14 = cty::c_int;
pub type lv_draw_mask_xcb_t = ::core::option::Option<
    unsafe extern "C" fn(
        mask_buf: *mut lv_opa_t,
        abs_x: lv_coord_t,
        abs_y: lv_coord_t,
        len: lv_coord_t,
        p: *mut cty::c_void,
    ) -> lv_draw_mask_res_t,
>;
pub type lv_draw_mask_line_side_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_draw_mask_common_dsc_t {
    pub cb: lv_draw_mask_xcb_t,
    pub type_: lv_draw_mask_type_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_draw_mask_line_param_t {
    pub dsc: lv_draw_mask_common_dsc_t,
    pub cfg: lv_draw_mask_line_param_t__bindgen_ty_1,
    pub origo: lv_point_t,
    pub xy_steep: i32,
    pub yx_steep: i32,
    pub steep: i32,
    pub spx: i32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_draw_mask_line_param_t__bindgen_ty_1 {
    pub p1: lv_point_t,
    pub p2: lv_point_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl lv_draw_mask_line_param_t__bindgen_ty_1 {
    #[inline]
    pub fn side(&self) -> lv_draw_mask_line_side_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_side(&mut self, val: lv_draw_mask_line_side_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(side: lv_draw_mask_line_side_t) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let side: u8 = unsafe { ::core::mem::transmute(side) };
            side as u64
        });
        __bindgen_bitfield_unit
    }
}
impl lv_draw_mask_line_param_t {
    #[inline]
    pub fn flat(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flat(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inv(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inv(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(flat: u8, inv: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let flat: u8 = unsafe { ::core::mem::transmute(flat) };
            flat as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let inv: u8 = unsafe { ::core::mem::transmute(inv) };
            inv as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_draw_mask_angle_param_t {
    pub dsc: lv_draw_mask_common_dsc_t,
    pub cfg: lv_draw_mask_angle_param_t__bindgen_ty_1,
    pub start_line: lv_draw_mask_line_param_t,
    pub end_line: lv_draw_mask_line_param_t,
    pub delta_deg: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_draw_mask_angle_param_t__bindgen_ty_1 {
    pub vertex_p: lv_point_t,
    pub start_angle: lv_coord_t,
    pub end_angle: lv_coord_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_draw_mask_radius_param_t {
    pub dsc: lv_draw_mask_common_dsc_t,
    pub cfg: lv_draw_mask_radius_param_t__bindgen_ty_1,
    pub y_prev: i32,
    pub y_prev_x: lv_sqrt_res_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_draw_mask_radius_param_t__bindgen_ty_1 {
    pub rect: lv_area_t,
    pub radius: lv_coord_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl lv_draw_mask_radius_param_t__bindgen_ty_1 {
    #[inline]
    pub fn outer(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_outer(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(outer: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let outer: u8 = unsafe { ::core::mem::transmute(outer) };
            outer as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_draw_mask_fade_param_t {
    pub dsc: lv_draw_mask_common_dsc_t,
    pub cfg: lv_draw_mask_fade_param_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_draw_mask_fade_param_t__bindgen_ty_1 {
    pub coords: lv_area_t,
    pub y_top: lv_coord_t,
    pub y_bottom: lv_coord_t,
    pub opa_top: lv_opa_t,
    pub opa_bottom: lv_opa_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_draw_mask_map_param_t {
    pub dsc: lv_draw_mask_common_dsc_t,
    pub cfg: _lv_draw_mask_map_param_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_draw_mask_map_param_t__bindgen_ty_1 {
    pub coords: lv_area_t,
    pub map: *const lv_opa_t,
}
pub type lv_draw_mask_map_param_t = _lv_draw_mask_map_param_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_draw_mask_saved_t {
    pub param: *mut cty::c_void,
    pub custom_id: *mut cty::c_void,
}
pub type _lv_draw_mask_saved_arr_t = [_lv_draw_mask_saved_t; 16usize];
extern "C" {
    pub fn lv_draw_mask_add(param: *mut cty::c_void, custom_id: *mut cty::c_void) -> i16;
}
extern "C" {
    pub fn lv_draw_mask_apply(
        mask_buf: *mut lv_opa_t,
        abs_x: lv_coord_t,
        abs_y: lv_coord_t,
        len: lv_coord_t,
    ) -> lv_draw_mask_res_t;
}
extern "C" {
    pub fn lv_draw_mask_remove_id(id: i16) -> *mut cty::c_void;
}
extern "C" {
    pub fn lv_draw_mask_remove_custom(custom_id: *mut cty::c_void) -> *mut cty::c_void;
}
extern "C" {
    pub fn lv_draw_mask_get_cnt() -> u8;
}
extern "C" {
    pub fn lv_draw_mask_line_points_init(
        param: *mut lv_draw_mask_line_param_t,
        p1x: lv_coord_t,
        p1y: lv_coord_t,
        p2x: lv_coord_t,
        p2y: lv_coord_t,
        side: lv_draw_mask_line_side_t,
    );
}
extern "C" {
    pub fn lv_draw_mask_line_angle_init(
        param: *mut lv_draw_mask_line_param_t,
        p1x: lv_coord_t,
        py: lv_coord_t,
        angle: i16,
        side: lv_draw_mask_line_side_t,
    );
}
extern "C" {
    pub fn lv_draw_mask_angle_init(
        param: *mut lv_draw_mask_angle_param_t,
        vertex_x: lv_coord_t,
        vertex_y: lv_coord_t,
        start_angle: lv_coord_t,
        end_angle: lv_coord_t,
    );
}
extern "C" {
    pub fn lv_draw_mask_radius_init(
        param: *mut lv_draw_mask_radius_param_t,
        rect: *const lv_area_t,
        radius: lv_coord_t,
        inv: bool,
    );
}
extern "C" {
    pub fn lv_draw_mask_fade_init(
        param: *mut lv_draw_mask_fade_param_t,
        coords: *const lv_area_t,
        opa_top: lv_opa_t,
        y_top: lv_coord_t,
        opa_bottom: lv_opa_t,
        y_bottom: lv_coord_t,
    );
}
extern "C" {
    pub fn lv_draw_mask_map_init(
        param: *mut lv_draw_mask_map_param_t,
        coords: *const lv_area_t,
        map: *const lv_opa_t,
    );
}
pub const LV_BLEND_MODE_NORMAL: cty::c_int = 0;
pub const LV_BLEND_MODE_ADDITIVE: cty::c_int = 1;
pub const LV_BLEND_MODE_SUBTRACTIVE: cty::c_int = 2;
pub type _bindgen_ty_15 = cty::c_int;
pub type lv_blend_mode_t = u8;
extern "C" {
    pub fn _lv_blend_fill(
        clip_area: *const lv_area_t,
        fill_area: *const lv_area_t,
        color: lv_color_t,
        mask: *mut lv_opa_t,
        mask_res: lv_draw_mask_res_t,
        opa: lv_opa_t,
        mode: lv_blend_mode_t,
    );
}
extern "C" {
    pub fn _lv_blend_map(
        clip_area: *const lv_area_t,
        map_area: *const lv_area_t,
        map_buf: *const lv_color_t,
        mask: *mut lv_opa_t,
        mask_res: lv_draw_mask_res_t,
        opa: lv_opa_t,
        mode: lv_blend_mode_t,
    );
}
pub const LV_BORDER_SIDE_NONE: cty::c_int = 0;
pub const LV_BORDER_SIDE_BOTTOM: cty::c_int = 1;
pub const LV_BORDER_SIDE_TOP: cty::c_int = 2;
pub const LV_BORDER_SIDE_LEFT: cty::c_int = 4;
pub const LV_BORDER_SIDE_RIGHT: cty::c_int = 8;
pub const LV_BORDER_SIDE_FULL: cty::c_int = 15;
pub const LV_BORDER_SIDE_INTERNAL: cty::c_int = 16;
pub const _LV_BORDER_SIDE_LAST: cty::c_int = 17;
pub type _bindgen_ty_16 = cty::c_int;
pub type lv_border_side_t = u8;
pub const LV_GRAD_DIR_NONE: cty::c_int = 0;
pub const LV_GRAD_DIR_VER: cty::c_int = 1;
pub const LV_GRAD_DIR_HOR: cty::c_int = 2;
pub const _LV_GRAD_DIR_LAST: cty::c_int = 3;
pub type _bindgen_ty_17 = cty::c_int;
pub type lv_grad_dir_t = u8;
pub const LV_TEXT_DECOR_NONE: cty::c_int = 0;
pub const LV_TEXT_DECOR_UNDERLINE: cty::c_int = 1;
pub const LV_TEXT_DECOR_STRIKETHROUGH: cty::c_int = 2;
pub const _LV_TEXT_DECOR_LAST: cty::c_int = 3;
pub type _bindgen_ty_18 = cty::c_int;
pub type lv_text_decor_t = u8;
pub type lv_style_attr_t = u8;
pub const LV_STYLE_RADIUS: cty::c_int = 1;
pub const LV_STYLE_CLIP_CORNER: cty::c_int = 2;
pub const LV_STYLE_SIZE: cty::c_int = 3;
pub const LV_STYLE_TRANSFORM_WIDTH: cty::c_int = 4;
pub const LV_STYLE_TRANSFORM_HEIGHT: cty::c_int = 5;
pub const LV_STYLE_TRANSFORM_ANGLE: cty::c_int = 6;
pub const LV_STYLE_TRANSFORM_ZOOM: cty::c_int = 7;
pub const LV_STYLE_OPA_SCALE: cty::c_int = 32780;
pub const LV_STYLE_PAD_TOP: cty::c_int = 16;
pub const LV_STYLE_PAD_BOTTOM: cty::c_int = 17;
pub const LV_STYLE_PAD_LEFT: cty::c_int = 18;
pub const LV_STYLE_PAD_RIGHT: cty::c_int = 19;
pub const LV_STYLE_PAD_INNER: cty::c_int = 20;
pub const LV_STYLE_MARGIN_TOP: cty::c_int = 21;
pub const LV_STYLE_MARGIN_BOTTOM: cty::c_int = 22;
pub const LV_STYLE_MARGIN_LEFT: cty::c_int = 23;
pub const LV_STYLE_MARGIN_RIGHT: cty::c_int = 24;
pub const LV_STYLE_BG_BLEND_MODE: cty::c_int = 32;
pub const LV_STYLE_BG_MAIN_STOP: cty::c_int = 33;
pub const LV_STYLE_BG_GRAD_STOP: cty::c_int = 34;
pub const LV_STYLE_BG_GRAD_DIR: cty::c_int = 35;
pub const LV_STYLE_BG_COLOR: cty::c_int = 41;
pub const LV_STYLE_BG_GRAD_COLOR: cty::c_int = 42;
pub const LV_STYLE_BG_OPA: cty::c_int = 44;
pub const LV_STYLE_BORDER_WIDTH: cty::c_int = 48;
pub const LV_STYLE_BORDER_SIDE: cty::c_int = 49;
pub const LV_STYLE_BORDER_BLEND_MODE: cty::c_int = 50;
pub const LV_STYLE_BORDER_POST: cty::c_int = 51;
pub const LV_STYLE_BORDER_COLOR: cty::c_int = 57;
pub const LV_STYLE_BORDER_OPA: cty::c_int = 60;
pub const LV_STYLE_OUTLINE_WIDTH: cty::c_int = 64;
pub const LV_STYLE_OUTLINE_PAD: cty::c_int = 65;
pub const LV_STYLE_OUTLINE_BLEND_MODE: cty::c_int = 66;
pub const LV_STYLE_OUTLINE_COLOR: cty::c_int = 73;
pub const LV_STYLE_OUTLINE_OPA: cty::c_int = 76;
pub const LV_STYLE_SHADOW_WIDTH: cty::c_int = 80;
pub const LV_STYLE_SHADOW_OFS_X: cty::c_int = 81;
pub const LV_STYLE_SHADOW_OFS_Y: cty::c_int = 82;
pub const LV_STYLE_SHADOW_SPREAD: cty::c_int = 83;
pub const LV_STYLE_SHADOW_BLEND_MODE: cty::c_int = 84;
pub const LV_STYLE_SHADOW_COLOR: cty::c_int = 89;
pub const LV_STYLE_SHADOW_OPA: cty::c_int = 92;
pub const LV_STYLE_PATTERN_BLEND_MODE: cty::c_int = 96;
pub const LV_STYLE_PATTERN_REPEAT: cty::c_int = 97;
pub const LV_STYLE_PATTERN_RECOLOR: cty::c_int = 105;
pub const LV_STYLE_PATTERN_OPA: cty::c_int = 108;
pub const LV_STYLE_PATTERN_RECOLOR_OPA: cty::c_int = 109;
pub const LV_STYLE_PATTERN_IMAGE: cty::c_int = 110;
pub const LV_STYLE_VALUE_LETTER_SPACE: cty::c_int = 112;
pub const LV_STYLE_VALUE_LINE_SPACE: cty::c_int = 113;
pub const LV_STYLE_VALUE_BLEND_MODE: cty::c_int = 114;
pub const LV_STYLE_VALUE_OFS_X: cty::c_int = 115;
pub const LV_STYLE_VALUE_OFS_Y: cty::c_int = 116;
pub const LV_STYLE_VALUE_ALIGN: cty::c_int = 117;
pub const LV_STYLE_VALUE_COLOR: cty::c_int = 121;
pub const LV_STYLE_VALUE_OPA: cty::c_int = 124;
pub const LV_STYLE_VALUE_FONT: cty::c_int = 126;
pub const LV_STYLE_VALUE_STR: cty::c_int = 127;
pub const LV_STYLE_TEXT_LETTER_SPACE: cty::c_int = 32896;
pub const LV_STYLE_TEXT_LINE_SPACE: cty::c_int = 32897;
pub const LV_STYLE_TEXT_DECOR: cty::c_int = 32898;
pub const LV_STYLE_TEXT_BLEND_MODE: cty::c_int = 32899;
pub const LV_STYLE_TEXT_COLOR: cty::c_int = 32905;
pub const LV_STYLE_TEXT_SEL_COLOR: cty::c_int = 32906;
pub const LV_STYLE_TEXT_SEL_BG_COLOR: cty::c_int = 32907;
pub const LV_STYLE_TEXT_OPA: cty::c_int = 32908;
pub const LV_STYLE_TEXT_FONT: cty::c_int = 32910;
pub const LV_STYLE_LINE_WIDTH: cty::c_int = 144;
pub const LV_STYLE_LINE_BLEND_MODE: cty::c_int = 145;
pub const LV_STYLE_LINE_DASH_WIDTH: cty::c_int = 146;
pub const LV_STYLE_LINE_DASH_GAP: cty::c_int = 147;
pub const LV_STYLE_LINE_ROUNDED: cty::c_int = 148;
pub const LV_STYLE_LINE_COLOR: cty::c_int = 153;
pub const LV_STYLE_LINE_OPA: cty::c_int = 156;
pub const LV_STYLE_IMAGE_BLEND_MODE: cty::c_int = 32928;
pub const LV_STYLE_IMAGE_RECOLOR: cty::c_int = 32937;
pub const LV_STYLE_IMAGE_OPA: cty::c_int = 32940;
pub const LV_STYLE_IMAGE_RECOLOR_OPA: cty::c_int = 32941;
pub const LV_STYLE_TRANSITION_TIME: cty::c_int = 176;
pub const LV_STYLE_TRANSITION_DELAY: cty::c_int = 177;
pub const LV_STYLE_TRANSITION_PROP_1: cty::c_int = 178;
pub const LV_STYLE_TRANSITION_PROP_2: cty::c_int = 179;
pub const LV_STYLE_TRANSITION_PROP_3: cty::c_int = 180;
pub const LV_STYLE_TRANSITION_PROP_4: cty::c_int = 181;
pub const LV_STYLE_TRANSITION_PROP_5: cty::c_int = 182;
pub const LV_STYLE_TRANSITION_PROP_6: cty::c_int = 183;
pub const LV_STYLE_TRANSITION_PATH: cty::c_int = 190;
pub const LV_STYLE_SCALE_WIDTH: cty::c_int = 192;
pub const LV_STYLE_SCALE_BORDER_WIDTH: cty::c_int = 193;
pub const LV_STYLE_SCALE_END_BORDER_WIDTH: cty::c_int = 194;
pub const LV_STYLE_SCALE_END_LINE_WIDTH: cty::c_int = 195;
pub const LV_STYLE_SCALE_GRAD_COLOR: cty::c_int = 201;
pub const LV_STYLE_SCALE_END_COLOR: cty::c_int = 202;
pub type _bindgen_ty_19 = cty::c_int;
pub type lv_style_property_t = u16;
pub type lv_style_state_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_style_t {
    pub map: *mut u8,
}
pub type lv_style_int_t = i16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_style_list_t {
    pub style_list: *mut *mut lv_style_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
impl lv_style_list_t {
    #[inline]
    pub fn style_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_style_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn has_local(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_local(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_trans(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_trans(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_trans(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_trans(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_trans(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ignore_trans(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn valid_cache(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_valid_cache(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_cache(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ignore_cache(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn radius_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_radius_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn opa_scale_cover(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_opa_scale_cover(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn clip_corner_off(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_clip_corner_off(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transform_all_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transform_all_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pad_all_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pad_all_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn margin_all_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_margin_all_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blend_mode_all_normal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_blend_mode_all_normal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bg_opa_transp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bg_opa_transp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bg_opa_cover(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bg_opa_cover(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn border_width_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_border_width_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn border_side_full(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_border_side_full(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn border_post_off(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_border_post_off(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn outline_width_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_outline_width_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pattern_img_null(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pattern_img_null(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn shadow_width_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_shadow_width_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn value_txt_str(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_value_txt_str(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn img_recolor_opa_transp(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_img_recolor_opa_transp(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn text_space_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_text_space_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn text_decor_none(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_text_decor_none(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn text_font_normal(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_text_font_normal(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        style_cnt: u32,
        has_local: u32,
        has_trans: u32,
        skip_trans: u32,
        ignore_trans: u32,
        valid_cache: u32,
        ignore_cache: u32,
        radius_zero: u32,
        opa_scale_cover: u32,
        clip_corner_off: u32,
        transform_all_zero: u32,
        pad_all_zero: u32,
        margin_all_zero: u32,
        blend_mode_all_normal: u32,
        bg_opa_transp: u32,
        bg_opa_cover: u32,
        border_width_zero: u32,
        border_side_full: u32,
        border_post_off: u32,
        outline_width_zero: u32,
        pattern_img_null: u32,
        shadow_width_zero: u32,
        value_txt_str: u32,
        img_recolor_opa_transp: u32,
        text_space_zero: u32,
        text_decor_none: u32,
        text_font_normal: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let style_cnt: u32 = unsafe { ::core::mem::transmute(style_cnt) };
            style_cnt as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let has_local: u32 = unsafe { ::core::mem::transmute(has_local) };
            has_local as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let has_trans: u32 = unsafe { ::core::mem::transmute(has_trans) };
            has_trans as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let skip_trans: u32 = unsafe { ::core::mem::transmute(skip_trans) };
            skip_trans as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ignore_trans: u32 = unsafe { ::core::mem::transmute(ignore_trans) };
            ignore_trans as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let valid_cache: u32 = unsafe { ::core::mem::transmute(valid_cache) };
            valid_cache as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ignore_cache: u32 = unsafe { ::core::mem::transmute(ignore_cache) };
            ignore_cache as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let radius_zero: u32 = unsafe { ::core::mem::transmute(radius_zero) };
            radius_zero as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let opa_scale_cover: u32 = unsafe { ::core::mem::transmute(opa_scale_cover) };
            opa_scale_cover as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let clip_corner_off: u32 = unsafe { ::core::mem::transmute(clip_corner_off) };
            clip_corner_off as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let transform_all_zero: u32 = unsafe { ::core::mem::transmute(transform_all_zero) };
            transform_all_zero as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let pad_all_zero: u32 = unsafe { ::core::mem::transmute(pad_all_zero) };
            pad_all_zero as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let margin_all_zero: u32 = unsafe { ::core::mem::transmute(margin_all_zero) };
            margin_all_zero as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let blend_mode_all_normal: u32 =
                unsafe { ::core::mem::transmute(blend_mode_all_normal) };
            blend_mode_all_normal as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let bg_opa_transp: u32 = unsafe { ::core::mem::transmute(bg_opa_transp) };
            bg_opa_transp as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let bg_opa_cover: u32 = unsafe { ::core::mem::transmute(bg_opa_cover) };
            bg_opa_cover as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let border_width_zero: u32 = unsafe { ::core::mem::transmute(border_width_zero) };
            border_width_zero as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let border_side_full: u32 = unsafe { ::core::mem::transmute(border_side_full) };
            border_side_full as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let border_post_off: u32 = unsafe { ::core::mem::transmute(border_post_off) };
            border_post_off as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let outline_width_zero: u32 = unsafe { ::core::mem::transmute(outline_width_zero) };
            outline_width_zero as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let pattern_img_null: u32 = unsafe { ::core::mem::transmute(pattern_img_null) };
            pattern_img_null as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let shadow_width_zero: u32 = unsafe { ::core::mem::transmute(shadow_width_zero) };
            shadow_width_zero as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let value_txt_str: u32 = unsafe { ::core::mem::transmute(value_txt_str) };
            value_txt_str as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let img_recolor_opa_transp: u32 =
                unsafe { ::core::mem::transmute(img_recolor_opa_transp) };
            img_recolor_opa_transp as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let text_space_zero: u32 = unsafe { ::core::mem::transmute(text_space_zero) };
            text_space_zero as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let text_decor_none: u32 = unsafe { ::core::mem::transmute(text_decor_none) };
            text_decor_none as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let text_font_normal: u32 = unsafe { ::core::mem::transmute(text_font_normal) };
            text_font_normal as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn lv_style_init(style: *mut lv_style_t);
}
extern "C" {
    pub fn lv_style_copy(style_dest: *mut lv_style_t, style_src: *const lv_style_t);
}
extern "C" {
    pub fn lv_style_list_init(list: *mut lv_style_list_t);
}
extern "C" {
    pub fn lv_style_list_copy(list_dest: *mut lv_style_list_t, list_src: *const lv_style_list_t);
}
extern "C" {
    pub fn _lv_style_list_add_style(list: *mut lv_style_list_t, style: *mut lv_style_t);
}
extern "C" {
    pub fn _lv_style_list_remove_style(list: *mut lv_style_list_t, style: *mut lv_style_t);
}
extern "C" {
    pub fn _lv_style_list_reset(style_list: *mut lv_style_list_t);
}
extern "C" {
    pub fn lv_style_reset(style: *mut lv_style_t);
}
extern "C" {
    pub fn _lv_style_get_mem_size(style: *const lv_style_t) -> u16;
}
extern "C" {
    pub fn lv_style_remove_prop(style: *mut lv_style_t, prop: lv_style_property_t) -> bool;
}
extern "C" {
    pub fn _lv_style_set_int(
        style: *mut lv_style_t,
        prop: lv_style_property_t,
        value: lv_style_int_t,
    );
}
extern "C" {
    pub fn _lv_style_set_color(
        style: *mut lv_style_t,
        prop: lv_style_property_t,
        color: lv_color_t,
    );
}
extern "C" {
    pub fn _lv_style_set_opa(style: *mut lv_style_t, prop: lv_style_property_t, opa: lv_opa_t);
}
extern "C" {
    pub fn _lv_style_set_ptr(
        style: *mut lv_style_t,
        prop: lv_style_property_t,
        p: *const cty::c_void,
    );
}
extern "C" {
    pub fn _lv_style_get_int(
        style: *const lv_style_t,
        prop: lv_style_property_t,
        res: *mut cty::c_void,
    ) -> i16;
}
extern "C" {
    pub fn _lv_style_get_color(
        style: *const lv_style_t,
        prop: lv_style_property_t,
        res: *mut cty::c_void,
    ) -> i16;
}
extern "C" {
    pub fn _lv_style_get_opa(
        style: *const lv_style_t,
        prop: lv_style_property_t,
        res: *mut cty::c_void,
    ) -> i16;
}
extern "C" {
    pub fn _lv_style_get_ptr(
        style: *const lv_style_t,
        prop: lv_style_property_t,
        res: *mut cty::c_void,
    ) -> i16;
}
extern "C" {
    pub fn lv_style_list_get_local_style(list: *mut lv_style_list_t) -> *mut lv_style_t;
}
extern "C" {
    pub fn _lv_style_list_get_transition_style(list: *mut lv_style_list_t) -> *mut lv_style_t;
}
extern "C" {
    pub fn _lv_style_list_add_trans_style(list: *mut lv_style_list_t) -> *mut lv_style_t;
}
extern "C" {
    pub fn _lv_style_list_set_local_int(
        list: *mut lv_style_list_t,
        prop: lv_style_property_t,
        value: lv_style_int_t,
    );
}
extern "C" {
    pub fn _lv_style_list_set_local_color(
        list: *mut lv_style_list_t,
        prop: lv_style_property_t,
        value: lv_color_t,
    );
}
extern "C" {
    pub fn _lv_style_list_set_local_opa(
        list: *mut lv_style_list_t,
        prop: lv_style_property_t,
        value: lv_opa_t,
    );
}
extern "C" {
    pub fn _lv_style_list_set_local_ptr(
        list: *mut lv_style_list_t,
        prop: lv_style_property_t,
        value: *const cty::c_void,
    );
}
extern "C" {
    pub fn _lv_style_list_get_int(
        list: *mut lv_style_list_t,
        prop: lv_style_property_t,
        res: *mut lv_style_int_t,
    ) -> lv_res_t;
}
extern "C" {
    pub fn _lv_style_list_get_color(
        list: *mut lv_style_list_t,
        prop: lv_style_property_t,
        res: *mut lv_color_t,
    ) -> lv_res_t;
}
extern "C" {
    pub fn _lv_style_list_get_opa(
        list: *mut lv_style_list_t,
        prop: lv_style_property_t,
        res: *mut lv_opa_t,
    ) -> lv_res_t;
}
extern "C" {
    pub fn _lv_style_list_get_ptr(
        list: *mut lv_style_list_t,
        prop: lv_style_property_t,
        res: *mut *const cty::c_void,
    ) -> lv_res_t;
}
extern "C" {
    pub fn lv_debug_check_style(style: *const lv_style_t) -> bool;
}
extern "C" {
    pub fn lv_debug_check_style_list(list: *const lv_style_list_t) -> bool;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_draw_rect_dsc_t {
    pub radius: lv_style_int_t,
    pub bg_color: lv_color_t,
    pub bg_grad_color: lv_color_t,
    pub bg_grad_dir: lv_grad_dir_t,
    pub bg_main_color_stop: lv_style_int_t,
    pub bg_grad_color_stop: lv_style_int_t,
    pub bg_opa: lv_opa_t,
    pub bg_blend_mode: lv_blend_mode_t,
    pub border_color: lv_color_t,
    pub border_width: lv_style_int_t,
    pub border_side: lv_style_int_t,
    pub border_opa: lv_opa_t,
    pub border_blend_mode: lv_blend_mode_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub outline_color: lv_color_t,
    pub outline_width: lv_style_int_t,
    pub outline_pad: lv_style_int_t,
    pub outline_opa: lv_opa_t,
    pub outline_blend_mode: lv_blend_mode_t,
    pub shadow_color: lv_color_t,
    pub shadow_width: lv_style_int_t,
    pub shadow_ofs_x: lv_style_int_t,
    pub shadow_ofs_y: lv_style_int_t,
    pub shadow_spread: lv_style_int_t,
    pub shadow_opa: lv_opa_t,
    pub shadow_blend_mode: lv_blend_mode_t,
    pub pattern_image: *const cty::c_void,
    pub pattern_font: *const lv_font_t,
    pub pattern_recolor: lv_color_t,
    pub pattern_opa: lv_opa_t,
    pub pattern_recolor_opa: lv_opa_t,
    pub _bitfield_align_2: [u8; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub pattern_blend_mode: lv_blend_mode_t,
    pub value_str: *const cty::c_char,
    pub value_font: *const lv_font_t,
    pub value_opa: lv_opa_t,
    pub value_color: lv_color_t,
    pub value_ofs_x: lv_style_int_t,
    pub value_ofs_y: lv_style_int_t,
    pub value_letter_space: lv_style_int_t,
    pub value_line_space: lv_style_int_t,
    pub value_align: lv_align_t,
    pub value_blend_mode: lv_blend_mode_t,
}
impl lv_draw_rect_dsc_t {
    #[inline]
    pub fn border_post(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_border_post(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(border_post: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let border_post: u8 = unsafe { ::core::mem::transmute(border_post) };
            border_post as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn pattern_repeat(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pattern_repeat(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(pattern_repeat: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pattern_repeat: u8 = unsafe { ::core::mem::transmute(pattern_repeat) };
            pattern_repeat as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn lv_draw_rect_dsc_init(dsc: *mut lv_draw_rect_dsc_t);
}
extern "C" {
    pub fn lv_draw_rect(
        coords: *const lv_area_t,
        mask: *const lv_area_t,
        dsc: *const lv_draw_rect_dsc_t,
    );
}
extern "C" {
    pub fn lv_draw_px(
        point: *const lv_point_t,
        clip_area: *const lv_area_t,
        style: *const lv_style_t,
    );
}
pub const LV_BIDI_DIR_LTR: cty::c_int = 0;
pub const LV_BIDI_DIR_RTL: cty::c_int = 1;
pub const LV_BIDI_DIR_AUTO: cty::c_int = 2;
pub const LV_BIDI_DIR_INHERIT: cty::c_int = 3;
pub const LV_BIDI_DIR_NEUTRAL: cty::c_int = 32;
pub const LV_BIDI_DIR_WEAK: cty::c_int = 33;
pub type _bindgen_ty_20 = cty::c_int;
pub type lv_bidi_dir_t = u8;
pub type __gnuc_va_list = __builtin_va_list;
extern "C" {
    pub fn lv_snprintf(
        buffer: *mut cty::c_char,
        count: size_t,
        format: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn lv_vsnprintf(
        buffer: *mut cty::c_char,
        count: size_t,
        format: *const cty::c_char,
        va: va_list,
    ) -> cty::c_int;
}
pub const LV_TXT_FLAG_NONE: cty::c_int = 0;
pub const LV_TXT_FLAG_RECOLOR: cty::c_int = 1;
pub const LV_TXT_FLAG_EXPAND: cty::c_int = 2;
pub const LV_TXT_FLAG_CENTER: cty::c_int = 4;
pub const LV_TXT_FLAG_RIGHT: cty::c_int = 8;
pub const LV_TXT_FLAG_FIT: cty::c_int = 16;
pub type _bindgen_ty_21 = cty::c_int;
pub type lv_txt_flag_t = u8;
pub const LV_TXT_CMD_STATE_WAIT: cty::c_int = 0;
pub const LV_TXT_CMD_STATE_PAR: cty::c_int = 1;
pub const LV_TXT_CMD_STATE_IN: cty::c_int = 2;
pub type _bindgen_ty_22 = cty::c_int;
pub type lv_txt_cmd_state_t = u8;
extern "C" {
    pub fn _lv_txt_get_size(
        size_res: *mut lv_point_t,
        text: *const cty::c_char,
        font: *const lv_font_t,
        letter_space: lv_coord_t,
        line_space: lv_coord_t,
        max_width: lv_coord_t,
        flag: lv_txt_flag_t,
    );
}
extern "C" {
    pub fn _lv_txt_get_next_line(
        txt: *const cty::c_char,
        font: *const lv_font_t,
        letter_space: lv_coord_t,
        max_width: lv_coord_t,
        flag: lv_txt_flag_t,
    ) -> u32;
}
extern "C" {
    pub fn _lv_txt_get_width(
        txt: *const cty::c_char,
        length: u32,
        font: *const lv_font_t,
        letter_space: lv_coord_t,
        flag: lv_txt_flag_t,
    ) -> lv_coord_t;
}
extern "C" {
    pub fn _lv_txt_is_cmd(state: *mut lv_txt_cmd_state_t, c: u32) -> bool;
}
extern "C" {
    pub fn _lv_txt_ins(txt_buf: *mut cty::c_char, pos: u32, ins_txt: *const cty::c_char);
}
extern "C" {
    pub fn _lv_txt_cut(txt: *mut cty::c_char, pos: u32, len: u32);
}
extern "C" {
    pub fn _lv_txt_set_text_vfmt(fmt: *const cty::c_char, ap: va_list) -> *mut cty::c_char;
}
extern "C" {
    pub static mut _lv_txt_encoded_size:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const cty::c_char) -> u8>;
}
extern "C" {
    pub static mut _lv_txt_unicode_to_encoded:
        ::core::option::Option<unsafe extern "C" fn(arg1: u32) -> u32>;
}
extern "C" {
    pub static mut _lv_txt_encoded_conv_wc:
        ::core::option::Option<unsafe extern "C" fn(c: u32) -> u32>;
}
extern "C" {
    pub static mut _lv_txt_encoded_next: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const cty::c_char, arg2: *mut u32) -> u32,
    >;
}
extern "C" {
    pub static mut _lv_txt_encoded_prev: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const cty::c_char, arg2: *mut u32) -> u32,
    >;
}
extern "C" {
    pub static mut _lv_txt_encoded_get_byte_id:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const cty::c_char, arg2: u32) -> u32>;
}
extern "C" {
    pub static mut _lv_txt_encoded_get_char_id:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const cty::c_char, arg2: u32) -> u32>;
}
extern "C" {
    pub static mut _lv_txt_get_encoded_length:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const cty::c_char) -> u32>;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_draw_label_dsc_t {
    pub color: lv_color_t,
    pub sel_color: lv_color_t,
    pub sel_bg_color: lv_color_t,
    pub font: *const lv_font_t,
    pub opa: lv_opa_t,
    pub line_space: lv_style_int_t,
    pub letter_space: lv_style_int_t,
    pub sel_start: u32,
    pub sel_end: u32,
    pub ofs_x: lv_coord_t,
    pub ofs_y: lv_coord_t,
    pub bidi_dir: lv_bidi_dir_t,
    pub flag: lv_txt_flag_t,
    pub decor: lv_text_decor_t,
    pub blend_mode: lv_blend_mode_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_draw_label_hint_t {
    pub line_start: i32,
    pub y: i32,
    pub coord_y: i32,
}
extern "C" {
    pub fn lv_draw_label_dsc_init(dsc: *mut lv_draw_label_dsc_t);
}
extern "C" {
    pub fn lv_draw_label(
        coords: *const lv_area_t,
        mask: *const lv_area_t,
        dsc: *const lv_draw_label_dsc_t,
        txt: *const cty::c_char,
        hint: *mut lv_draw_label_hint_t,
    );
}
extern "C" {
    pub static mut _lv_bpp2_opa_table: [u8; 0usize];
}
extern "C" {
    pub static mut _lv_bpp3_opa_table: [u8; 0usize];
}
extern "C" {
    pub static mut _lv_bpp1_opa_table: [u8; 0usize];
}
extern "C" {
    pub static mut _lv_bpp4_opa_table: [u8; 0usize];
}
extern "C" {
    pub static mut _lv_bpp8_opa_table: [u8; 0usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_draw_line_dsc_t {
    pub color: lv_color_t,
    pub width: lv_style_int_t,
    pub dash_width: lv_style_int_t,
    pub dash_gap: lv_style_int_t,
    pub opa: lv_opa_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl lv_draw_line_dsc_t {
    #[inline]
    pub fn blend_mode(&self) -> lv_blend_mode_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_blend_mode(&mut self, val: lv_blend_mode_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn round_start(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_round_start(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn round_end(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_round_end(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn raw_end(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_raw_end(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        blend_mode: lv_blend_mode_t,
        round_start: u8,
        round_end: u8,
        raw_end: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let blend_mode: u8 = unsafe { ::core::mem::transmute(blend_mode) };
            blend_mode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let round_start: u8 = unsafe { ::core::mem::transmute(round_start) };
            round_start as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let round_end: u8 = unsafe { ::core::mem::transmute(round_end) };
            round_end as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let raw_end: u8 = unsafe { ::core::mem::transmute(raw_end) };
            raw_end as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn lv_draw_line(
        point1: *const lv_point_t,
        point2: *const lv_point_t,
        clip: *const lv_area_t,
        dsc: *const lv_draw_line_dsc_t,
    );
}
extern "C" {
    pub fn lv_draw_line_dsc_init(dsc: *mut lv_draw_line_dsc_t);
}
pub const LV_IMG_CF_UNKNOWN: cty::c_int = 0;
pub const LV_IMG_CF_RAW: cty::c_int = 1;
pub const LV_IMG_CF_RAW_ALPHA: cty::c_int = 2;
pub const LV_IMG_CF_RAW_CHROMA_KEYED: cty::c_int = 3;
pub const LV_IMG_CF_TRUE_COLOR: cty::c_int = 4;
pub const LV_IMG_CF_TRUE_COLOR_ALPHA: cty::c_int = 5;
pub const LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED: cty::c_int = 6;
pub const LV_IMG_CF_INDEXED_1BIT: cty::c_int = 7;
pub const LV_IMG_CF_INDEXED_2BIT: cty::c_int = 8;
pub const LV_IMG_CF_INDEXED_4BIT: cty::c_int = 9;
pub const LV_IMG_CF_INDEXED_8BIT: cty::c_int = 10;
pub const LV_IMG_CF_ALPHA_1BIT: cty::c_int = 11;
pub const LV_IMG_CF_ALPHA_2BIT: cty::c_int = 12;
pub const LV_IMG_CF_ALPHA_4BIT: cty::c_int = 13;
pub const LV_IMG_CF_ALPHA_8BIT: cty::c_int = 14;
pub const LV_IMG_CF_RESERVED_15: cty::c_int = 15;
pub const LV_IMG_CF_RESERVED_16: cty::c_int = 16;
pub const LV_IMG_CF_RESERVED_17: cty::c_int = 17;
pub const LV_IMG_CF_RESERVED_18: cty::c_int = 18;
pub const LV_IMG_CF_RESERVED_19: cty::c_int = 19;
pub const LV_IMG_CF_RESERVED_20: cty::c_int = 20;
pub const LV_IMG_CF_RESERVED_21: cty::c_int = 21;
pub const LV_IMG_CF_RESERVED_22: cty::c_int = 22;
pub const LV_IMG_CF_RESERVED_23: cty::c_int = 23;
pub const LV_IMG_CF_USER_ENCODED_0: cty::c_int = 24;
pub const LV_IMG_CF_USER_ENCODED_1: cty::c_int = 25;
pub const LV_IMG_CF_USER_ENCODED_2: cty::c_int = 26;
pub const LV_IMG_CF_USER_ENCODED_3: cty::c_int = 27;
pub const LV_IMG_CF_USER_ENCODED_4: cty::c_int = 28;
pub const LV_IMG_CF_USER_ENCODED_5: cty::c_int = 29;
pub const LV_IMG_CF_USER_ENCODED_6: cty::c_int = 30;
pub const LV_IMG_CF_USER_ENCODED_7: cty::c_int = 31;
pub type _bindgen_ty_23 = cty::c_int;
pub type lv_img_cf_t = u8;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct lv_img_header_t {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl lv_img_header_t {
    #[inline]
    pub fn cf(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_cf(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn always_zero(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_always_zero(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn w(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_w(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn h(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_h(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cf: u32,
        always_zero: u32,
        reserved: u32,
        w: u32,
        h: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let cf: u32 = unsafe { ::core::mem::transmute(cf) };
            cf as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let always_zero: u32 = unsafe { ::core::mem::transmute(always_zero) };
            always_zero as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(10usize, 11u8, {
            let w: u32 = unsafe { ::core::mem::transmute(w) };
            w as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let h: u32 = unsafe { ::core::mem::transmute(h) };
            h as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_img_dsc_t {
    pub header: lv_img_header_t,
    pub data_size: u32,
    pub data: *const u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_img_transform_dsc_t {
    pub cfg: lv_img_transform_dsc_t__bindgen_ty_1,
    pub res: lv_img_transform_dsc_t__bindgen_ty_2,
    pub tmp: lv_img_transform_dsc_t__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_img_transform_dsc_t__bindgen_ty_1 {
    pub src: *const cty::c_void,
    pub src_w: lv_coord_t,
    pub src_h: lv_coord_t,
    pub pivot_x: lv_coord_t,
    pub pivot_y: lv_coord_t,
    pub angle: i16,
    pub zoom: u16,
    pub color: lv_color_t,
    pub cf: lv_img_cf_t,
    pub antialias: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_img_transform_dsc_t__bindgen_ty_2 {
    pub color: lv_color_t,
    pub opa: lv_opa_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_img_transform_dsc_t__bindgen_ty_3 {
    pub img_dsc: lv_img_dsc_t,
    pub pivot_x_256: i32,
    pub pivot_y_256: i32,
    pub sinma: i32,
    pub cosma: i32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub zoom_inv: u32,
    pub xs: lv_coord_t,
    pub ys: lv_coord_t,
    pub xs_int: lv_coord_t,
    pub ys_int: lv_coord_t,
    pub pxi: u32,
    pub px_size: u8,
}
impl lv_img_transform_dsc_t__bindgen_ty_3 {
    #[inline]
    pub fn chroma_keyed(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_chroma_keyed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_alpha(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_has_alpha(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn native_color(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_native_color(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        chroma_keyed: u8,
        has_alpha: u8,
        native_color: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let chroma_keyed: u8 = unsafe { ::core::mem::transmute(chroma_keyed) };
            chroma_keyed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_alpha: u8 = unsafe { ::core::mem::transmute(has_alpha) };
            has_alpha as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let native_color: u8 = unsafe { ::core::mem::transmute(native_color) };
            native_color as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn lv_img_buf_alloc(w: lv_coord_t, h: lv_coord_t, cf: lv_img_cf_t) -> *mut lv_img_dsc_t;
}
extern "C" {
    pub fn lv_img_buf_get_px_color(
        dsc: *mut lv_img_dsc_t,
        x: lv_coord_t,
        y: lv_coord_t,
        color: lv_color_t,
    ) -> lv_color_t;
}
extern "C" {
    pub fn lv_img_buf_get_px_alpha(
        dsc: *mut lv_img_dsc_t,
        x: lv_coord_t,
        y: lv_coord_t,
    ) -> lv_opa_t;
}
extern "C" {
    pub fn lv_img_buf_set_px_color(
        dsc: *mut lv_img_dsc_t,
        x: lv_coord_t,
        y: lv_coord_t,
        c: lv_color_t,
    );
}
extern "C" {
    pub fn lv_img_buf_set_px_alpha(
        dsc: *mut lv_img_dsc_t,
        x: lv_coord_t,
        y: lv_coord_t,
        opa: lv_opa_t,
    );
}
extern "C" {
    pub fn lv_img_buf_set_palette(dsc: *mut lv_img_dsc_t, id: u8, c: lv_color_t);
}
extern "C" {
    pub fn lv_img_buf_free(dsc: *mut lv_img_dsc_t);
}
extern "C" {
    pub fn lv_img_buf_get_img_size(w: lv_coord_t, h: lv_coord_t, cf: lv_img_cf_t) -> u32;
}
extern "C" {
    pub fn _lv_img_buf_transform_init(dsc: *mut lv_img_transform_dsc_t);
}
extern "C" {
    pub fn _lv_img_buf_transform_anti_alias(dsc: *mut lv_img_transform_dsc_t) -> bool;
}
extern "C" {
    pub fn _lv_img_buf_get_transformed_area(
        res: *mut lv_area_t,
        w: lv_coord_t,
        h: lv_coord_t,
        angle: i16,
        zoom: u16,
        pivot: *const lv_point_t,
    );
}
pub const LV_FS_RES_OK: cty::c_int = 0;
pub const LV_FS_RES_HW_ERR: cty::c_int = 1;
pub const LV_FS_RES_FS_ERR: cty::c_int = 2;
pub const LV_FS_RES_NOT_EX: cty::c_int = 3;
pub const LV_FS_RES_FULL: cty::c_int = 4;
pub const LV_FS_RES_LOCKED: cty::c_int = 5;
pub const LV_FS_RES_DENIED: cty::c_int = 6;
pub const LV_FS_RES_BUSY: cty::c_int = 7;
pub const LV_FS_RES_TOUT: cty::c_int = 8;
pub const LV_FS_RES_NOT_IMP: cty::c_int = 9;
pub const LV_FS_RES_OUT_OF_MEM: cty::c_int = 10;
pub const LV_FS_RES_INV_PARAM: cty::c_int = 11;
pub const LV_FS_RES_UNKNOWN: cty::c_int = 12;
pub type _bindgen_ty_24 = cty::c_int;
pub type lv_fs_res_t = u8;
pub const LV_FS_MODE_WR: cty::c_int = 1;
pub const LV_FS_MODE_RD: cty::c_int = 2;
pub type _bindgen_ty_25 = cty::c_int;
pub type lv_fs_mode_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_fs_drv_t {
    pub letter: cty::c_char,
    pub file_size: u16,
    pub rddir_size: u16,
    pub ready_cb: ::core::option::Option<unsafe extern "C" fn(drv: *mut _lv_fs_drv_t) -> bool>,
    pub open_cb: ::core::option::Option<
        unsafe extern "C" fn(
            drv: *mut _lv_fs_drv_t,
            file_p: *mut cty::c_void,
            path: *const cty::c_char,
            mode: lv_fs_mode_t,
        ) -> lv_fs_res_t,
    >,
    pub close_cb: ::core::option::Option<
        unsafe extern "C" fn(drv: *mut _lv_fs_drv_t, file_p: *mut cty::c_void) -> lv_fs_res_t,
    >,
    pub remove_cb: ::core::option::Option<
        unsafe extern "C" fn(drv: *mut _lv_fs_drv_t, fn_: *const cty::c_char) -> lv_fs_res_t,
    >,
    pub read_cb: ::core::option::Option<
        unsafe extern "C" fn(
            drv: *mut _lv_fs_drv_t,
            file_p: *mut cty::c_void,
            buf: *mut cty::c_void,
            btr: u32,
            br: *mut u32,
        ) -> lv_fs_res_t,
    >,
    pub write_cb: ::core::option::Option<
        unsafe extern "C" fn(
            drv: *mut _lv_fs_drv_t,
            file_p: *mut cty::c_void,
            buf: *const cty::c_void,
            btw: u32,
            bw: *mut u32,
        ) -> lv_fs_res_t,
    >,
    pub seek_cb: ::core::option::Option<
        unsafe extern "C" fn(
            drv: *mut _lv_fs_drv_t,
            file_p: *mut cty::c_void,
            pos: u32,
        ) -> lv_fs_res_t,
    >,
    pub tell_cb: ::core::option::Option<
        unsafe extern "C" fn(
            drv: *mut _lv_fs_drv_t,
            file_p: *mut cty::c_void,
            pos_p: *mut u32,
        ) -> lv_fs_res_t,
    >,
    pub trunc_cb: ::core::option::Option<
        unsafe extern "C" fn(drv: *mut _lv_fs_drv_t, file_p: *mut cty::c_void) -> lv_fs_res_t,
    >,
    pub size_cb: ::core::option::Option<
        unsafe extern "C" fn(
            drv: *mut _lv_fs_drv_t,
            file_p: *mut cty::c_void,
            size_p: *mut u32,
        ) -> lv_fs_res_t,
    >,
    pub rename_cb: ::core::option::Option<
        unsafe extern "C" fn(
            drv: *mut _lv_fs_drv_t,
            oldname: *const cty::c_char,
            newname: *const cty::c_char,
        ) -> lv_fs_res_t,
    >,
    pub free_space_cb: ::core::option::Option<
        unsafe extern "C" fn(
            drv: *mut _lv_fs_drv_t,
            total_p: *mut u32,
            free_p: *mut u32,
        ) -> lv_fs_res_t,
    >,
    pub dir_open_cb: ::core::option::Option<
        unsafe extern "C" fn(
            drv: *mut _lv_fs_drv_t,
            rddir_p: *mut cty::c_void,
            path: *const cty::c_char,
        ) -> lv_fs_res_t,
    >,
    pub dir_read_cb: ::core::option::Option<
        unsafe extern "C" fn(
            drv: *mut _lv_fs_drv_t,
            rddir_p: *mut cty::c_void,
            fn_: *mut cty::c_char,
        ) -> lv_fs_res_t,
    >,
    pub dir_close_cb: ::core::option::Option<
        unsafe extern "C" fn(drv: *mut _lv_fs_drv_t, rddir_p: *mut cty::c_void) -> lv_fs_res_t,
    >,
    pub user_data: lv_fs_drv_user_data_t,
}
pub type lv_fs_drv_t = _lv_fs_drv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_fs_file_t {
    pub file_d: *mut cty::c_void,
    pub drv: *mut lv_fs_drv_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_fs_dir_t {
    pub dir_d: *mut cty::c_void,
    pub drv: *mut lv_fs_drv_t,
}
extern "C" {
    pub fn _lv_fs_init();
}
extern "C" {
    pub fn lv_fs_drv_init(drv: *mut lv_fs_drv_t);
}
extern "C" {
    pub fn lv_fs_drv_register(drv_p: *mut lv_fs_drv_t);
}
extern "C" {
    pub fn lv_fs_get_drv(letter: cty::c_char) -> *mut lv_fs_drv_t;
}
extern "C" {
    pub fn lv_fs_is_ready(letter: cty::c_char) -> bool;
}
extern "C" {
    pub fn lv_fs_open(
        file_p: *mut lv_fs_file_t,
        path: *const cty::c_char,
        mode: lv_fs_mode_t,
    ) -> lv_fs_res_t;
}
extern "C" {
    pub fn lv_fs_close(file_p: *mut lv_fs_file_t) -> lv_fs_res_t;
}
extern "C" {
    pub fn lv_fs_remove(path: *const cty::c_char) -> lv_fs_res_t;
}
extern "C" {
    pub fn lv_fs_read(
        file_p: *mut lv_fs_file_t,
        buf: *mut cty::c_void,
        btr: u32,
        br: *mut u32,
    ) -> lv_fs_res_t;
}
extern "C" {
    pub fn lv_fs_write(
        file_p: *mut lv_fs_file_t,
        buf: *const cty::c_void,
        btw: u32,
        bw: *mut u32,
    ) -> lv_fs_res_t;
}
extern "C" {
    pub fn lv_fs_seek(file_p: *mut lv_fs_file_t, pos: u32) -> lv_fs_res_t;
}
extern "C" {
    pub fn lv_fs_tell(file_p: *mut lv_fs_file_t, pos: *mut u32) -> lv_fs_res_t;
}
extern "C" {
    pub fn lv_fs_trunc(file_p: *mut lv_fs_file_t) -> lv_fs_res_t;
}
extern "C" {
    pub fn lv_fs_size(file_p: *mut lv_fs_file_t, size: *mut u32) -> lv_fs_res_t;
}
extern "C" {
    pub fn lv_fs_rename(oldname: *const cty::c_char, newname: *const cty::c_char) -> lv_fs_res_t;
}
extern "C" {
    pub fn lv_fs_dir_open(rddir_p: *mut lv_fs_dir_t, path: *const cty::c_char) -> lv_fs_res_t;
}
extern "C" {
    pub fn lv_fs_dir_read(rddir_p: *mut lv_fs_dir_t, fn_: *mut cty::c_char) -> lv_fs_res_t;
}
extern "C" {
    pub fn lv_fs_dir_close(rddir_p: *mut lv_fs_dir_t) -> lv_fs_res_t;
}
extern "C" {
    pub fn lv_fs_free_space(
        letter: cty::c_char,
        total_p: *mut u32,
        free_p: *mut u32,
    ) -> lv_fs_res_t;
}
extern "C" {
    pub fn lv_fs_get_letters(buf: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn lv_fs_get_ext(fn_: *const cty::c_char) -> *const cty::c_char;
}
extern "C" {
    pub fn lv_fs_up(path: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn lv_fs_get_last(path: *const cty::c_char) -> *const cty::c_char;
}
pub const LV_IMG_SRC_VARIABLE: cty::c_int = 0;
pub const LV_IMG_SRC_FILE: cty::c_int = 1;
pub const LV_IMG_SRC_SYMBOL: cty::c_int = 2;
pub const LV_IMG_SRC_UNKNOWN: cty::c_int = 3;
pub type _bindgen_ty_26 = cty::c_int;
pub type lv_img_src_t = u8;
pub type lv_img_decoder_info_f_t = ::core::option::Option<
    unsafe extern "C" fn(
        decoder: *mut _lv_img_decoder,
        src: *const cty::c_void,
        header: *mut lv_img_header_t,
    ) -> lv_res_t,
>;
pub type lv_img_decoder_open_f_t = ::core::option::Option<
    unsafe extern "C" fn(decoder: *mut _lv_img_decoder, dsc: *mut _lv_img_decoder_dsc) -> lv_res_t,
>;
pub type lv_img_decoder_read_line_f_t = ::core::option::Option<
    unsafe extern "C" fn(
        decoder: *mut _lv_img_decoder,
        dsc: *mut _lv_img_decoder_dsc,
        x: lv_coord_t,
        y: lv_coord_t,
        len: lv_coord_t,
        buf: *mut u8,
    ) -> lv_res_t,
>;
pub type lv_img_decoder_close_f_t = ::core::option::Option<
    unsafe extern "C" fn(decoder: *mut _lv_img_decoder, dsc: *mut _lv_img_decoder_dsc),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_img_decoder {
    pub info_cb: lv_img_decoder_info_f_t,
    pub open_cb: lv_img_decoder_open_f_t,
    pub read_line_cb: lv_img_decoder_read_line_f_t,
    pub close_cb: lv_img_decoder_close_f_t,
    pub user_data: lv_img_decoder_user_data_t,
}
pub type lv_img_decoder_t = _lv_img_decoder;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _lv_img_decoder_dsc {
    pub decoder: *mut lv_img_decoder_t,
    pub src: *const cty::c_void,
    pub color: lv_color_t,
    pub src_type: lv_img_src_t,
    pub header: lv_img_header_t,
    pub img_data: *const u8,
    pub time_to_open: u32,
    pub error_msg: *const cty::c_char,
    pub user_data: *mut cty::c_void,
}
pub type lv_img_decoder_dsc_t = _lv_img_decoder_dsc;
extern "C" {
    pub fn _lv_img_decoder_init();
}
extern "C" {
    pub fn lv_img_decoder_get_info(
        src: *const cty::c_char,
        header: *mut lv_img_header_t,
    ) -> lv_res_t;
}
extern "C" {
    pub fn lv_img_decoder_open(
        dsc: *mut lv_img_decoder_dsc_t,
        src: *const cty::c_void,
        color: lv_color_t,
    ) -> lv_res_t;
}
extern "C" {
    pub fn lv_img_decoder_read_line(
        dsc: *mut lv_img_decoder_dsc_t,
        x: lv_coord_t,
        y: lv_coord_t,
        len: lv_coord_t,
        buf: *mut u8,
    ) -> lv_res_t;
}
extern "C" {
    pub fn lv_img_decoder_close(dsc: *mut lv_img_decoder_dsc_t);
}
extern "C" {
    pub fn lv_img_decoder_create() -> *mut lv_img_decoder_t;
}
extern "C" {
    pub fn lv_img_decoder_delete(decoder: *mut lv_img_decoder_t);
}
extern "C" {
    pub fn lv_img_decoder_set_info_cb(
        decoder: *mut lv_img_decoder_t,
        info_cb: lv_img_decoder_info_f_t,
    );
}
extern "C" {
    pub fn lv_img_decoder_set_open_cb(
        decoder: *mut lv_img_decoder_t,
        open_cb: lv_img_decoder_open_f_t,
    );
}
extern "C" {
    pub fn lv_img_decoder_set_read_line_cb(
        decoder: *mut lv_img_decoder_t,
        read_line_cb: lv_img_decoder_read_line_f_t,
    );
}
extern "C" {
    pub fn lv_img_decoder_set_close_cb(
        decoder: *mut lv_img_decoder_t,
        close_cb: lv_img_decoder_close_f_t,
    );
}
extern "C" {
    pub fn lv_img_decoder_built_in_info(
        decoder: *mut lv_img_decoder_t,
        src: *const cty::c_void,
        header: *mut lv_img_header_t,
    ) -> lv_res_t;
}
extern "C" {
    pub fn lv_img_decoder_built_in_open(
        decoder: *mut lv_img_decoder_t,
        dsc: *mut lv_img_decoder_dsc_t,
    ) -> lv_res_t;
}
extern "C" {
    pub fn lv_img_decoder_built_in_read_line(
        decoder: *mut lv_img_decoder_t,
        dsc: *mut lv_img_decoder_dsc_t,
        x: lv_coord_t,
        y: lv_coord_t,
        len: lv_coord_t,
        buf: *mut u8,
    ) -> lv_res_t;
}
extern "C" {
    pub fn lv_img_decoder_built_in_close(
        decoder: *mut lv_img_decoder_t,
        dsc: *mut lv_img_decoder_dsc_t,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_draw_img_dsc_t {
    pub opa: lv_opa_t,
    pub angle: u16,
    pub pivot: lv_point_t,
    pub zoom: u16,
    pub recolor_opa: lv_opa_t,
    pub recolor: lv_color_t,
    pub blend_mode: lv_blend_mode_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl lv_draw_img_dsc_t {
    #[inline]
    pub fn antialias(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_antialias(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(antialias: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let antialias: u8 = unsafe { ::core::mem::transmute(antialias) };
            antialias as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn lv_draw_img_dsc_init(dsc: *mut lv_draw_img_dsc_t);
}
extern "C" {
    pub fn lv_draw_img(
        coords: *const lv_area_t,
        mask: *const lv_area_t,
        src: *const cty::c_void,
        dsc: *const lv_draw_img_dsc_t,
    );
}
extern "C" {
    pub fn lv_img_src_get_type(src: *const cty::c_void) -> lv_img_src_t;
}
extern "C" {
    pub fn lv_img_cf_get_px_size(cf: lv_img_cf_t) -> u8;
}
extern "C" {
    pub fn lv_img_cf_is_chroma_keyed(cf: lv_img_cf_t) -> bool;
}
extern "C" {
    pub fn lv_img_cf_has_alpha(cf: lv_img_cf_t) -> bool;
}
pub const LV_DESIGN_DRAW_MAIN: cty::c_int = 0;
pub const LV_DESIGN_DRAW_POST: cty::c_int = 1;
pub const LV_DESIGN_COVER_CHK: cty::c_int = 2;
pub type _bindgen_ty_27 = cty::c_int;
pub type lv_design_mode_t = u8;
pub const LV_DESIGN_RES_OK: cty::c_int = 0;
pub const LV_DESIGN_RES_COVER: cty::c_int = 1;
pub const LV_DESIGN_RES_NOT_COVER: cty::c_int = 2;
pub const LV_DESIGN_RES_MASKED: cty::c_int = 3;
pub type _bindgen_ty_28 = cty::c_int;
pub type lv_design_res_t = u8;
pub type lv_design_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: *mut _lv_obj_t,
        clip_area: *const lv_area_t,
        mode: lv_design_mode_t,
    ) -> lv_design_res_t,
>;
pub const LV_EVENT_PRESSED: cty::c_int = 0;
pub const LV_EVENT_PRESSING: cty::c_int = 1;
pub const LV_EVENT_PRESS_LOST: cty::c_int = 2;
pub const LV_EVENT_SHORT_CLICKED: cty::c_int = 3;
pub const LV_EVENT_LONG_PRESSED: cty::c_int = 4;
pub const LV_EVENT_LONG_PRESSED_REPEAT: cty::c_int = 5;
pub const LV_EVENT_CLICKED: cty::c_int = 6;
pub const LV_EVENT_RELEASED: cty::c_int = 7;
pub const LV_EVENT_DRAG_BEGIN: cty::c_int = 8;
pub const LV_EVENT_DRAG_END: cty::c_int = 9;
pub const LV_EVENT_DRAG_THROW_BEGIN: cty::c_int = 10;
pub const LV_EVENT_GESTURE: cty::c_int = 11;
pub const LV_EVENT_KEY: cty::c_int = 12;
pub const LV_EVENT_FOCUSED: cty::c_int = 13;
pub const LV_EVENT_DEFOCUSED: cty::c_int = 14;
pub const LV_EVENT_LEAVE: cty::c_int = 15;
pub const LV_EVENT_VALUE_CHANGED: cty::c_int = 16;
pub const LV_EVENT_INSERT: cty::c_int = 17;
pub const LV_EVENT_REFRESH: cty::c_int = 18;
pub const LV_EVENT_APPLY: cty::c_int = 19;
pub const LV_EVENT_CANCEL: cty::c_int = 20;
pub const LV_EVENT_DELETE: cty::c_int = 21;
pub const _LV_EVENT_LAST: cty::c_int = 22;
pub type _bindgen_ty_29 = cty::c_int;
pub type lv_event_t = u8;
pub type lv_event_cb_t =
    ::core::option::Option<unsafe extern "C" fn(obj: *mut _lv_obj_t, event: lv_event_t)>;
pub const LV_SIGNAL_CLEANUP: cty::c_int = 0;
pub const LV_SIGNAL_CHILD_CHG: cty::c_int = 1;
pub const LV_SIGNAL_COORD_CHG: cty::c_int = 2;
pub const LV_SIGNAL_PARENT_SIZE_CHG: cty::c_int = 3;
pub const LV_SIGNAL_STYLE_CHG: cty::c_int = 4;
pub const LV_SIGNAL_BASE_DIR_CHG: cty::c_int = 5;
pub const LV_SIGNAL_REFR_EXT_DRAW_PAD: cty::c_int = 6;
pub const LV_SIGNAL_GET_TYPE: cty::c_int = 7;
pub const LV_SIGNAL_GET_STYLE: cty::c_int = 8;
pub const LV_SIGNAL_GET_STATE_DSC: cty::c_int = 9;
pub const LV_SIGNAL_HIT_TEST: cty::c_int = 10;
pub const LV_SIGNAL_PRESSED: cty::c_int = 11;
pub const LV_SIGNAL_PRESSING: cty::c_int = 12;
pub const LV_SIGNAL_PRESS_LOST: cty::c_int = 13;
pub const LV_SIGNAL_RELEASED: cty::c_int = 14;
pub const LV_SIGNAL_LONG_PRESS: cty::c_int = 15;
pub const LV_SIGNAL_LONG_PRESS_REP: cty::c_int = 16;
pub const LV_SIGNAL_DRAG_BEGIN: cty::c_int = 17;
pub const LV_SIGNAL_DRAG_THROW_BEGIN: cty::c_int = 18;
pub const LV_SIGNAL_DRAG_END: cty::c_int = 19;
pub const LV_SIGNAL_GESTURE: cty::c_int = 20;
pub const LV_SIGNAL_LEAVE: cty::c_int = 21;
pub const LV_SIGNAL_FOCUS: cty::c_int = 22;
pub const LV_SIGNAL_DEFOCUS: cty::c_int = 23;
pub const LV_SIGNAL_CONTROL: cty::c_int = 24;
pub const LV_SIGNAL_GET_EDITABLE: cty::c_int = 25;
pub type _bindgen_ty_30 = cty::c_int;
pub type lv_signal_t = u8;
pub type lv_signal_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        obj: *mut _lv_obj_t,
        sign: lv_signal_t,
        param: *mut cty::c_void,
    ) -> lv_res_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_realign_t {
    pub base: *const _lv_obj_t,
    pub xofs: lv_coord_t,
    pub yofs: lv_coord_t,
    pub align: lv_align_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
}
impl lv_realign_t {
    #[inline]
    pub fn auto_realign(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auto_realign(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mid_align(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mid_align(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(auto_realign: u8, mid_align: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let auto_realign: u8 = unsafe { ::core::mem::transmute(auto_realign) };
            auto_realign as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let mid_align: u8 = unsafe { ::core::mem::transmute(mid_align) };
            mid_align as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_PROTECT_NONE: cty::c_int = 0;
pub const LV_PROTECT_CHILD_CHG: cty::c_int = 1;
pub const LV_PROTECT_PARENT: cty::c_int = 2;
pub const LV_PROTECT_POS: cty::c_int = 4;
pub const LV_PROTECT_FOLLOW: cty::c_int = 8;
pub const LV_PROTECT_PRESS_LOST: cty::c_int = 16;
pub const LV_PROTECT_CLICK_FOCUS: cty::c_int = 32;
pub const LV_PROTECT_EVENT_TO_DISABLED: cty::c_int = 64;
pub type _bindgen_ty_31 = cty::c_int;
pub type lv_protect_t = u8;
pub const LV_STATE_DEFAULT: cty::c_int = 0;
pub const LV_STATE_CHECKED: cty::c_int = 1;
pub const LV_STATE_FOCUSED: cty::c_int = 2;
pub const LV_STATE_EDITED: cty::c_int = 4;
pub const LV_STATE_HOVERED: cty::c_int = 8;
pub const LV_STATE_PRESSED: cty::c_int = 16;
pub const LV_STATE_DISABLED: cty::c_int = 32;
pub type _bindgen_ty_32 = cty::c_int;
pub type lv_state_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_obj_t {
    pub parent: *mut _lv_obj_t,
    pub child_ll: lv_ll_t,
    pub coords: lv_area_t,
    pub event_cb: lv_event_cb_t,
    pub signal_cb: lv_signal_cb_t,
    pub design_cb: lv_design_cb_t,
    pub ext_attr: *mut cty::c_void,
    pub style_list: lv_style_list_t,
    pub ext_click_pad_hor: u8,
    pub ext_click_pad_ver: u8,
    pub ext_draw_pad: lv_coord_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub group_p: *mut cty::c_void,
    pub protect: u8,
    pub state: lv_state_t,
    pub realign: lv_realign_t,
    pub user_data: lv_obj_user_data_t,
}
impl _lv_obj_t {
    #[inline]
    pub fn click(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_click(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_throw(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_throw(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_parent(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_parent(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hidden(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hidden(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn top(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_top(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn parent_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_parent_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn adv_hittest(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_adv_hittest(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gesture_parent(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gesture_parent(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn focus_parent(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_focus_parent(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_dir(&self) -> lv_drag_dir_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_drag_dir(&mut self, val: lv_drag_dir_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn base_dir(&self) -> lv_bidi_dir_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_base_dir(&mut self, val: lv_bidi_dir_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        click: u8,
        drag: u8,
        drag_throw: u8,
        drag_parent: u8,
        hidden: u8,
        top: u8,
        parent_event: u8,
        adv_hittest: u8,
        gesture_parent: u8,
        focus_parent: u8,
        drag_dir: lv_drag_dir_t,
        base_dir: lv_bidi_dir_t,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let click: u8 = unsafe { ::core::mem::transmute(click) };
            click as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let drag: u8 = unsafe { ::core::mem::transmute(drag) };
            drag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let drag_throw: u8 = unsafe { ::core::mem::transmute(drag_throw) };
            drag_throw as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let drag_parent: u8 = unsafe { ::core::mem::transmute(drag_parent) };
            drag_parent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let hidden: u8 = unsafe { ::core::mem::transmute(hidden) };
            hidden as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let top: u8 = unsafe { ::core::mem::transmute(top) };
            top as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let parent_event: u8 = unsafe { ::core::mem::transmute(parent_event) };
            parent_event as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let adv_hittest: u8 = unsafe { ::core::mem::transmute(adv_hittest) };
            adv_hittest as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let gesture_parent: u8 = unsafe { ::core::mem::transmute(gesture_parent) };
            gesture_parent as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let focus_parent: u8 = unsafe { ::core::mem::transmute(focus_parent) };
            focus_parent as u64
        });
        __bindgen_bitfield_unit.set(10usize, 3u8, {
            let drag_dir: u8 = unsafe { ::core::mem::transmute(drag_dir) };
            drag_dir as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let base_dir: u8 = unsafe { ::core::mem::transmute(base_dir) };
            base_dir as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_obj_t = _lv_obj_t;
pub const LV_OBJ_PART_MAIN: cty::c_int = 0;
pub const _LV_OBJ_PART_VIRTUAL_LAST: cty::c_int = 1;
pub const _LV_OBJ_PART_REAL_LAST: cty::c_int = 64;
pub const LV_OBJ_PART_ALL: cty::c_int = 255;
pub type _bindgen_ty_33 = cty::c_int;
pub type lv_obj_part_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_obj_type_t {
    pub type_: [*const cty::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_hit_test_info_t {
    pub point: *mut lv_point_t,
    pub result: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_get_style_info_t {
    pub part: u8,
    pub result: *mut lv_style_list_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_get_state_info_t {
    pub part: u8,
    pub result: lv_state_t,
}
extern "C" {
    pub fn lv_init();
}
extern "C" {
    pub fn lv_deinit();
}
extern "C" {
    pub fn lv_obj_create(parent: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_obj_del(obj: *mut lv_obj_t) -> lv_res_t;
}
extern "C" {
    pub fn lv_obj_del_anim_ready_cb(a: *mut lv_anim_t);
}
extern "C" {
    pub fn lv_obj_del_async(obj: *mut _lv_obj_t);
}
extern "C" {
    pub fn lv_obj_clean(obj: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_obj_invalidate_area(obj: *const lv_obj_t, area: *const lv_area_t);
}
extern "C" {
    pub fn lv_obj_invalidate(obj: *const lv_obj_t);
}
extern "C" {
    pub fn lv_obj_area_is_visible(obj: *const lv_obj_t, area: *mut lv_area_t) -> bool;
}
extern "C" {
    pub fn lv_obj_is_visible(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_obj_set_parent(obj: *mut lv_obj_t, parent: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_obj_move_foreground(obj: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_obj_move_background(obj: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_obj_set_pos(obj: *mut lv_obj_t, x: lv_coord_t, y: lv_coord_t);
}
extern "C" {
    pub fn lv_obj_set_x(obj: *mut lv_obj_t, x: lv_coord_t);
}
extern "C" {
    pub fn lv_obj_set_y(obj: *mut lv_obj_t, y: lv_coord_t);
}
extern "C" {
    pub fn lv_obj_set_size(obj: *mut lv_obj_t, w: lv_coord_t, h: lv_coord_t);
}
extern "C" {
    pub fn lv_obj_set_width(obj: *mut lv_obj_t, w: lv_coord_t);
}
extern "C" {
    pub fn lv_obj_set_height(obj: *mut lv_obj_t, h: lv_coord_t);
}
extern "C" {
    pub fn lv_obj_set_width_fit(obj: *mut lv_obj_t, w: lv_coord_t);
}
extern "C" {
    pub fn lv_obj_set_height_fit(obj: *mut lv_obj_t, h: lv_coord_t);
}
extern "C" {
    pub fn lv_obj_set_width_margin(obj: *mut lv_obj_t, w: lv_coord_t);
}
extern "C" {
    pub fn lv_obj_set_height_margin(obj: *mut lv_obj_t, h: lv_coord_t);
}
extern "C" {
    pub fn lv_obj_align(
        obj: *mut lv_obj_t,
        base: *const lv_obj_t,
        align: lv_align_t,
        x_ofs: lv_coord_t,
        y_ofs: lv_coord_t,
    );
}
extern "C" {
    pub fn lv_obj_align_x(
        obj: *mut lv_obj_t,
        base: *const lv_obj_t,
        align: lv_align_t,
        x_ofs: lv_coord_t,
    );
}
extern "C" {
    pub fn lv_obj_align_y(
        obj: *mut lv_obj_t,
        base: *const lv_obj_t,
        align: lv_align_t,
        y_ofs: lv_coord_t,
    );
}
extern "C" {
    pub fn lv_obj_align_mid(
        obj: *mut lv_obj_t,
        base: *const lv_obj_t,
        align: lv_align_t,
        x_ofs: lv_coord_t,
        y_ofs: lv_coord_t,
    );
}
extern "C" {
    pub fn lv_obj_align_mid_x(
        obj: *mut lv_obj_t,
        base: *const lv_obj_t,
        align: lv_align_t,
        x_ofs: lv_coord_t,
    );
}
extern "C" {
    pub fn lv_obj_align_mid_y(
        obj: *mut lv_obj_t,
        base: *const lv_obj_t,
        align: lv_align_t,
        y_ofs: lv_coord_t,
    );
}
extern "C" {
    pub fn lv_obj_realign(obj: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_obj_set_auto_realign(obj: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_obj_set_ext_click_area(
        obj: *mut lv_obj_t,
        left: lv_coord_t,
        right: lv_coord_t,
        top: lv_coord_t,
        bottom: lv_coord_t,
    );
}
extern "C" {
    pub fn lv_obj_add_style(obj: *mut lv_obj_t, part: u8, style: *mut lv_style_t);
}
extern "C" {
    pub fn lv_obj_remove_style(obj: *mut lv_obj_t, part: u8, style: *mut lv_style_t);
}
extern "C" {
    pub fn lv_obj_clean_style_list(obj: *mut lv_obj_t, part: u8);
}
extern "C" {
    pub fn lv_obj_reset_style_list(obj: *mut lv_obj_t, part: u8);
}
extern "C" {
    pub fn lv_obj_refresh_style(obj: *mut lv_obj_t, part: u8, prop: lv_style_property_t);
}
extern "C" {
    pub fn lv_obj_report_style_mod(style: *mut lv_style_t);
}
extern "C" {
    pub fn _lv_obj_set_style_local_color(
        obj: *mut lv_obj_t,
        type_: u8,
        prop: lv_style_property_t,
        color: lv_color_t,
    );
}
extern "C" {
    pub fn _lv_obj_set_style_local_int(
        obj: *mut lv_obj_t,
        type_: u8,
        prop: lv_style_property_t,
        value: lv_style_int_t,
    );
}
extern "C" {
    pub fn _lv_obj_set_style_local_opa(
        obj: *mut lv_obj_t,
        type_: u8,
        prop: lv_style_property_t,
        opa: lv_opa_t,
    );
}
extern "C" {
    pub fn _lv_obj_set_style_local_ptr(
        obj: *mut lv_obj_t,
        type_: u8,
        prop: lv_style_property_t,
        value: *const cty::c_void,
    );
}
extern "C" {
    pub fn lv_obj_remove_style_local_prop(
        obj: *mut lv_obj_t,
        part: u8,
        prop: lv_style_property_t,
    ) -> bool;
}
extern "C" {
    pub fn _lv_obj_disable_style_caching(obj: *mut lv_obj_t, dis: bool);
}
extern "C" {
    pub fn lv_obj_set_hidden(obj: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_obj_set_adv_hittest(obj: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_obj_set_click(obj: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_obj_set_top(obj: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_obj_set_drag(obj: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_obj_set_drag_dir(obj: *mut lv_obj_t, drag_dir: lv_drag_dir_t);
}
extern "C" {
    pub fn lv_obj_set_drag_throw(obj: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_obj_set_drag_parent(obj: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_obj_set_focus_parent(obj: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_obj_set_gesture_parent(obj: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_obj_set_parent_event(obj: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_obj_set_base_dir(obj: *mut lv_obj_t, dir: lv_bidi_dir_t);
}
extern "C" {
    pub fn lv_obj_add_protect(obj: *mut lv_obj_t, prot: u8);
}
extern "C" {
    pub fn lv_obj_clear_protect(obj: *mut lv_obj_t, prot: u8);
}
extern "C" {
    pub fn lv_obj_set_state(obj: *mut lv_obj_t, state: lv_state_t);
}
extern "C" {
    pub fn lv_obj_add_state(obj: *mut lv_obj_t, state: lv_state_t);
}
extern "C" {
    pub fn lv_obj_clear_state(obj: *mut lv_obj_t, state: lv_state_t);
}
extern "C" {
    pub fn lv_obj_finish_transitions(obj: *mut lv_obj_t, part: u8);
}
extern "C" {
    pub fn lv_obj_set_event_cb(obj: *mut lv_obj_t, event_cb: lv_event_cb_t);
}
extern "C" {
    pub fn lv_event_send(
        obj: *mut lv_obj_t,
        event: lv_event_t,
        data: *const cty::c_void,
    ) -> lv_res_t;
}
extern "C" {
    pub fn lv_event_send_refresh(obj: *mut lv_obj_t) -> lv_res_t;
}
extern "C" {
    pub fn lv_event_send_refresh_recursive(obj: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_event_send_func(
        event_xcb: lv_event_cb_t,
        obj: *mut lv_obj_t,
        event: lv_event_t,
        data: *const cty::c_void,
    ) -> lv_res_t;
}
extern "C" {
    pub fn lv_event_get_data() -> *const cty::c_void;
}
extern "C" {
    pub fn lv_obj_set_signal_cb(obj: *mut lv_obj_t, signal_cb: lv_signal_cb_t);
}
extern "C" {
    pub fn lv_signal_send(
        obj: *mut lv_obj_t,
        signal: lv_signal_t,
        param: *mut cty::c_void,
    ) -> lv_res_t;
}
extern "C" {
    pub fn lv_obj_set_design_cb(obj: *mut lv_obj_t, design_cb: lv_design_cb_t);
}
extern "C" {
    pub fn lv_obj_allocate_ext_attr(obj: *mut lv_obj_t, ext_size: u16) -> *mut cty::c_void;
}
extern "C" {
    pub fn lv_obj_refresh_ext_draw_pad(obj: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_obj_get_screen(obj: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_obj_get_disp(obj: *const lv_obj_t) -> *mut lv_disp_t;
}
extern "C" {
    pub fn lv_obj_get_parent(obj: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_obj_get_child(obj: *const lv_obj_t, child: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_obj_get_child_back(obj: *const lv_obj_t, child: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_obj_count_children(obj: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_obj_count_children_recursive(obj: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_obj_get_coords(obj: *const lv_obj_t, cords_p: *mut lv_area_t);
}
extern "C" {
    pub fn lv_obj_get_inner_coords(obj: *const lv_obj_t, coords_p: *mut lv_area_t);
}
extern "C" {
    pub fn lv_obj_get_x(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_obj_get_y(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_obj_get_width(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_obj_get_height(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_obj_get_width_fit(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_obj_get_height_fit(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_obj_get_height_margin(obj: *mut lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_obj_get_width_margin(obj: *mut lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_obj_get_width_grid(obj: *mut lv_obj_t, div: u8, span: u8) -> lv_coord_t;
}
extern "C" {
    pub fn lv_obj_get_height_grid(obj: *mut lv_obj_t, div: u8, span: u8) -> lv_coord_t;
}
extern "C" {
    pub fn lv_obj_get_auto_realign(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_obj_get_ext_click_pad_left(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_obj_get_ext_click_pad_right(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_obj_get_ext_click_pad_top(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_obj_get_ext_click_pad_bottom(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_obj_get_ext_draw_pad(obj: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_obj_get_style_list(obj: *const lv_obj_t, part: u8) -> *mut lv_style_list_t;
}
extern "C" {
    pub fn _lv_obj_get_style_int(
        obj: *const lv_obj_t,
        part: u8,
        prop: lv_style_property_t,
    ) -> lv_style_int_t;
}
extern "C" {
    pub fn _lv_obj_get_style_color(
        obj: *const lv_obj_t,
        part: u8,
        prop: lv_style_property_t,
    ) -> lv_color_t;
}
extern "C" {
    pub fn _lv_obj_get_style_opa(
        obj: *const lv_obj_t,
        part: u8,
        prop: lv_style_property_t,
    ) -> lv_opa_t;
}
extern "C" {
    pub fn _lv_obj_get_style_ptr(
        obj: *const lv_obj_t,
        part: u8,
        prop: lv_style_property_t,
    ) -> *const cty::c_void;
}
extern "C" {
    pub fn lv_obj_get_local_style(obj: *mut lv_obj_t, part: u8) -> *mut lv_style_t;
}
extern "C" {
    pub fn lv_obj_get_hidden(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_obj_get_adv_hittest(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_obj_get_click(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_obj_get_top(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_obj_get_drag(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_obj_get_drag_dir(obj: *const lv_obj_t) -> lv_drag_dir_t;
}
extern "C" {
    pub fn lv_obj_get_drag_throw(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_obj_get_drag_parent(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_obj_get_focus_parent(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_obj_get_parent_event(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_obj_get_gesture_parent(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_obj_get_base_dir(obj: *const lv_obj_t) -> lv_bidi_dir_t;
}
extern "C" {
    pub fn lv_obj_get_protect(obj: *const lv_obj_t) -> u8;
}
extern "C" {
    pub fn lv_obj_is_protected(obj: *const lv_obj_t, prot: u8) -> bool;
}
extern "C" {
    pub fn lv_obj_get_state(obj: *const lv_obj_t, part: u8) -> lv_state_t;
}
extern "C" {
    pub fn lv_obj_get_signal_cb(obj: *const lv_obj_t) -> lv_signal_cb_t;
}
extern "C" {
    pub fn lv_obj_get_design_cb(obj: *const lv_obj_t) -> lv_design_cb_t;
}
extern "C" {
    pub fn lv_obj_get_event_cb(obj: *const lv_obj_t) -> lv_event_cb_t;
}
extern "C" {
    pub fn lv_obj_is_point_on_coords(obj: *mut lv_obj_t, point: *const lv_point_t) -> bool;
}
extern "C" {
    pub fn lv_obj_hittest(obj: *mut lv_obj_t, point: *mut lv_point_t) -> bool;
}
extern "C" {
    pub fn lv_obj_get_ext_attr(obj: *const lv_obj_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lv_obj_get_type(obj: *const lv_obj_t, buf: *mut lv_obj_type_t);
}
extern "C" {
    pub fn lv_obj_get_user_data(obj: *const lv_obj_t) -> lv_obj_user_data_t;
}
extern "C" {
    pub fn lv_obj_get_user_data_ptr(obj: *const lv_obj_t) -> *mut lv_obj_user_data_t;
}
extern "C" {
    pub fn lv_obj_set_user_data(obj: *mut lv_obj_t, data: lv_obj_user_data_t);
}
extern "C" {
    pub fn lv_obj_get_group(obj: *const lv_obj_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn lv_obj_is_focused(obj: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_obj_get_focused_obj(obj: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_obj_handle_get_type_signal(
        buf: *mut lv_obj_type_t,
        name: *const cty::c_char,
    ) -> lv_res_t;
}
extern "C" {
    pub fn lv_obj_init_draw_rect_dsc(
        obj: *mut lv_obj_t,
        type_: u8,
        draw_dsc: *mut lv_draw_rect_dsc_t,
    );
}
extern "C" {
    pub fn lv_obj_init_draw_label_dsc(
        obj: *mut lv_obj_t,
        type_: u8,
        draw_dsc: *mut lv_draw_label_dsc_t,
    );
}
extern "C" {
    pub fn lv_obj_init_draw_img_dsc(obj: *mut lv_obj_t, part: u8, draw_dsc: *mut lv_draw_img_dsc_t);
}
extern "C" {
    pub fn lv_obj_init_draw_line_dsc(
        obj: *mut lv_obj_t,
        part: u8,
        draw_dsc: *mut lv_draw_line_dsc_t,
    );
}
extern "C" {
    pub fn lv_obj_get_draw_rect_ext_pad_size(obj: *mut lv_obj_t, part: u8) -> lv_coord_t;
}
extern "C" {
    pub fn lv_obj_fade_in(obj: *mut lv_obj_t, time: u32, delay: u32);
}
extern "C" {
    pub fn lv_obj_fade_out(obj: *mut lv_obj_t, time: u32, delay: u32);
}
extern "C" {
    pub fn lv_debug_check_obj_type(obj: *const lv_obj_t, obj_type: *const cty::c_char) -> bool;
}
extern "C" {
    pub fn lv_debug_check_obj_valid(obj: *const lv_obj_t) -> bool;
}
pub const LV_KEY_UP: cty::c_int = 17;
pub const LV_KEY_DOWN: cty::c_int = 18;
pub const LV_KEY_RIGHT: cty::c_int = 19;
pub const LV_KEY_LEFT: cty::c_int = 20;
pub const LV_KEY_ESC: cty::c_int = 27;
pub const LV_KEY_DEL: cty::c_int = 127;
pub const LV_KEY_BACKSPACE: cty::c_int = 8;
pub const LV_KEY_ENTER: cty::c_int = 10;
pub const LV_KEY_NEXT: cty::c_int = 9;
pub const LV_KEY_PREV: cty::c_int = 11;
pub const LV_KEY_HOME: cty::c_int = 2;
pub const LV_KEY_END: cty::c_int = 3;
pub type _bindgen_ty_34 = cty::c_int;
pub type lv_key_t = u8;
pub type lv_group_style_mod_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_group_t, arg2: *mut lv_style_t)>;
pub type lv_group_focus_cb_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut _lv_group_t)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lv_group_t {
    pub obj_ll: lv_ll_t,
    pub obj_focus: *mut *mut lv_obj_t,
    pub focus_cb: lv_group_focus_cb_t,
    pub user_data: lv_group_user_data_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl _lv_group_t {
    #[inline]
    pub fn frozen(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_frozen(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn editing(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_editing(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn click_focus(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_click_focus(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn refocus_policy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_refocus_policy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wrap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wrap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        frozen: u8,
        editing: u8,
        click_focus: u8,
        refocus_policy: u8,
        wrap: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let frozen: u8 = unsafe { ::core::mem::transmute(frozen) };
            frozen as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let editing: u8 = unsafe { ::core::mem::transmute(editing) };
            editing as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let click_focus: u8 = unsafe { ::core::mem::transmute(click_focus) };
            click_focus as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let refocus_policy: u8 = unsafe { ::core::mem::transmute(refocus_policy) };
            refocus_policy as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let wrap: u8 = unsafe { ::core::mem::transmute(wrap) };
            wrap as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type lv_group_t = _lv_group_t;
pub const LV_GROUP_REFOCUS_POLICY_NEXT: cty::c_int = 0;
pub const LV_GROUP_REFOCUS_POLICY_PREV: cty::c_int = 1;
pub type _bindgen_ty_35 = cty::c_int;
pub type lv_group_refocus_policy_t = u8;
extern "C" {
    pub fn _lv_group_init();
}
extern "C" {
    pub fn lv_group_create() -> *mut lv_group_t;
}
extern "C" {
    pub fn lv_group_del(group: *mut lv_group_t);
}
extern "C" {
    pub fn lv_group_add_obj(group: *mut lv_group_t, obj: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_group_remove_obj(obj: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_group_remove_all_objs(group: *mut lv_group_t);
}
extern "C" {
    pub fn lv_group_focus_obj(obj: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_group_focus_next(group: *mut lv_group_t);
}
extern "C" {
    pub fn lv_group_focus_prev(group: *mut lv_group_t);
}
extern "C" {
    pub fn lv_group_focus_freeze(group: *mut lv_group_t, en: bool);
}
extern "C" {
    pub fn lv_group_send_data(group: *mut lv_group_t, c: u32) -> lv_res_t;
}
extern "C" {
    pub fn lv_group_set_focus_cb(group: *mut lv_group_t, focus_cb: lv_group_focus_cb_t);
}
extern "C" {
    pub fn lv_group_set_refocus_policy(group: *mut lv_group_t, policy: lv_group_refocus_policy_t);
}
extern "C" {
    pub fn lv_group_set_editing(group: *mut lv_group_t, edit: bool);
}
extern "C" {
    pub fn lv_group_set_click_focus(group: *mut lv_group_t, en: bool);
}
extern "C" {
    pub fn lv_group_set_wrap(group: *mut lv_group_t, en: bool);
}
extern "C" {
    pub fn lv_group_get_focused(group: *const lv_group_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_group_get_user_data(group: *mut lv_group_t) -> *mut lv_group_user_data_t;
}
extern "C" {
    pub fn lv_group_get_focus_cb(group: *const lv_group_t) -> lv_group_focus_cb_t;
}
extern "C" {
    pub fn lv_group_get_editing(group: *const lv_group_t) -> bool;
}
extern "C" {
    pub fn lv_group_get_click_focus(group: *const lv_group_t) -> bool;
}
extern "C" {
    pub fn lv_group_get_wrap(group: *mut lv_group_t) -> bool;
}
extern "C" {
    pub fn _lv_indev_init();
}
extern "C" {
    pub fn _lv_indev_read_task(task: *mut lv_task_t);
}
extern "C" {
    pub fn lv_indev_get_act() -> *mut lv_indev_t;
}
extern "C" {
    pub fn lv_indev_get_type(indev: *const lv_indev_t) -> lv_indev_type_t;
}
extern "C" {
    pub fn lv_indev_reset(indev: *mut lv_indev_t, obj: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_indev_reset_long_press(indev: *mut lv_indev_t);
}
extern "C" {
    pub fn lv_indev_enable(indev: *mut lv_indev_t, en: bool);
}
extern "C" {
    pub fn lv_indev_set_cursor(indev: *mut lv_indev_t, cur_obj: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_indev_set_group(indev: *mut lv_indev_t, group: *mut lv_group_t);
}
extern "C" {
    pub fn lv_indev_set_button_points(indev: *mut lv_indev_t, points: *const lv_point_t);
}
extern "C" {
    pub fn lv_indev_get_point(indev: *const lv_indev_t, point: *mut lv_point_t);
}
extern "C" {
    pub fn lv_indev_get_gesture_dir(indev: *const lv_indev_t) -> lv_gesture_dir_t;
}
extern "C" {
    pub fn lv_indev_get_key(indev: *const lv_indev_t) -> u32;
}
extern "C" {
    pub fn lv_indev_is_dragging(indev: *const lv_indev_t) -> bool;
}
extern "C" {
    pub fn lv_indev_get_vect(indev: *const lv_indev_t, point: *mut lv_point_t);
}
extern "C" {
    pub fn lv_indev_finish_drag(indev: *mut lv_indev_t) -> lv_res_t;
}
extern "C" {
    pub fn lv_indev_wait_release(indev: *mut lv_indev_t);
}
extern "C" {
    pub fn lv_indev_get_obj_act() -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_indev_search_obj(obj: *mut lv_obj_t, point: *mut lv_point_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_indev_get_read_task(indev: *mut lv_disp_t) -> *mut lv_task_t;
}
extern "C" {
    pub fn _lv_refr_init();
}
extern "C" {
    pub fn lv_refr_now(disp: *mut lv_disp_t);
}
extern "C" {
    pub fn _lv_inv_area(disp: *mut lv_disp_t, area_p: *const lv_area_t);
}
extern "C" {
    pub fn _lv_refr_get_disp_refreshing() -> *mut lv_disp_t;
}
extern "C" {
    pub fn _lv_refr_set_disp_refreshing(disp: *mut lv_disp_t);
}
extern "C" {
    pub fn _lv_disp_refr_task(task: *mut lv_task_t);
}
pub const lv_scr_load_anim_t_LV_SCR_LOAD_ANIM_NONE: lv_scr_load_anim_t = 0;
pub const lv_scr_load_anim_t_LV_SCR_LOAD_ANIM_OVER_LEFT: lv_scr_load_anim_t = 1;
pub const lv_scr_load_anim_t_LV_SCR_LOAD_ANIM_OVER_RIGHT: lv_scr_load_anim_t = 2;
pub const lv_scr_load_anim_t_LV_SCR_LOAD_ANIM_OVER_TOP: lv_scr_load_anim_t = 3;
pub const lv_scr_load_anim_t_LV_SCR_LOAD_ANIM_OVER_BOTTOM: lv_scr_load_anim_t = 4;
pub const lv_scr_load_anim_t_LV_SCR_LOAD_ANIM_MOVE_LEFT: lv_scr_load_anim_t = 5;
pub const lv_scr_load_anim_t_LV_SCR_LOAD_ANIM_MOVE_RIGHT: lv_scr_load_anim_t = 6;
pub const lv_scr_load_anim_t_LV_SCR_LOAD_ANIM_MOVE_TOP: lv_scr_load_anim_t = 7;
pub const lv_scr_load_anim_t_LV_SCR_LOAD_ANIM_MOVE_BOTTOM: lv_scr_load_anim_t = 8;
pub const lv_scr_load_anim_t_LV_SCR_LOAD_ANIM_FADE_ON: lv_scr_load_anim_t = 9;
pub type lv_scr_load_anim_t = cty::c_int;
extern "C" {
    pub fn lv_disp_get_scr_act(disp: *mut lv_disp_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_disp_get_scr_prev(disp: *mut lv_disp_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_disp_load_scr(scr: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_disp_get_layer_top(disp: *mut lv_disp_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_disp_get_layer_sys(disp: *mut lv_disp_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_disp_assign_screen(disp: *mut lv_disp_t, scr: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_disp_set_bg_color(disp: *mut lv_disp_t, color: lv_color_t);
}
extern "C" {
    pub fn lv_disp_set_bg_image(disp: *mut lv_disp_t, img_src: *const cty::c_void);
}
extern "C" {
    pub fn lv_disp_set_bg_opa(disp: *mut lv_disp_t, opa: lv_opa_t);
}
extern "C" {
    pub fn lv_scr_load_anim(
        scr: *mut lv_obj_t,
        anim_type: lv_scr_load_anim_t,
        time: u32,
        delay: u32,
        auto_del: bool,
    );
}
extern "C" {
    pub fn lv_disp_get_inactive_time(disp: *const lv_disp_t) -> u32;
}
extern "C" {
    pub fn lv_disp_trig_activity(disp: *mut lv_disp_t);
}
extern "C" {
    pub fn lv_disp_clean_dcache(disp: *mut lv_disp_t);
}
extern "C" {
    pub fn _lv_disp_get_refr_task(disp: *mut lv_disp_t) -> *mut lv_task_t;
}
pub const lv_theme_style_t_LV_THEME_NONE: lv_theme_style_t = 0;
pub const lv_theme_style_t_LV_THEME_SCR: lv_theme_style_t = 1;
pub const lv_theme_style_t_LV_THEME_OBJ: lv_theme_style_t = 2;
pub const lv_theme_style_t_LV_THEME_ARC: lv_theme_style_t = 3;
pub const lv_theme_style_t_LV_THEME_BAR: lv_theme_style_t = 4;
pub const lv_theme_style_t_LV_THEME_BTN: lv_theme_style_t = 5;
pub const lv_theme_style_t_LV_THEME_BTNMATRIX: lv_theme_style_t = 6;
pub const lv_theme_style_t_LV_THEME_CALENDAR: lv_theme_style_t = 7;
pub const lv_theme_style_t_LV_THEME_CANVAS: lv_theme_style_t = 8;
pub const lv_theme_style_t_LV_THEME_CHECKBOX: lv_theme_style_t = 9;
pub const lv_theme_style_t_LV_THEME_CHART: lv_theme_style_t = 10;
pub const lv_theme_style_t_LV_THEME_CONT: lv_theme_style_t = 11;
pub const lv_theme_style_t_LV_THEME_CPICKER: lv_theme_style_t = 12;
pub const lv_theme_style_t_LV_THEME_DROPDOWN: lv_theme_style_t = 13;
pub const lv_theme_style_t_LV_THEME_GAUGE: lv_theme_style_t = 14;
pub const lv_theme_style_t_LV_THEME_IMAGE: lv_theme_style_t = 15;
pub const lv_theme_style_t_LV_THEME_IMGBTN: lv_theme_style_t = 16;
pub const lv_theme_style_t_LV_THEME_KEYBOARD: lv_theme_style_t = 17;
pub const lv_theme_style_t_LV_THEME_LABEL: lv_theme_style_t = 18;
pub const lv_theme_style_t_LV_THEME_LED: lv_theme_style_t = 19;
pub const lv_theme_style_t_LV_THEME_LINE: lv_theme_style_t = 20;
pub const lv_theme_style_t_LV_THEME_LIST: lv_theme_style_t = 21;
pub const lv_theme_style_t_LV_THEME_LIST_BTN: lv_theme_style_t = 22;
pub const lv_theme_style_t_LV_THEME_LINEMETER: lv_theme_style_t = 23;
pub const lv_theme_style_t_LV_THEME_MSGBOX: lv_theme_style_t = 24;
pub const lv_theme_style_t_LV_THEME_MSGBOX_BTNS: lv_theme_style_t = 25;
pub const lv_theme_style_t_LV_THEME_OBJMASK: lv_theme_style_t = 26;
pub const lv_theme_style_t_LV_THEME_PAGE: lv_theme_style_t = 27;
pub const lv_theme_style_t_LV_THEME_ROLLER: lv_theme_style_t = 28;
pub const lv_theme_style_t_LV_THEME_SLIDER: lv_theme_style_t = 29;
pub const lv_theme_style_t_LV_THEME_SPINBOX: lv_theme_style_t = 30;
pub const lv_theme_style_t_LV_THEME_SPINBOX_BTN: lv_theme_style_t = 31;
pub const lv_theme_style_t_LV_THEME_SPINNER: lv_theme_style_t = 32;
pub const lv_theme_style_t_LV_THEME_SWITCH: lv_theme_style_t = 33;
pub const lv_theme_style_t_LV_THEME_TABLE: lv_theme_style_t = 34;
pub const lv_theme_style_t_LV_THEME_TABVIEW: lv_theme_style_t = 35;
pub const lv_theme_style_t_LV_THEME_TABVIEW_PAGE: lv_theme_style_t = 36;
pub const lv_theme_style_t_LV_THEME_TEXTAREA: lv_theme_style_t = 37;
pub const lv_theme_style_t_LV_THEME_TILEVIEW: lv_theme_style_t = 38;
pub const lv_theme_style_t_LV_THEME_WIN: lv_theme_style_t = 39;
pub const lv_theme_style_t_LV_THEME_WIN_BTN: lv_theme_style_t = 40;
pub const lv_theme_style_t__LV_THEME_BUILTIN_LAST: lv_theme_style_t = 41;
pub const lv_theme_style_t_LV_THEME_CUSTOM_START: lv_theme_style_t = 41;
pub const lv_theme_style_t__LV_THEME_CUSTOM_LAST: lv_theme_style_t = 65535;
pub type lv_theme_style_t = cty::c_int;
pub type lv_theme_apply_cb_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut _lv_theme_t, arg2: *mut lv_obj_t, arg3: lv_theme_style_t),
>;
pub type lv_theme_apply_xcb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut lv_obj_t, arg2: lv_theme_style_t)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _lv_theme_t {
    pub apply_cb: lv_theme_apply_cb_t,
    pub apply_xcb: lv_theme_apply_xcb_t,
    pub base: *mut _lv_theme_t,
    pub color_primary: lv_color_t,
    pub color_secondary: lv_color_t,
    pub font_small: *const lv_font_t,
    pub font_normal: *const lv_font_t,
    pub font_subtitle: *const lv_font_t,
    pub font_title: *const lv_font_t,
    pub flags: u32,
    pub user_data: *mut cty::c_void,
}
pub type lv_theme_t = _lv_theme_t;
extern "C" {
    pub fn lv_theme_set_act(th: *mut lv_theme_t);
}
extern "C" {
    pub fn lv_theme_get_act() -> *mut lv_theme_t;
}
extern "C" {
    pub fn lv_theme_apply(obj: *mut lv_obj_t, name: lv_theme_style_t);
}
extern "C" {
    pub fn lv_theme_copy(theme: *mut lv_theme_t, copy: *const lv_theme_t);
}
extern "C" {
    pub fn lv_theme_set_base(new_theme: *mut lv_theme_t, base: *mut lv_theme_t);
}
extern "C" {
    pub fn lv_theme_set_apply_cb(theme: *mut lv_theme_t, apply_cb: lv_theme_apply_cb_t);
}
extern "C" {
    pub fn lv_theme_get_font_small() -> *const lv_font_t;
}
extern "C" {
    pub fn lv_theme_get_font_normal() -> *const lv_font_t;
}
extern "C" {
    pub fn lv_theme_get_font_subtitle() -> *const lv_font_t;
}
extern "C" {
    pub fn lv_theme_get_font_title() -> *const lv_font_t;
}
extern "C" {
    pub fn lv_theme_get_color_primary() -> lv_color_t;
}
extern "C" {
    pub fn lv_theme_get_color_secondary() -> lv_color_t;
}
extern "C" {
    pub fn lv_theme_get_flags() -> u32;
}
extern "C" {
    pub fn lv_theme_empty_init(
        color_primary: lv_color_t,
        color_secondary: lv_color_t,
        flags: u32,
        font_small: *const lv_font_t,
        font_normal: *const lv_font_t,
        font_subtitle: *const lv_font_t,
        font_title: *const lv_font_t,
    ) -> *mut lv_theme_t;
}
extern "C" {
    pub fn lv_theme_template_init(
        color_primary: lv_color_t,
        color_secondary: lv_color_t,
        flags: u32,
        font_small: *const lv_font_t,
        font_normal: *const lv_font_t,
        font_subtitle: *const lv_font_t,
        font_title: *const lv_font_t,
    ) -> *mut lv_theme_t;
}
pub const lv_theme_material_flag_t_LV_THEME_MATERIAL_FLAG_DARK: lv_theme_material_flag_t = 1;
pub const lv_theme_material_flag_t_LV_THEME_MATERIAL_FLAG_LIGHT: lv_theme_material_flag_t = 2;
pub const lv_theme_material_flag_t_LV_THEME_MATERIAL_FLAG_NO_TRANSITION: lv_theme_material_flag_t =
    16;
pub const lv_theme_material_flag_t_LV_THEME_MATERIAL_FLAG_NO_FOCUS: lv_theme_material_flag_t = 32;
pub type lv_theme_material_flag_t = cty::c_int;
extern "C" {
    pub fn lv_theme_material_init(
        color_primary: lv_color_t,
        color_secondary: lv_color_t,
        flags: u32,
        font_small: *const lv_font_t,
        font_normal: *const lv_font_t,
        font_subtitle: *const lv_font_t,
        font_title: *const lv_font_t,
    ) -> *mut lv_theme_t;
}
extern "C" {
    pub fn lv_theme_mono_init(
        color_primary: lv_color_t,
        color_secondary: lv_color_t,
        flags: u32,
        font_small: *const lv_font_t,
        font_normal: *const lv_font_t,
        font_subtitle: *const lv_font_t,
        font_title: *const lv_font_t,
    ) -> *mut lv_theme_t;
}
extern "C" {
    pub fn lv_font_load(fontName: *const cty::c_char) -> *mut lv_font_t;
}
extern "C" {
    pub fn lv_font_free(font: *mut lv_font_t);
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct lv_font_fmt_txt_glyph_dsc_t {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub box_w: u8,
    pub box_h: u8,
    pub ofs_x: i8,
    pub ofs_y: i8,
}
impl lv_font_fmt_txt_glyph_dsc_t {
    #[inline]
    pub fn bitmap_index(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_bitmap_index(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn adv_w(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_adv_w(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(bitmap_index: u32, adv_w: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let bitmap_index: u32 = unsafe { ::core::mem::transmute(bitmap_index) };
            bitmap_index as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let adv_w: u32 = unsafe { ::core::mem::transmute(adv_w) };
            adv_w as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL: cty::c_int = 0;
pub const LV_FONT_FMT_TXT_CMAP_SPARSE_FULL: cty::c_int = 1;
pub const LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY: cty::c_int = 2;
pub const LV_FONT_FMT_TXT_CMAP_SPARSE_TINY: cty::c_int = 3;
pub type _bindgen_ty_36 = cty::c_int;
pub type lv_font_fmt_txt_cmap_type_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_font_fmt_txt_cmap_t {
    pub range_start: u32,
    pub range_length: u16,
    pub glyph_id_start: u16,
    pub unicode_list: *const u16,
    pub glyph_id_ofs_list: *const cty::c_void,
    pub list_length: u16,
    pub type_: lv_font_fmt_txt_cmap_type_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_font_fmt_txt_kern_pair_t {
    pub glyph_ids: *const cty::c_void,
    pub values: *const i8,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_padding_0: u32,
}
impl lv_font_fmt_txt_kern_pair_t {
    #[inline]
    pub fn pair_cnt(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_pair_cnt(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn glyph_ids_size(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_glyph_ids_size(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pair_cnt: u32,
        glyph_ids_size: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 30u8, {
            let pair_cnt: u32 = unsafe { ::core::mem::transmute(pair_cnt) };
            pair_cnt as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let glyph_ids_size: u32 = unsafe { ::core::mem::transmute(glyph_ids_size) };
            glyph_ids_size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_font_fmt_txt_kern_classes_t {
    pub class_pair_values: *const i8,
    pub left_class_mapping: *const u8,
    pub right_class_mapping: *const u8,
    pub left_class_cnt: u8,
    pub right_class_cnt: u8,
}
pub const lv_font_fmt_txt_bitmap_format_t_LV_FONT_FMT_TXT_PLAIN: lv_font_fmt_txt_bitmap_format_t =
    0;
pub const lv_font_fmt_txt_bitmap_format_t_LV_FONT_FMT_TXT_COMPRESSED:
    lv_font_fmt_txt_bitmap_format_t = 1;
pub const lv_font_fmt_txt_bitmap_format_t_LV_FONT_FMT_TXT_COMPRESSED_NO_PREFILTER:
    lv_font_fmt_txt_bitmap_format_t = 1;
pub type lv_font_fmt_txt_bitmap_format_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_font_fmt_txt_dsc_t {
    pub glyph_bitmap: *const u8,
    pub glyph_dsc: *const lv_font_fmt_txt_glyph_dsc_t,
    pub cmaps: *const lv_font_fmt_txt_cmap_t,
    pub kern_dsc: *const cty::c_void,
    pub kern_scale: u16,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub last_letter: u32,
    pub last_glyph_id: u32,
}
impl lv_font_fmt_txt_dsc_t {
    #[inline]
    pub fn cmap_num(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_cmap_num(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn bpp(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_bpp(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn kern_classes(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_kern_classes(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bitmap_format(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_bitmap_format(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cmap_num: u16,
        bpp: u16,
        kern_classes: u16,
        bitmap_format: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let cmap_num: u16 = unsafe { ::core::mem::transmute(cmap_num) };
            cmap_num as u64
        });
        __bindgen_bitfield_unit.set(9usize, 4u8, {
            let bpp: u16 = unsafe { ::core::mem::transmute(bpp) };
            bpp as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let kern_classes: u16 = unsafe { ::core::mem::transmute(kern_classes) };
            kern_classes as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let bitmap_format: u16 = unsafe { ::core::mem::transmute(bitmap_format) };
            bitmap_format as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn lv_font_get_bitmap_fmt_txt(font: *const lv_font_t, letter: u32) -> *const u8;
}
extern "C" {
    pub fn lv_font_get_glyph_dsc_fmt_txt(
        font: *const lv_font_t,
        dsc_out: *mut lv_font_glyph_dsc_t,
        unicode_letter: u32,
        unicode_letter_next: u32,
    ) -> bool;
}
extern "C" {
    pub fn _lv_font_clean_up_fmt_txt();
}
pub const LV_LAYOUT_OFF: cty::c_int = 0;
pub const LV_LAYOUT_CENTER: cty::c_int = 1;
pub const LV_LAYOUT_COLUMN_LEFT: cty::c_int = 2;
pub const LV_LAYOUT_COLUMN_MID: cty::c_int = 3;
pub const LV_LAYOUT_COLUMN_RIGHT: cty::c_int = 4;
pub const LV_LAYOUT_ROW_TOP: cty::c_int = 5;
pub const LV_LAYOUT_ROW_MID: cty::c_int = 6;
pub const LV_LAYOUT_ROW_BOTTOM: cty::c_int = 7;
pub const LV_LAYOUT_PRETTY_TOP: cty::c_int = 8;
pub const LV_LAYOUT_PRETTY_MID: cty::c_int = 9;
pub const LV_LAYOUT_PRETTY_BOTTOM: cty::c_int = 10;
pub const LV_LAYOUT_GRID: cty::c_int = 11;
pub const _LV_LAYOUT_LAST: cty::c_int = 12;
pub type _bindgen_ty_37 = cty::c_int;
pub type lv_layout_t = u8;
pub const LV_FIT_NONE: cty::c_int = 0;
pub const LV_FIT_TIGHT: cty::c_int = 1;
pub const LV_FIT_PARENT: cty::c_int = 2;
pub const LV_FIT_MAX: cty::c_int = 3;
pub const _LV_FIT_LAST: cty::c_int = 4;
pub type _bindgen_ty_38 = cty::c_int;
pub type lv_fit_t = u8;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct lv_cont_ext_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
impl lv_cont_ext_t {
    #[inline]
    pub fn layout(&self) -> lv_layout_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_layout(&mut self, val: lv_layout_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn fit_left(&self) -> lv_fit_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fit_left(&mut self, val: lv_fit_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fit_right(&self) -> lv_fit_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fit_right(&mut self, val: lv_fit_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fit_top(&self) -> lv_fit_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fit_top(&mut self, val: lv_fit_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn fit_bottom(&self) -> lv_fit_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fit_bottom(&mut self, val: lv_fit_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        layout: lv_layout_t,
        fit_left: lv_fit_t,
        fit_right: lv_fit_t,
        fit_top: lv_fit_t,
        fit_bottom: lv_fit_t,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let layout: u8 = unsafe { ::core::mem::transmute(layout) };
            layout as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let fit_left: u8 = unsafe { ::core::mem::transmute(fit_left) };
            fit_left as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let fit_right: u8 = unsafe { ::core::mem::transmute(fit_right) };
            fit_right as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let fit_top: u8 = unsafe { ::core::mem::transmute(fit_top) };
            fit_top as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let fit_bottom: u8 = unsafe { ::core::mem::transmute(fit_bottom) };
            fit_bottom as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_CONT_PART_MAIN: cty::c_int = 0;
pub const _LV_CONT_PART_VIRTUAL_LAST: cty::c_int = 1;
pub const _LV_CONT_PART_REAL_LAST: cty::c_int = 64;
pub type _bindgen_ty_39 = cty::c_int;
extern "C" {
    pub fn lv_cont_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_cont_set_layout(cont: *mut lv_obj_t, layout: lv_layout_t);
}
extern "C" {
    pub fn lv_cont_set_fit4(
        cont: *mut lv_obj_t,
        left: lv_fit_t,
        right: lv_fit_t,
        top: lv_fit_t,
        bottom: lv_fit_t,
    );
}
extern "C" {
    pub fn lv_cont_get_layout(cont: *const lv_obj_t) -> lv_layout_t;
}
extern "C" {
    pub fn lv_cont_get_fit_left(cont: *const lv_obj_t) -> lv_fit_t;
}
extern "C" {
    pub fn lv_cont_get_fit_right(cont: *const lv_obj_t) -> lv_fit_t;
}
extern "C" {
    pub fn lv_cont_get_fit_top(cont: *const lv_obj_t) -> lv_fit_t;
}
extern "C" {
    pub fn lv_cont_get_fit_bottom(cont: *const lv_obj_t) -> lv_fit_t;
}
pub const LV_BTN_STATE_RELEASED: cty::c_int = 0;
pub const LV_BTN_STATE_PRESSED: cty::c_int = 1;
pub const LV_BTN_STATE_DISABLED: cty::c_int = 2;
pub const LV_BTN_STATE_CHECKED_RELEASED: cty::c_int = 3;
pub const LV_BTN_STATE_CHECKED_PRESSED: cty::c_int = 4;
pub const LV_BTN_STATE_CHECKED_DISABLED: cty::c_int = 5;
pub const _LV_BTN_STATE_LAST: cty::c_int = 6;
pub type _bindgen_ty_40 = cty::c_int;
pub type lv_btn_state_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_btn_ext_t {
    pub cont: lv_cont_ext_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl lv_btn_ext_t {
    #[inline]
    pub fn checkable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_checkable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(checkable: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let checkable: u8 = unsafe { ::core::mem::transmute(checkable) };
            checkable as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_BTN_PART_MAIN: cty::c_int = 0;
pub const _LV_BTN_PART_VIRTUAL_LAST: cty::c_int = 1;
pub const _LV_BTN_PART_REAL_LAST: cty::c_int = 64;
pub type _bindgen_ty_41 = cty::c_int;
pub type lv_btn_part_t = u8;
extern "C" {
    pub fn lv_btn_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_btn_set_checkable(btn: *mut lv_obj_t, tgl: bool);
}
extern "C" {
    pub fn lv_btn_set_state(btn: *mut lv_obj_t, state: lv_btn_state_t);
}
extern "C" {
    pub fn lv_btn_toggle(btn: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_btn_get_state(btn: *const lv_obj_t) -> lv_btn_state_t;
}
extern "C" {
    pub fn lv_btn_get_checkable(btn: *const lv_obj_t) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_imgbtn_ext_t {
    pub btn: lv_btn_ext_t,
    pub img_src_mid: [*const cty::c_void; 6usize],
    pub act_cf: lv_img_cf_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl lv_imgbtn_ext_t {
    #[inline]
    pub fn tiled(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tiled(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(tiled: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tiled: u8 = unsafe { ::core::mem::transmute(tiled) };
            tiled as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_IMGBTN_PART_MAIN: cty::c_int = 0;
pub type _bindgen_ty_42 = cty::c_int;
pub type lv_imgbtn_part_t = u8;
extern "C" {
    pub fn lv_imgbtn_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_imgbtn_set_src(imgbtn: *mut lv_obj_t, state: lv_btn_state_t, src: *const cty::c_void);
}
extern "C" {
    pub fn lv_imgbtn_set_state(imgbtn: *mut lv_obj_t, state: lv_btn_state_t);
}
extern "C" {
    pub fn lv_imgbtn_toggle(imgbtn: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_imgbtn_get_src(imgbtn: *mut lv_obj_t, state: lv_btn_state_t) -> *const cty::c_void;
}
extern "C" {
    pub fn lv_draw_triangle(
        points: *const lv_point_t,
        clip: *const lv_area_t,
        draw_dsc: *const lv_draw_rect_dsc_t,
    );
}
extern "C" {
    pub fn lv_draw_polygon(
        points: *const lv_point_t,
        point_cnt: u16,
        mask: *const lv_area_t,
        draw_dsc: *const lv_draw_rect_dsc_t,
    );
}
extern "C" {
    pub fn lv_draw_arc(
        center_x: lv_coord_t,
        center_y: lv_coord_t,
        radius: u16,
        start_angle: u16,
        end_angle: u16,
        clip_area: *const lv_area_t,
        dsc: *const lv_draw_line_dsc_t,
    );
}
pub const LV_LABEL_LONG_EXPAND: cty::c_int = 0;
pub const LV_LABEL_LONG_BREAK: cty::c_int = 1;
pub const LV_LABEL_LONG_DOT: cty::c_int = 2;
pub const LV_LABEL_LONG_SROLL: cty::c_int = 3;
pub const LV_LABEL_LONG_SROLL_CIRC: cty::c_int = 4;
pub const LV_LABEL_LONG_CROP: cty::c_int = 5;
pub type _bindgen_ty_43 = cty::c_int;
pub type lv_label_long_mode_t = u8;
pub const LV_LABEL_ALIGN_LEFT: cty::c_int = 0;
pub const LV_LABEL_ALIGN_CENTER: cty::c_int = 1;
pub const LV_LABEL_ALIGN_RIGHT: cty::c_int = 2;
pub const LV_LABEL_ALIGN_AUTO: cty::c_int = 3;
pub type _bindgen_ty_44 = cty::c_int;
pub type lv_label_align_t = u8;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_label_ext_t {
    pub text: *mut cty::c_char,
    pub dot: lv_label_ext_t__bindgen_ty_1,
    pub dot_end: u32,
    pub anim_speed: u16,
    pub offset: lv_point_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lv_label_ext_t__bindgen_ty_1 {
    pub tmp_ptr: *mut cty::c_char,
    pub tmp: [cty::c_char; 4usize],
}
impl lv_label_ext_t {
    #[inline]
    pub fn long_mode(&self) -> lv_label_long_mode_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_long_mode(&mut self, val: lv_label_long_mode_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn static_txt(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_static_txt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn align(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_align(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn recolor(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_recolor(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn expand(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_expand(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dot_tmp_alloc(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dot_tmp_alloc(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        long_mode: lv_label_long_mode_t,
        static_txt: u8,
        align: u8,
        recolor: u8,
        expand: u8,
        dot_tmp_alloc: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let long_mode: u8 = unsafe { ::core::mem::transmute(long_mode) };
            long_mode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let static_txt: u8 = unsafe { ::core::mem::transmute(static_txt) };
            static_txt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let align: u8 = unsafe { ::core::mem::transmute(align) };
            align as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let recolor: u8 = unsafe { ::core::mem::transmute(recolor) };
            recolor as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let expand: u8 = unsafe { ::core::mem::transmute(expand) };
            expand as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let dot_tmp_alloc: u8 = unsafe { ::core::mem::transmute(dot_tmp_alloc) };
            dot_tmp_alloc as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_LABEL_PART_MAIN: cty::c_int = 0;
pub type _bindgen_ty_45 = cty::c_int;
pub type lv_label_part_t = u8;
extern "C" {
    pub fn lv_label_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_label_set_text(label: *mut lv_obj_t, text: *const cty::c_char);
}
extern "C" {
    pub fn lv_label_set_text_fmt(label: *mut lv_obj_t, fmt: *const cty::c_char, ...);
}
extern "C" {
    pub fn lv_label_set_text_static(label: *mut lv_obj_t, text: *const cty::c_char);
}
extern "C" {
    pub fn lv_label_set_long_mode(label: *mut lv_obj_t, long_mode: lv_label_long_mode_t);
}
extern "C" {
    pub fn lv_label_set_align(label: *mut lv_obj_t, align: lv_label_align_t);
}
extern "C" {
    pub fn lv_label_set_recolor(label: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_label_set_anim_speed(label: *mut lv_obj_t, anim_speed: u16);
}
extern "C" {
    pub fn lv_label_set_text_sel_start(label: *mut lv_obj_t, index: u32);
}
extern "C" {
    pub fn lv_label_set_text_sel_end(label: *mut lv_obj_t, index: u32);
}
extern "C" {
    pub fn lv_label_get_text(label: *const lv_obj_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn lv_label_get_long_mode(label: *const lv_obj_t) -> lv_label_long_mode_t;
}
extern "C" {
    pub fn lv_label_get_align(label: *const lv_obj_t) -> lv_label_align_t;
}
extern "C" {
    pub fn lv_label_get_recolor(label: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_label_get_anim_speed(label: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_label_get_letter_pos(label: *const lv_obj_t, index: u32, pos: *mut lv_point_t);
}
extern "C" {
    pub fn lv_label_get_letter_on(label: *const lv_obj_t, pos: *mut lv_point_t) -> u32;
}
extern "C" {
    pub fn lv_label_is_char_under_pos(label: *const lv_obj_t, pos: *mut lv_point_t) -> bool;
}
extern "C" {
    pub fn lv_label_get_text_sel_start(label: *const lv_obj_t) -> u32;
}
extern "C" {
    pub fn lv_label_get_text_sel_end(label: *const lv_obj_t) -> u32;
}
extern "C" {
    pub fn lv_label_get_style(label: *mut lv_obj_t, type_: u8) -> *mut lv_style_list_t;
}
extern "C" {
    pub fn lv_label_ins_text(label: *mut lv_obj_t, pos: u32, txt: *const cty::c_char);
}
extern "C" {
    pub fn lv_label_cut_text(label: *mut lv_obj_t, pos: u32, cnt: u32);
}
extern "C" {
    pub fn lv_label_refr_text(label: *mut lv_obj_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_img_ext_t {
    pub src: *const cty::c_void,
    pub offset: lv_point_t,
    pub w: lv_coord_t,
    pub h: lv_coord_t,
    pub angle: u16,
    pub pivot: lv_point_t,
    pub zoom: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl lv_img_ext_t {
    #[inline]
    pub fn src_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_src_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auto_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cf(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_cf(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn antialias(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_antialias(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        src_type: u8,
        auto_size: u8,
        cf: u8,
        antialias: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let src_type: u8 = unsafe { ::core::mem::transmute(src_type) };
            src_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let auto_size: u8 = unsafe { ::core::mem::transmute(auto_size) };
            auto_size as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let cf: u8 = unsafe { ::core::mem::transmute(cf) };
            cf as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let antialias: u8 = unsafe { ::core::mem::transmute(antialias) };
            antialias as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_IMG_PART_MAIN: cty::c_int = 0;
pub type _bindgen_ty_46 = cty::c_int;
pub type lv_img_part_t = u8;
extern "C" {
    pub fn lv_img_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_img_set_src(img: *mut lv_obj_t, src_img: *const cty::c_void);
}
extern "C" {
    pub fn lv_img_set_auto_size(img: *mut lv_obj_t, autosize_en: bool);
}
extern "C" {
    pub fn lv_img_set_offset_x(img: *mut lv_obj_t, x: lv_coord_t);
}
extern "C" {
    pub fn lv_img_set_offset_y(img: *mut lv_obj_t, y: lv_coord_t);
}
extern "C" {
    pub fn lv_img_set_pivot(img: *mut lv_obj_t, pivot_x: lv_coord_t, pivot_y: lv_coord_t);
}
extern "C" {
    pub fn lv_img_set_angle(img: *mut lv_obj_t, angle: i16);
}
extern "C" {
    pub fn lv_img_set_zoom(img: *mut lv_obj_t, zoom: u16);
}
extern "C" {
    pub fn lv_img_set_antialias(img: *mut lv_obj_t, antialias: bool);
}
extern "C" {
    pub fn lv_img_get_src(img: *mut lv_obj_t) -> *const cty::c_void;
}
extern "C" {
    pub fn lv_img_get_file_name(img: *const lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    pub fn lv_img_get_auto_size(img: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_img_get_offset_x(img: *mut lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_img_get_offset_y(img: *mut lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_img_get_angle(img: *mut lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_img_get_pivot(img: *mut lv_obj_t, center: *mut lv_point_t);
}
extern "C" {
    pub fn lv_img_get_zoom(img: *mut lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_img_get_antialias(img: *mut lv_obj_t) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_line_ext_t {
    pub point_array: *const lv_point_t,
    pub point_num: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 5usize],
}
impl lv_line_ext_t {
    #[inline]
    pub fn auto_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auto_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn y_inv(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_y_inv(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(auto_size: u8, y_inv: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let auto_size: u8 = unsafe { ::core::mem::transmute(auto_size) };
            auto_size as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let y_inv: u8 = unsafe { ::core::mem::transmute(y_inv) };
            y_inv as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_LINE_PART_MAIN: cty::c_int = 0;
pub type _bindgen_ty_47 = cty::c_int;
pub type lv_line_style_t = u8;
extern "C" {
    pub fn lv_line_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_line_set_points(line: *mut lv_obj_t, point_a: *const lv_point_t, point_num: u16);
}
extern "C" {
    pub fn lv_line_set_auto_size(line: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_line_set_y_invert(line: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_line_get_auto_size(line: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_line_get_y_invert(line: *const lv_obj_t) -> bool;
}
pub const LV_SCROLLBAR_MODE_OFF: cty::c_int = 0;
pub const LV_SCROLLBAR_MODE_ON: cty::c_int = 1;
pub const LV_SCROLLBAR_MODE_DRAG: cty::c_int = 2;
pub const LV_SCROLLBAR_MODE_AUTO: cty::c_int = 3;
pub const LV_SCROLLBAR_MODE_HIDE: cty::c_int = 4;
pub const LV_SCROLLBAR_MODE_UNHIDE: cty::c_int = 8;
pub type _bindgen_ty_48 = cty::c_int;
pub type lv_scrollbar_mode_t = u8;
pub const LV_PAGE_EDGE_LEFT: cty::c_int = 1;
pub const LV_PAGE_EDGE_TOP: cty::c_int = 2;
pub const LV_PAGE_EDGE_RIGHT: cty::c_int = 4;
pub const LV_PAGE_EDGE_BOTTOM: cty::c_int = 8;
pub type _bindgen_ty_49 = cty::c_int;
pub type lv_page_edge_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_page_ext_t {
    pub bg: lv_cont_ext_t,
    pub scrl: *mut lv_obj_t,
    pub scrlbar: lv_page_ext_t__bindgen_ty_1,
    pub edge_flash: lv_page_ext_t__bindgen_ty_2,
    pub anim_time: u16,
    pub scroll_prop_obj: *mut lv_obj_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_page_ext_t__bindgen_ty_1 {
    pub style: lv_style_list_t,
    pub hor_area: lv_area_t,
    pub ver_area: lv_area_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl lv_page_ext_t__bindgen_ty_1 {
    #[inline]
    pub fn hor_draw(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hor_draw(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ver_draw(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ver_draw(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mode(&self) -> lv_scrollbar_mode_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_mode(&mut self, val: lv_scrollbar_mode_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hor_draw: u8,
        ver_draw: u8,
        mode: lv_scrollbar_mode_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hor_draw: u8 = unsafe { ::core::mem::transmute(hor_draw) };
            hor_draw as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ver_draw: u8 = unsafe { ::core::mem::transmute(ver_draw) };
            ver_draw as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let mode: u8 = unsafe { ::core::mem::transmute(mode) };
            mode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_page_ext_t__bindgen_ty_2 {
    pub state: lv_anim_value_t,
    pub style: lv_style_list_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl lv_page_ext_t__bindgen_ty_2 {
    #[inline]
    pub fn enabled(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn top_ip(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_top_ip(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bottom_ip(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bottom_ip(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn right_ip(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_right_ip(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn left_ip(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_left_ip(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled: u8,
        top_ip: u8,
        bottom_ip: u8,
        right_ip: u8,
        left_ip: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u8 = unsafe { ::core::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let top_ip: u8 = unsafe { ::core::mem::transmute(top_ip) };
            top_ip as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let bottom_ip: u8 = unsafe { ::core::mem::transmute(bottom_ip) };
            bottom_ip as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let right_ip: u8 = unsafe { ::core::mem::transmute(right_ip) };
            right_ip as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let left_ip: u8 = unsafe { ::core::mem::transmute(left_ip) };
            left_ip as u64
        });
        __bindgen_bitfield_unit
    }
}
impl lv_page_ext_t {
    #[inline]
    pub fn scroll_prop(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scroll_prop(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(scroll_prop: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let scroll_prop: u8 = unsafe { ::core::mem::transmute(scroll_prop) };
            scroll_prop as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_PAGE_PART_BG: cty::c_int = 0;
pub const LV_PAGE_PART_SCROLLBAR: cty::c_int = 1;
pub const LV_PAGE_PART_EDGE_FLASH: cty::c_int = 2;
pub const _LV_PAGE_PART_VIRTUAL_LAST: cty::c_int = 3;
pub const LV_PAGE_PART_SCROLLABLE: cty::c_int = 64;
pub const _LV_PAGE_PART_REAL_LAST: cty::c_int = 65;
pub type _bindgen_ty_50 = cty::c_int;
pub type lv_part_style_t = u8;
extern "C" {
    pub fn lv_page_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_page_clean(page: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_page_get_scrollable(page: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_page_get_anim_time(page: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_page_set_scrollbar_mode(page: *mut lv_obj_t, sb_mode: lv_scrollbar_mode_t);
}
extern "C" {
    pub fn lv_page_set_anim_time(page: *mut lv_obj_t, anim_time: u16);
}
extern "C" {
    pub fn lv_page_set_scroll_propagation(page: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_page_set_edge_flash(page: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_page_get_scrollbar_mode(page: *const lv_obj_t) -> lv_scrollbar_mode_t;
}
extern "C" {
    pub fn lv_page_get_scroll_propagation(page: *mut lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_page_get_edge_flash(page: *mut lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_page_get_width_fit(page: *mut lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_page_get_height_fit(page: *mut lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_page_get_width_grid(page: *mut lv_obj_t, div: u8, span: u8) -> lv_coord_t;
}
extern "C" {
    pub fn lv_page_get_height_grid(page: *mut lv_obj_t, div: u8, span: u8) -> lv_coord_t;
}
extern "C" {
    pub fn lv_page_on_edge(page: *mut lv_obj_t, edge: lv_page_edge_t) -> bool;
}
extern "C" {
    pub fn lv_page_glue_obj(obj: *mut lv_obj_t, glue: bool);
}
extern "C" {
    pub fn lv_page_focus(page: *mut lv_obj_t, obj: *const lv_obj_t, anim_en: lv_anim_enable_t);
}
extern "C" {
    pub fn lv_page_scroll_hor(page: *mut lv_obj_t, dist: lv_coord_t);
}
extern "C" {
    pub fn lv_page_scroll_ver(page: *mut lv_obj_t, dist: lv_coord_t);
}
extern "C" {
    pub fn lv_page_start_edge_flash(page: *mut lv_obj_t, edge: lv_page_edge_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_list_ext_t {
    pub page: lv_page_ext_t,
    pub last_sel_btn: *mut lv_obj_t,
    pub act_sel_btn: *mut lv_obj_t,
}
pub const LV_LIST_PART_BG: cty::c_int = 0;
pub const LV_LIST_PART_SCROLLBAR: cty::c_int = 1;
pub const LV_LIST_PART_EDGE_FLASH: cty::c_int = 2;
pub const _LV_LIST_PART_VIRTUAL_LAST: cty::c_int = 3;
pub const LV_LIST_PART_SCROLLABLE: cty::c_int = 64;
pub const _LV_LIST_PART_REAL_LAST: cty::c_int = 65;
pub type _bindgen_ty_51 = cty::c_int;
pub type lv_list_style_t = u8;
extern "C" {
    pub fn lv_list_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_list_clean(list: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_list_add_btn(
        list: *mut lv_obj_t,
        img_src: *const cty::c_void,
        txt: *const cty::c_char,
    ) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_list_remove(list: *const lv_obj_t, index: u16) -> bool;
}
extern "C" {
    pub fn lv_list_focus_btn(list: *mut lv_obj_t, btn: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_list_set_layout(list: *mut lv_obj_t, layout: lv_layout_t);
}
extern "C" {
    pub fn lv_list_get_btn_text(btn: *const lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    pub fn lv_list_get_btn_label(btn: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_list_get_btn_img(btn: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_list_get_prev_btn(list: *const lv_obj_t, prev_btn: *mut lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_list_get_next_btn(list: *const lv_obj_t, prev_btn: *mut lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_list_get_btn_index(list: *const lv_obj_t, btn: *const lv_obj_t) -> i32;
}
extern "C" {
    pub fn lv_list_get_size(list: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_list_get_btn_selected(list: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_list_get_layout(list: *mut lv_obj_t) -> lv_layout_t;
}
extern "C" {
    pub fn lv_list_up(list: *const lv_obj_t);
}
extern "C" {
    pub fn lv_list_down(list: *const lv_obj_t);
}
extern "C" {
    pub fn lv_list_focus(btn: *const lv_obj_t, anim: lv_anim_enable_t);
}
pub const LV_CHART_TYPE_NONE: cty::c_int = 0;
pub const LV_CHART_TYPE_LINE: cty::c_int = 1;
pub const LV_CHART_TYPE_COLUMN: cty::c_int = 2;
pub type _bindgen_ty_52 = cty::c_int;
pub type lv_chart_type_t = u8;
pub const LV_CHART_UPDATE_MODE_SHIFT: cty::c_int = 0;
pub const LV_CHART_UPDATE_MODE_CIRCULAR: cty::c_int = 1;
pub type _bindgen_ty_53 = cty::c_int;
pub type lv_chart_update_mode_t = u8;
pub const LV_CHART_AXIS_PRIMARY_Y: cty::c_int = 0;
pub const LV_CHART_AXIS_SECONDARY_Y: cty::c_int = 1;
pub const _LV_CHART_AXIS_LAST: cty::c_int = 2;
pub type _bindgen_ty_54 = cty::c_int;
pub type lv_chart_axis_t = u8;
pub const LV_CHART_CURSOR_NONE: cty::c_int = 0;
pub const LV_CHART_CURSOR_RIGHT: cty::c_int = 1;
pub const LV_CHART_CURSOR_UP: cty::c_int = 2;
pub const LV_CHART_CURSOR_LEFT: cty::c_int = 4;
pub const LV_CHART_CURSOR_DOWN: cty::c_int = 8;
pub type _bindgen_ty_55 = cty::c_int;
pub type lv_cursor_direction_t = u8;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_chart_series_t {
    pub points: *mut lv_coord_t,
    pub color: lv_color_t,
    pub start_point: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl lv_chart_series_t {
    #[inline]
    pub fn ext_buf_assigned(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ext_buf_assigned(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hidden(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hidden(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn y_axis(&self) -> lv_chart_axis_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_y_axis(&mut self, val: lv_chart_axis_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ext_buf_assigned: u8,
        hidden: u8,
        y_axis: lv_chart_axis_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ext_buf_assigned: u8 = unsafe { ::core::mem::transmute(ext_buf_assigned) };
            ext_buf_assigned as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hidden: u8 = unsafe { ::core::mem::transmute(hidden) };
            hidden as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let y_axis: u8 = unsafe { ::core::mem::transmute(y_axis) };
            y_axis as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_chart_cursor_t {
    pub point: lv_point_t,
    pub color: lv_color_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl lv_chart_cursor_t {
    #[inline]
    pub fn axes(&self) -> lv_cursor_direction_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_axes(&mut self, val: lv_cursor_direction_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(axes: lv_cursor_direction_t) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let axes: u8 = unsafe { ::core::mem::transmute(axes) };
            axes as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_CHART_AXIS_SKIP_LAST_TICK: cty::c_int = 0;
pub const LV_CHART_AXIS_DRAW_LAST_TICK: cty::c_int = 1;
pub const LV_CHART_AXIS_INVERSE_LABELS_ORDER: cty::c_int = 2;
pub type _bindgen_ty_56 = cty::c_int;
pub type lv_chart_axis_options_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_chart_axis_cfg_t {
    pub list_of_values: *const cty::c_char,
    pub options: lv_chart_axis_options_t,
    pub num_tick_marks: u8,
    pub major_tick_len: u8,
    pub minor_tick_len: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_chart_ext_t {
    pub series_ll: lv_ll_t,
    pub cursors_ll: lv_ll_t,
    pub ymin: [lv_coord_t; 2usize],
    pub ymax: [lv_coord_t; 2usize],
    pub hdiv_cnt: u8,
    pub vdiv_cnt: u8,
    pub point_cnt: u16,
    pub style_series_bg: lv_style_list_t,
    pub style_series: lv_style_list_t,
    pub style_cursors: lv_style_list_t,
    pub type_: lv_chart_type_t,
    pub y_axis: lv_chart_axis_cfg_t,
    pub x_axis: lv_chart_axis_cfg_t,
    pub secondary_y_axis: lv_chart_axis_cfg_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl lv_chart_ext_t {
    #[inline]
    pub fn update_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_update_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(update_mode: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let update_mode: u8 = unsafe { ::core::mem::transmute(update_mode) };
            update_mode as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_CHART_PART_BG: cty::c_int = 0;
pub const LV_CHART_PART_SERIES_BG: cty::c_int = 1;
pub const LV_CHART_PART_SERIES: cty::c_int = 2;
pub const LV_CHART_PART_CURSOR: cty::c_int = 3;
pub type _bindgen_ty_57 = cty::c_int;
extern "C" {
    pub fn lv_chart_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_chart_add_series(chart: *mut lv_obj_t, color: lv_color_t) -> *mut lv_chart_series_t;
}
extern "C" {
    pub fn lv_chart_remove_series(chart: *mut lv_obj_t, series: *mut lv_chart_series_t);
}
extern "C" {
    pub fn lv_chart_add_cursor(
        chart: *mut lv_obj_t,
        color: lv_color_t,
        dir: lv_cursor_direction_t,
    ) -> *mut lv_chart_cursor_t;
}
extern "C" {
    pub fn lv_chart_clear_series(chart: *mut lv_obj_t, series: *mut lv_chart_series_t);
}
extern "C" {
    pub fn lv_chart_hide_series(chart: *mut lv_obj_t, series: *mut lv_chart_series_t, hide: bool);
}
extern "C" {
    pub fn lv_chart_set_div_line_count(chart: *mut lv_obj_t, hdiv: u8, vdiv: u8);
}
extern "C" {
    pub fn lv_chart_set_y_range(
        chart: *mut lv_obj_t,
        axis: lv_chart_axis_t,
        ymin: lv_coord_t,
        ymax: lv_coord_t,
    );
}
extern "C" {
    pub fn lv_chart_set_type(chart: *mut lv_obj_t, type_: lv_chart_type_t);
}
extern "C" {
    pub fn lv_chart_set_point_count(chart: *mut lv_obj_t, point_cnt: u16);
}
extern "C" {
    pub fn lv_chart_init_points(chart: *mut lv_obj_t, ser: *mut lv_chart_series_t, y: lv_coord_t);
}
extern "C" {
    pub fn lv_chart_set_points(
        chart: *mut lv_obj_t,
        ser: *mut lv_chart_series_t,
        y_array: *mut lv_coord_t,
    );
}
extern "C" {
    pub fn lv_chart_set_next(chart: *mut lv_obj_t, ser: *mut lv_chart_series_t, y: lv_coord_t);
}
extern "C" {
    pub fn lv_chart_set_update_mode(chart: *mut lv_obj_t, update_mode: lv_chart_update_mode_t);
}
extern "C" {
    pub fn lv_chart_set_x_tick_length(chart: *mut lv_obj_t, major_tick_len: u8, minor_tick_len: u8);
}
extern "C" {
    pub fn lv_chart_set_y_tick_length(chart: *mut lv_obj_t, major_tick_len: u8, minor_tick_len: u8);
}
extern "C" {
    pub fn lv_chart_set_secondary_y_tick_length(
        chart: *mut lv_obj_t,
        major_tick_len: u8,
        minor_tick_len: u8,
    );
}
extern "C" {
    pub fn lv_chart_set_x_tick_texts(
        chart: *mut lv_obj_t,
        list_of_values: *const cty::c_char,
        num_tick_marks: u8,
        options: lv_chart_axis_options_t,
    );
}
extern "C" {
    pub fn lv_chart_set_secondary_y_tick_texts(
        chart: *mut lv_obj_t,
        list_of_values: *const cty::c_char,
        num_tick_marks: u8,
        options: lv_chart_axis_options_t,
    );
}
extern "C" {
    pub fn lv_chart_set_y_tick_texts(
        chart: *mut lv_obj_t,
        list_of_values: *const cty::c_char,
        num_tick_marks: u8,
        options: lv_chart_axis_options_t,
    );
}
extern "C" {
    pub fn lv_chart_set_x_start_point(chart: *mut lv_obj_t, ser: *mut lv_chart_series_t, id: u16);
}
extern "C" {
    pub fn lv_chart_set_ext_array(
        chart: *mut lv_obj_t,
        ser: *mut lv_chart_series_t,
        array: *mut lv_coord_t,
        point_cnt: u16,
    );
}
extern "C" {
    pub fn lv_chart_set_point_id(
        chart: *mut lv_obj_t,
        ser: *mut lv_chart_series_t,
        value: lv_coord_t,
        id: u16,
    );
}
extern "C" {
    pub fn lv_chart_set_series_axis(
        chart: *mut lv_obj_t,
        ser: *mut lv_chart_series_t,
        axis: lv_chart_axis_t,
    );
}
extern "C" {
    pub fn lv_chart_set_cursor_point(
        chart: *mut lv_obj_t,
        cursor: *mut lv_chart_cursor_t,
        point: *mut lv_point_t,
    );
}
extern "C" {
    pub fn lv_chart_get_type(chart: *const lv_obj_t) -> lv_chart_type_t;
}
extern "C" {
    pub fn lv_chart_get_point_count(chart: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_chart_get_x_start_point(ser: *mut lv_chart_series_t) -> u16;
}
extern "C" {
    pub fn lv_chart_get_point_id(
        chart: *mut lv_obj_t,
        ser: *mut lv_chart_series_t,
        id: u16,
    ) -> lv_coord_t;
}
extern "C" {
    pub fn lv_chart_get_series_axis(
        chart: *mut lv_obj_t,
        ser: *mut lv_chart_series_t,
    ) -> lv_chart_axis_t;
}
extern "C" {
    pub fn lv_chart_get_series_area(chart: *mut lv_obj_t, series_area: *mut lv_area_t);
}
extern "C" {
    pub fn lv_chart_get_cursor_point(
        chart: *mut lv_obj_t,
        cursor: *mut lv_chart_cursor_t,
    ) -> lv_point_t;
}
extern "C" {
    pub fn lv_chart_get_nearest_index_from_coord(chart: *mut lv_obj_t, x: lv_coord_t) -> u16;
}
extern "C" {
    pub fn lv_chart_get_x_from_index(
        chart: *mut lv_obj_t,
        ser: *mut lv_chart_series_t,
        id: u16,
    ) -> lv_coord_t;
}
extern "C" {
    pub fn lv_chart_get_y_from_index(
        chart: *mut lv_obj_t,
        ser: *mut lv_chart_series_t,
        id: u16,
    ) -> lv_coord_t;
}
extern "C" {
    pub fn lv_chart_refresh(chart: *mut lv_obj_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lv_table_cell_format_t {
    pub s: lv_table_cell_format_t__bindgen_ty_1,
    pub format_byte: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct lv_table_cell_format_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
impl lv_table_cell_format_t__bindgen_ty_1 {
    #[inline]
    pub fn align(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_align(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn right_merge(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_right_merge(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn crop(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_crop(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        align: u8,
        right_merge: u8,
        type_: u8,
        crop: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let align: u8 = unsafe { ::core::mem::transmute(align) };
            align as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let right_merge: u8 = unsafe { ::core::mem::transmute(right_merge) };
            right_merge as u64
        });
        __bindgen_bitfield_unit.set(3usize, 4u8, {
            let type_: u8 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let crop: u8 = unsafe { ::core::mem::transmute(crop) };
            crop as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_table_ext_t {
    pub col_cnt: u16,
    pub row_cnt: u16,
    pub cell_data: *mut *mut cty::c_char,
    pub row_h: *mut lv_coord_t,
    pub cell_style: [lv_style_list_t; 4usize],
    pub col_w: [lv_coord_t; 12usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl lv_table_ext_t {
    #[inline]
    pub fn cell_types(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_cell_types(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(cell_types: u16) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let cell_types: u16 = unsafe { ::core::mem::transmute(cell_types) };
            cell_types as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_TABLE_PART_BG: cty::c_int = 0;
pub const LV_TABLE_PART_CELL1: cty::c_int = 1;
pub const LV_TABLE_PART_CELL2: cty::c_int = 2;
pub const LV_TABLE_PART_CELL3: cty::c_int = 3;
pub const LV_TABLE_PART_CELL4: cty::c_int = 4;
pub type _bindgen_ty_58 = cty::c_int;
extern "C" {
    pub fn lv_table_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_table_set_cell_value(
        table: *mut lv_obj_t,
        row: u16,
        col: u16,
        txt: *const cty::c_char,
    );
}
extern "C" {
    pub fn lv_table_set_cell_value_fmt(
        table: *mut lv_obj_t,
        row: u16,
        col: u16,
        fmt: *const cty::c_char,
        ...
    );
}
extern "C" {
    pub fn lv_table_set_row_cnt(table: *mut lv_obj_t, row_cnt: u16);
}
extern "C" {
    pub fn lv_table_set_col_cnt(table: *mut lv_obj_t, col_cnt: u16);
}
extern "C" {
    pub fn lv_table_set_col_width(table: *mut lv_obj_t, col_id: u16, w: lv_coord_t);
}
extern "C" {
    pub fn lv_table_set_cell_align(
        table: *mut lv_obj_t,
        row: u16,
        col: u16,
        align: lv_label_align_t,
    );
}
extern "C" {
    pub fn lv_table_set_cell_type(table: *mut lv_obj_t, row: u16, col: u16, type_: u8);
}
extern "C" {
    pub fn lv_table_set_cell_crop(table: *mut lv_obj_t, row: u16, col: u16, crop: bool);
}
extern "C" {
    pub fn lv_table_set_cell_merge_right(table: *mut lv_obj_t, row: u16, col: u16, en: bool);
}
extern "C" {
    pub fn lv_table_get_cell_value(table: *mut lv_obj_t, row: u16, col: u16) -> *const cty::c_char;
}
extern "C" {
    pub fn lv_table_get_row_cnt(table: *mut lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_table_get_col_cnt(table: *mut lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_table_get_col_width(table: *mut lv_obj_t, col_id: u16) -> lv_coord_t;
}
extern "C" {
    pub fn lv_table_get_cell_align(table: *mut lv_obj_t, row: u16, col: u16) -> lv_label_align_t;
}
extern "C" {
    pub fn lv_table_get_cell_type(table: *mut lv_obj_t, row: u16, col: u16) -> lv_label_align_t;
}
extern "C" {
    pub fn lv_table_get_cell_crop(table: *mut lv_obj_t, row: u16, col: u16) -> lv_label_align_t;
}
extern "C" {
    pub fn lv_table_get_cell_merge_right(table: *mut lv_obj_t, row: u16, col: u16) -> bool;
}
extern "C" {
    pub fn lv_table_get_pressed_cell(
        table: *mut lv_obj_t,
        row: *mut u16,
        col: *mut u16,
    ) -> lv_res_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_checkbox_ext_t {
    pub bg_btn: lv_btn_ext_t,
    pub bullet: *mut lv_obj_t,
    pub label: *mut lv_obj_t,
}
pub const LV_CHECKBOX_PART_BG: cty::c_int = 0;
pub const _LV_CHECKBOX_PART_VIRTUAL_LAST: cty::c_int = 1;
pub const LV_CHECKBOX_PART_BULLET: cty::c_int = 64;
pub const _LV_CHECKBOX_PART_REAL_LAST: cty::c_int = 65;
pub type _bindgen_ty_59 = cty::c_int;
pub type lv_checkbox_style_t = u8;
extern "C" {
    pub fn lv_checkbox_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_checkbox_set_text(cb: *mut lv_obj_t, txt: *const cty::c_char);
}
extern "C" {
    pub fn lv_checkbox_set_text_static(cb: *mut lv_obj_t, txt: *const cty::c_char);
}
extern "C" {
    pub fn lv_checkbox_set_checked(cb: *mut lv_obj_t, checked: bool);
}
extern "C" {
    pub fn lv_checkbox_set_disabled(cb: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_checkbox_set_state(cb: *mut lv_obj_t, state: lv_btn_state_t);
}
extern "C" {
    pub fn lv_checkbox_get_text(cb: *const lv_obj_t) -> *const cty::c_char;
}
pub const LV_CPICKER_TYPE_RECT: cty::c_int = 0;
pub const LV_CPICKER_TYPE_DISC: cty::c_int = 1;
pub type _bindgen_ty_60 = cty::c_int;
pub type lv_cpicker_type_t = u8;
pub const LV_CPICKER_COLOR_MODE_HUE: cty::c_int = 0;
pub const LV_CPICKER_COLOR_MODE_SATURATION: cty::c_int = 1;
pub const LV_CPICKER_COLOR_MODE_VALUE: cty::c_int = 2;
pub type _bindgen_ty_61 = cty::c_int;
pub type lv_cpicker_color_mode_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_cpicker_ext_t {
    pub hsv: lv_color_hsv_t,
    pub knob: lv_cpicker_ext_t__bindgen_ty_1,
    pub last_click_time: u32,
    pub last_change_time: u32,
    pub last_press_point: lv_point_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_cpicker_ext_t__bindgen_ty_1 {
    pub style_list: lv_style_list_t,
    pub pos: lv_point_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl lv_cpicker_ext_t__bindgen_ty_1 {
    #[inline]
    pub fn colored(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_colored(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(colored: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let colored: u8 = unsafe { ::core::mem::transmute(colored) };
            colored as u64
        });
        __bindgen_bitfield_unit
    }
}
impl lv_cpicker_ext_t {
    #[inline]
    pub fn color_mode(&self) -> lv_cpicker_color_mode_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_color_mode(&mut self, val: lv_cpicker_color_mode_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn color_mode_fixed(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_color_mode_fixed(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> lv_cpicker_type_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: lv_cpicker_type_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        color_mode: lv_cpicker_color_mode_t,
        color_mode_fixed: u8,
        type_: lv_cpicker_type_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let color_mode: u8 = unsafe { ::core::mem::transmute(color_mode) };
            color_mode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let color_mode_fixed: u8 = unsafe { ::core::mem::transmute(color_mode_fixed) };
            color_mode_fixed as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let type_: u8 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_CPICKER_PART_MAIN: cty::c_int = 0;
pub const LV_CPICKER_PART_KNOB: cty::c_int = 1;
pub const _LV_CPICKER_PART_VIRTUAL_LAST: cty::c_int = 2;
pub const _LV_CPICKER_PART_REAL_LAST: cty::c_int = 64;
pub type _bindgen_ty_62 = cty::c_int;
extern "C" {
    pub fn lv_cpicker_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_cpicker_set_type(cpicker: *mut lv_obj_t, type_: lv_cpicker_type_t);
}
extern "C" {
    pub fn lv_cpicker_set_hue(cpicker: *mut lv_obj_t, hue: u16) -> bool;
}
extern "C" {
    pub fn lv_cpicker_set_saturation(cpicker: *mut lv_obj_t, saturation: u8) -> bool;
}
extern "C" {
    pub fn lv_cpicker_set_value(cpicker: *mut lv_obj_t, val: u8) -> bool;
}
extern "C" {
    pub fn lv_cpicker_set_hsv(cpicker: *mut lv_obj_t, hsv: lv_color_hsv_t) -> bool;
}
extern "C" {
    pub fn lv_cpicker_set_color(cpicker: *mut lv_obj_t, color: lv_color_t) -> bool;
}
extern "C" {
    pub fn lv_cpicker_set_color_mode(cpicker: *mut lv_obj_t, mode: lv_cpicker_color_mode_t);
}
extern "C" {
    pub fn lv_cpicker_set_color_mode_fixed(cpicker: *mut lv_obj_t, fixed: bool);
}
extern "C" {
    pub fn lv_cpicker_set_knob_colored(cpicker: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_cpicker_get_color_mode(cpicker: *mut lv_obj_t) -> lv_cpicker_color_mode_t;
}
extern "C" {
    pub fn lv_cpicker_get_color_mode_fixed(cpicker: *mut lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_cpicker_get_hue(cpicker: *mut lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_cpicker_get_saturation(cpicker: *mut lv_obj_t) -> u8;
}
extern "C" {
    pub fn lv_cpicker_get_value(cpicker: *mut lv_obj_t) -> u8;
}
extern "C" {
    pub fn lv_cpicker_get_hsv(cpicker: *mut lv_obj_t) -> lv_color_hsv_t;
}
extern "C" {
    pub fn lv_cpicker_get_color(cpicker: *mut lv_obj_t) -> lv_color_t;
}
extern "C" {
    pub fn lv_cpicker_get_knob_colored(cpicker: *mut lv_obj_t) -> bool;
}
pub const LV_BAR_TYPE_NORMAL: cty::c_int = 0;
pub const LV_BAR_TYPE_SYMMETRICAL: cty::c_int = 1;
pub const LV_BAR_TYPE_CUSTOM: cty::c_int = 2;
pub type _bindgen_ty_63 = cty::c_int;
pub type lv_bar_type_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_bar_anim_t {
    pub bar: *mut lv_obj_t,
    pub anim_start: lv_anim_value_t,
    pub anim_end: lv_anim_value_t,
    pub anim_state: lv_anim_value_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_bar_ext_t {
    pub cur_value: i16,
    pub min_value: i16,
    pub max_value: i16,
    pub start_value: i16,
    pub indic_area: lv_area_t,
    pub anim_time: lv_anim_value_t,
    pub cur_value_anim: lv_bar_anim_t,
    pub start_value_anim: lv_bar_anim_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub style_indic: lv_style_list_t,
}
impl lv_bar_ext_t {
    #[inline]
    pub fn type_(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(type_: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let type_: u8 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_BAR_PART_BG: cty::c_int = 0;
pub const LV_BAR_PART_INDIC: cty::c_int = 1;
pub const _LV_BAR_PART_VIRTUAL_LAST: cty::c_int = 2;
pub type _bindgen_ty_64 = cty::c_int;
pub type lv_bar_part_t = u8;
extern "C" {
    pub fn lv_bar_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_bar_set_value(bar: *mut lv_obj_t, value: i16, anim: lv_anim_enable_t);
}
extern "C" {
    pub fn lv_bar_set_start_value(bar: *mut lv_obj_t, start_value: i16, anim: lv_anim_enable_t);
}
extern "C" {
    pub fn lv_bar_set_range(bar: *mut lv_obj_t, min: i16, max: i16);
}
extern "C" {
    pub fn lv_bar_set_type(bar: *mut lv_obj_t, type_: lv_bar_type_t);
}
extern "C" {
    pub fn lv_bar_set_anim_time(bar: *mut lv_obj_t, anim_time: u16);
}
extern "C" {
    pub fn lv_bar_get_value(bar: *const lv_obj_t) -> i16;
}
extern "C" {
    pub fn lv_bar_get_start_value(bar: *const lv_obj_t) -> i16;
}
extern "C" {
    pub fn lv_bar_get_min_value(bar: *const lv_obj_t) -> i16;
}
extern "C" {
    pub fn lv_bar_get_max_value(bar: *const lv_obj_t) -> i16;
}
extern "C" {
    pub fn lv_bar_get_type(bar: *mut lv_obj_t) -> lv_bar_type_t;
}
extern "C" {
    pub fn lv_bar_get_anim_time(bar: *const lv_obj_t) -> u16;
}
pub const LV_SLIDER_TYPE_NORMAL: cty::c_int = 0;
pub const LV_SLIDER_TYPE_SYMMETRICAL: cty::c_int = 1;
pub const LV_SLIDER_TYPE_RANGE: cty::c_int = 2;
pub type _bindgen_ty_65 = cty::c_int;
pub type lv_slider_type_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_slider_ext_t {
    pub bar: lv_bar_ext_t,
    pub style_knob: lv_style_list_t,
    pub left_knob_area: lv_area_t,
    pub right_knob_area: lv_area_t,
    pub value_to_set: *mut i16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl lv_slider_ext_t {
    #[inline]
    pub fn dragging(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dragging(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn left_knob_focus(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_left_knob_focus(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dragging: u8,
        left_knob_focus: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dragging: u8 = unsafe { ::core::mem::transmute(dragging) };
            dragging as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let left_knob_focus: u8 = unsafe { ::core::mem::transmute(left_knob_focus) };
            left_knob_focus as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_SLIDER_PART_BG: cty::c_int = 0;
pub const LV_SLIDER_PART_INDIC: cty::c_int = 1;
pub const LV_SLIDER_PART_KNOB: cty::c_int = 2;
pub type _bindgen_ty_66 = cty::c_int;
extern "C" {
    pub fn lv_slider_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_slider_get_value(slider: *const lv_obj_t) -> i16;
}
extern "C" {
    pub fn lv_slider_is_dragged(slider: *const lv_obj_t) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_led_ext_t {
    pub bright: u8,
}
pub const LV_LED_PART_MAIN: cty::c_int = 0;
pub type _bindgen_ty_67 = cty::c_int;
pub type lv_led_part_t = u8;
extern "C" {
    pub fn lv_led_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_led_set_bright(led: *mut lv_obj_t, bright: u8);
}
extern "C" {
    pub fn lv_led_on(led: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_led_off(led: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_led_toggle(led: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_led_get_bright(led: *const lv_obj_t) -> u8;
}
pub const LV_BTNMATRIX_CTRL_HIDDEN: cty::c_int = 8;
pub const LV_BTNMATRIX_CTRL_NO_REPEAT: cty::c_int = 16;
pub const LV_BTNMATRIX_CTRL_DISABLED: cty::c_int = 32;
pub const LV_BTNMATRIX_CTRL_CHECKABLE: cty::c_int = 64;
pub const LV_BTNMATRIX_CTRL_CHECK_STATE: cty::c_int = 128;
pub const LV_BTNMATRIX_CTRL_CLICK_TRIG: cty::c_int = 256;
pub type _bindgen_ty_68 = cty::c_int;
pub type lv_btnmatrix_ctrl_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_btnmatrix_ext_t {
    pub map_p: *mut *const cty::c_char,
    pub button_areas: *mut lv_area_t,
    pub ctrl_bits: *mut lv_btnmatrix_ctrl_t,
    pub style_btn: lv_style_list_t,
    pub btn_cnt: u16,
    pub btn_id_pr: u16,
    pub btn_id_focused: u16,
    pub btn_id_act: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl lv_btnmatrix_ext_t {
    #[inline]
    pub fn recolor(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_recolor(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn one_check(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_one_check(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn align(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_align(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        recolor: u8,
        one_check: u8,
        align: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let recolor: u8 = unsafe { ::core::mem::transmute(recolor) };
            recolor as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let one_check: u8 = unsafe { ::core::mem::transmute(one_check) };
            one_check as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let align: u8 = unsafe { ::core::mem::transmute(align) };
            align as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_BTNMATRIX_PART_BG: cty::c_int = 0;
pub const LV_BTNMATRIX_PART_BTN: cty::c_int = 1;
pub type _bindgen_ty_69 = cty::c_int;
pub type lv_btnmatrix_part_t = u8;
extern "C" {
    pub fn lv_btnmatrix_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_btnmatrix_set_map(btnm: *mut lv_obj_t, map: *mut *const cty::c_char);
}
extern "C" {
    pub fn lv_btnmatrix_set_ctrl_map(btnm: *mut lv_obj_t, ctrl_map: *const lv_btnmatrix_ctrl_t);
}
extern "C" {
    pub fn lv_btnmatrix_set_focused_btn(btnm: *mut lv_obj_t, id: u16);
}
extern "C" {
    pub fn lv_btnmatrix_set_recolor(btnm: *const lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_btnmatrix_set_btn_ctrl(btnm: *mut lv_obj_t, btn_id: u16, ctrl: lv_btnmatrix_ctrl_t);
}
extern "C" {
    pub fn lv_btnmatrix_clear_btn_ctrl(
        btnm: *const lv_obj_t,
        btn_id: u16,
        ctrl: lv_btnmatrix_ctrl_t,
    );
}
extern "C" {
    pub fn lv_btnmatrix_set_btn_ctrl_all(btnm: *mut lv_obj_t, ctrl: lv_btnmatrix_ctrl_t);
}
extern "C" {
    pub fn lv_btnmatrix_clear_btn_ctrl_all(btnm: *mut lv_obj_t, ctrl: lv_btnmatrix_ctrl_t);
}
extern "C" {
    pub fn lv_btnmatrix_set_btn_width(btnm: *mut lv_obj_t, btn_id: u16, width: u8);
}
extern "C" {
    pub fn lv_btnmatrix_set_one_check(btnm: *mut lv_obj_t, one_chk: bool);
}
extern "C" {
    pub fn lv_btnmatrix_set_align(btnm: *mut lv_obj_t, align: lv_label_align_t);
}
extern "C" {
    pub fn lv_btnmatrix_get_map_array(btnm: *const lv_obj_t) -> *mut *const cty::c_char;
}
extern "C" {
    pub fn lv_btnmatrix_get_recolor(btnm: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_btnmatrix_get_active_btn(btnm: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_btnmatrix_get_active_btn_text(btnm: *const lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    pub fn lv_btnmatrix_get_focused_btn(btnm: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_btnmatrix_get_btn_text(btnm: *const lv_obj_t, btn_id: u16) -> *const cty::c_char;
}
extern "C" {
    pub fn lv_btnmatrix_get_btn_ctrl(
        btnm: *mut lv_obj_t,
        btn_id: u16,
        ctrl: lv_btnmatrix_ctrl_t,
    ) -> bool;
}
extern "C" {
    pub fn lv_btnmatrix_get_one_check(btnm: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_btnmatrix_get_align(btnm: *const lv_obj_t) -> lv_label_align_t;
}
pub const LV_KEYBOARD_MODE_TEXT_LOWER: cty::c_int = 0;
pub const LV_KEYBOARD_MODE_TEXT_UPPER: cty::c_int = 1;
pub const LV_KEYBOARD_MODE_SPECIAL: cty::c_int = 2;
pub const LV_KEYBOARD_MODE_NUM: cty::c_int = 3;
pub type _bindgen_ty_70 = cty::c_int;
pub type lv_keyboard_mode_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_keyboard_ext_t {
    pub btnm: lv_btnmatrix_ext_t,
    pub ta: *mut lv_obj_t,
    pub mode: lv_keyboard_mode_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl lv_keyboard_ext_t {
    #[inline]
    pub fn cursor_mng(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cursor_mng(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(cursor_mng: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cursor_mng: u8 = unsafe { ::core::mem::transmute(cursor_mng) };
            cursor_mng as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_KEYBOARD_PART_BG: cty::c_int = 0;
pub const LV_KEYBOARD_PART_BTN: cty::c_int = 1;
pub type _bindgen_ty_71 = cty::c_int;
pub type lv_keyboard_style_t = u8;
extern "C" {
    pub fn lv_keyboard_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_keyboard_set_textarea(kb: *mut lv_obj_t, ta: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_keyboard_set_mode(kb: *mut lv_obj_t, mode: lv_keyboard_mode_t);
}
extern "C" {
    pub fn lv_keyboard_set_cursor_manage(kb: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_keyboard_set_map(
        kb: *mut lv_obj_t,
        mode: lv_keyboard_mode_t,
        map: *mut *const cty::c_char,
    );
}
extern "C" {
    pub fn lv_keyboard_set_ctrl_map(
        kb: *mut lv_obj_t,
        mode: lv_keyboard_mode_t,
        ctrl_map: *const lv_btnmatrix_ctrl_t,
    );
}
extern "C" {
    pub fn lv_keyboard_get_textarea(kb: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_keyboard_get_mode(kb: *const lv_obj_t) -> lv_keyboard_mode_t;
}
extern "C" {
    pub fn lv_keyboard_get_cursor_manage(kb: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_keyboard_def_event_cb(kb: *mut lv_obj_t, event: lv_event_t);
}
pub const LV_DROPDOWN_DIR_DOWN: cty::c_int = 0;
pub const LV_DROPDOWN_DIR_UP: cty::c_int = 1;
pub const LV_DROPDOWN_DIR_LEFT: cty::c_int = 2;
pub const LV_DROPDOWN_DIR_RIGHT: cty::c_int = 3;
pub type _bindgen_ty_72 = cty::c_int;
pub type lv_dropdown_dir_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_dropdown_ext_t {
    pub page: *mut lv_obj_t,
    pub text: *const cty::c_char,
    pub symbol: *const cty::c_char,
    pub options: *mut cty::c_char,
    pub style_selected: lv_style_list_t,
    pub style_page: lv_style_list_t,
    pub style_scrlbar: lv_style_list_t,
    pub max_height: lv_coord_t,
    pub option_cnt: u16,
    pub sel_opt_id: u16,
    pub sel_opt_id_orig: u16,
    pub pr_opt_id: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 5usize],
}
impl lv_dropdown_ext_t {
    #[inline]
    pub fn dir(&self) -> lv_dropdown_dir_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_dir(&mut self, val: lv_dropdown_dir_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn show_selected(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_show_selected(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn static_txt(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_static_txt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dir: lv_dropdown_dir_t,
        show_selected: u8,
        static_txt: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let dir: u8 = unsafe { ::core::mem::transmute(dir) };
            dir as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let show_selected: u8 = unsafe { ::core::mem::transmute(show_selected) };
            show_selected as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let static_txt: u8 = unsafe { ::core::mem::transmute(static_txt) };
            static_txt as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_DROPDOWN_PART_MAIN: cty::c_int = 0;
pub const LV_DROPDOWN_PART_LIST: cty::c_int = 64;
pub const LV_DROPDOWN_PART_SCROLLBAR: cty::c_int = 65;
pub const LV_DROPDOWN_PART_SELECTED: cty::c_int = 66;
pub type _bindgen_ty_73 = cty::c_int;
pub type lv_dropdown_part_t = u8;
extern "C" {
    pub fn lv_dropdown_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_dropdown_set_text(ddlist: *mut lv_obj_t, txt: *const cty::c_char);
}
extern "C" {
    pub fn lv_dropdown_clear_options(ddlist: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_dropdown_set_options(ddlist: *mut lv_obj_t, options: *const cty::c_char);
}
extern "C" {
    pub fn lv_dropdown_set_options_static(ddlist: *mut lv_obj_t, options: *const cty::c_char);
}
extern "C" {
    pub fn lv_dropdown_add_option(ddlist: *mut lv_obj_t, option: *const cty::c_char, pos: u32);
}
extern "C" {
    pub fn lv_dropdown_set_selected(ddlist: *mut lv_obj_t, sel_opt: u16);
}
extern "C" {
    pub fn lv_dropdown_set_dir(ddlist: *mut lv_obj_t, dir: lv_dropdown_dir_t);
}
extern "C" {
    pub fn lv_dropdown_set_max_height(ddlist: *mut lv_obj_t, h: lv_coord_t);
}
extern "C" {
    pub fn lv_dropdown_set_symbol(ddlist: *mut lv_obj_t, symbol: *const cty::c_char);
}
extern "C" {
    pub fn lv_dropdown_set_show_selected(ddlist: *mut lv_obj_t, show: bool);
}
extern "C" {
    pub fn lv_dropdown_get_text(ddlist: *mut lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    pub fn lv_dropdown_get_options(ddlist: *const lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    pub fn lv_dropdown_get_selected(ddlist: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_dropdown_get_option_cnt(ddlist: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_dropdown_get_selected_str(
        ddlist: *const lv_obj_t,
        buf: *mut cty::c_char,
        buf_size: u32,
    );
}
extern "C" {
    pub fn lv_dropdown_get_max_height(ddlist: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_dropdown_get_symbol(ddlist: *mut lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    pub fn lv_dropdown_get_dir(ddlist: *const lv_obj_t) -> lv_dropdown_dir_t;
}
extern "C" {
    pub fn lv_dropdown_get_show_selected(ddlist: *mut lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_dropdown_open(ddlist: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_dropdown_close(ddlist: *mut lv_obj_t);
}
pub const LV_ROLLER_MODE_NORMAL: cty::c_int = 0;
pub const LV_ROLLER_MODE_INFINITE: cty::c_int = 1;
pub type _bindgen_ty_74 = cty::c_int;
pub type lv_roller_mode_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_roller_ext_t {
    pub page: lv_page_ext_t,
    pub style_sel: lv_style_list_t,
    pub option_cnt: u16,
    pub sel_opt_id: u16,
    pub sel_opt_id_ori: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u8,
}
impl lv_roller_ext_t {
    #[inline]
    pub fn mode(&self) -> lv_roller_mode_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mode(&mut self, val: lv_roller_mode_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn auto_fit(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_auto_fit(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mode: lv_roller_mode_t,
        auto_fit: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mode: u8 = unsafe { ::core::mem::transmute(mode) };
            mode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let auto_fit: u8 = unsafe { ::core::mem::transmute(auto_fit) };
            auto_fit as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_ROLLER_PART_BG: cty::c_int = 0;
pub const LV_ROLLER_PART_SELECTED: cty::c_int = 3;
pub const _LV_ROLLER_PART_VIRTUAL_LAST: cty::c_int = 4;
pub type _bindgen_ty_75 = cty::c_int;
pub type lv_roller_part_t = u8;
extern "C" {
    pub fn lv_roller_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_roller_set_options(
        roller: *mut lv_obj_t,
        options: *const cty::c_char,
        mode: lv_roller_mode_t,
    );
}
extern "C" {
    pub fn lv_roller_set_align(roller: *mut lv_obj_t, align: lv_label_align_t);
}
extern "C" {
    pub fn lv_roller_set_selected(roller: *mut lv_obj_t, sel_opt: u16, anim: lv_anim_enable_t);
}
extern "C" {
    pub fn lv_roller_set_visible_row_count(roller: *mut lv_obj_t, row_cnt: u8);
}
extern "C" {
    pub fn lv_roller_set_auto_fit(roller: *mut lv_obj_t, auto_fit: bool);
}
extern "C" {
    pub fn lv_roller_get_selected(roller: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_roller_get_option_cnt(roller: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_roller_get_selected_str(
        roller: *const lv_obj_t,
        buf: *mut cty::c_char,
        buf_size: u32,
    );
}
extern "C" {
    pub fn lv_roller_get_align(roller: *const lv_obj_t) -> lv_label_align_t;
}
extern "C" {
    pub fn lv_roller_get_auto_fit(roller: *mut lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_roller_get_options(roller: *const lv_obj_t) -> *const cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_textarea_ext_t {
    pub page: lv_page_ext_t,
    pub label: *mut lv_obj_t,
    pub placeholder_txt: *mut cty::c_char,
    pub style_placeholder: lv_style_list_t,
    pub pwd_tmp: *mut cty::c_char,
    pub accepted_chars: *const cty::c_char,
    pub max_length: u32,
    pub pwd_show_time: u16,
    pub cursor: lv_textarea_ext_t__bindgen_ty_1,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_textarea_ext_t__bindgen_ty_1 {
    pub style: lv_style_list_t,
    pub valid_x: lv_coord_t,
    pub pos: u32,
    pub blink_time: u16,
    pub area: lv_area_t,
    pub txt_byte_pos: u32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl lv_textarea_ext_t__bindgen_ty_1 {
    #[inline]
    pub fn state(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_state(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hidden(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hidden(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn click_pos(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_click_pos(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state: u8,
        hidden: u8,
        click_pos: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let state: u8 = unsafe { ::core::mem::transmute(state) };
            state as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let hidden: u8 = unsafe { ::core::mem::transmute(hidden) };
            hidden as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let click_pos: u8 = unsafe { ::core::mem::transmute(click_pos) };
            click_pos as u64
        });
        __bindgen_bitfield_unit
    }
}
impl lv_textarea_ext_t {
    #[inline]
    pub fn pwd_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pwd_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn one_line(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_one_line(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(pwd_mode: u8, one_line: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let pwd_mode: u8 = unsafe { ::core::mem::transmute(pwd_mode) };
            pwd_mode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let one_line: u8 = unsafe { ::core::mem::transmute(one_line) };
            one_line as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_TEXTAREA_PART_BG: cty::c_int = 0;
pub const LV_TEXTAREA_PART_SCROLLBAR: cty::c_int = 1;
pub const LV_TEXTAREA_PART_EDGE_FLASH: cty::c_int = 2;
pub const LV_TEXTAREA_PART_CURSOR: cty::c_int = 3;
pub const LV_TEXTAREA_PART_PLACEHOLDER: cty::c_int = 4;
pub const _LV_TEXTAREA_PART_VIRTUAL_LAST: cty::c_int = 5;
pub const _LV_TEXTAREA_PART_REAL_LAST: cty::c_int = 65;
pub type _bindgen_ty_76 = cty::c_int;
pub type lv_textarea_style_t = u8;
extern "C" {
    pub fn lv_textarea_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_textarea_add_char(ta: *mut lv_obj_t, c: u32);
}
extern "C" {
    pub fn lv_textarea_add_text(ta: *mut lv_obj_t, txt: *const cty::c_char);
}
extern "C" {
    pub fn lv_textarea_del_char(ta: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_textarea_del_char_forward(ta: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_textarea_set_text(ta: *mut lv_obj_t, txt: *const cty::c_char);
}
extern "C" {
    pub fn lv_textarea_set_placeholder_text(ta: *mut lv_obj_t, txt: *const cty::c_char);
}
extern "C" {
    pub fn lv_textarea_set_cursor_pos(ta: *mut lv_obj_t, pos: i32);
}
extern "C" {
    pub fn lv_textarea_set_cursor_hidden(ta: *mut lv_obj_t, hide: bool);
}
extern "C" {
    pub fn lv_textarea_set_cursor_click_pos(ta: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_textarea_set_pwd_mode(ta: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_textarea_set_one_line(ta: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_textarea_set_text_align(ta: *mut lv_obj_t, align: lv_label_align_t);
}
extern "C" {
    pub fn lv_textarea_set_accepted_chars(ta: *mut lv_obj_t, list: *const cty::c_char);
}
extern "C" {
    pub fn lv_textarea_set_max_length(ta: *mut lv_obj_t, num: u32);
}
extern "C" {
    pub fn lv_textarea_set_insert_replace(ta: *mut lv_obj_t, txt: *const cty::c_char);
}
extern "C" {
    pub fn lv_textarea_set_text_sel(ta: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_textarea_set_pwd_show_time(ta: *mut lv_obj_t, time: u16);
}
extern "C" {
    pub fn lv_textarea_set_cursor_blink_time(ta: *mut lv_obj_t, time: u16);
}
extern "C" {
    pub fn lv_textarea_get_text(ta: *const lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    pub fn lv_textarea_get_placeholder_text(ta: *mut lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    pub fn lv_textarea_get_label(ta: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_textarea_get_cursor_pos(ta: *const lv_obj_t) -> u32;
}
extern "C" {
    pub fn lv_textarea_get_cursor_hidden(ta: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_textarea_get_cursor_click_pos(ta: *mut lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_textarea_get_pwd_mode(ta: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_textarea_get_one_line(ta: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_textarea_get_accepted_chars(ta: *mut lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    pub fn lv_textarea_get_max_length(ta: *mut lv_obj_t) -> u32;
}
extern "C" {
    pub fn lv_textarea_text_is_selected(ta: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_textarea_get_text_sel_en(ta: *mut lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_textarea_get_pwd_show_time(ta: *mut lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_textarea_get_cursor_blink_time(ta: *mut lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_textarea_clear_selection(ta: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_textarea_cursor_right(ta: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_textarea_cursor_left(ta: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_textarea_cursor_down(ta: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_textarea_cursor_up(ta: *mut lv_obj_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_canvas_ext_t {
    pub img: lv_img_ext_t,
    pub dsc: lv_img_dsc_t,
}
pub const LV_CANVAS_PART_MAIN: cty::c_int = 0;
pub type _bindgen_ty_77 = cty::c_int;
pub type lv_canvas_part_t = u8;
extern "C" {
    pub fn lv_canvas_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_canvas_set_buffer(
        canvas: *mut lv_obj_t,
        buf: *mut cty::c_void,
        w: lv_coord_t,
        h: lv_coord_t,
        cf: lv_img_cf_t,
    );
}
extern "C" {
    pub fn lv_canvas_set_px(canvas: *mut lv_obj_t, x: lv_coord_t, y: lv_coord_t, c: lv_color_t);
}
extern "C" {
    pub fn lv_canvas_set_palette(canvas: *mut lv_obj_t, id: u8, c: lv_color_t);
}
extern "C" {
    pub fn lv_canvas_get_px(canvas: *mut lv_obj_t, x: lv_coord_t, y: lv_coord_t) -> lv_color_t;
}
extern "C" {
    pub fn lv_canvas_get_img(canvas: *mut lv_obj_t) -> *mut lv_img_dsc_t;
}
extern "C" {
    pub fn lv_canvas_copy_buf(
        canvas: *mut lv_obj_t,
        to_copy: *const cty::c_void,
        x: lv_coord_t,
        y: lv_coord_t,
        w: lv_coord_t,
        h: lv_coord_t,
    );
}
extern "C" {
    pub fn lv_canvas_transform(
        canvas: *mut lv_obj_t,
        img: *mut lv_img_dsc_t,
        angle: i16,
        zoom: u16,
        offset_x: lv_coord_t,
        offset_y: lv_coord_t,
        pivot_x: i32,
        pivot_y: i32,
        antialias: bool,
    );
}
extern "C" {
    pub fn lv_canvas_blur_hor(canvas: *mut lv_obj_t, area: *const lv_area_t, r: u16);
}
extern "C" {
    pub fn lv_canvas_blur_ver(canvas: *mut lv_obj_t, area: *const lv_area_t, r: u16);
}
extern "C" {
    pub fn lv_canvas_fill_bg(canvas: *mut lv_obj_t, color: lv_color_t, opa: lv_opa_t);
}
extern "C" {
    pub fn lv_canvas_draw_rect(
        canvas: *mut lv_obj_t,
        x: lv_coord_t,
        y: lv_coord_t,
        w: lv_coord_t,
        h: lv_coord_t,
        rect_dsc: *const lv_draw_rect_dsc_t,
    );
}
extern "C" {
    pub fn lv_canvas_draw_text(
        canvas: *mut lv_obj_t,
        x: lv_coord_t,
        y: lv_coord_t,
        max_w: lv_coord_t,
        label_draw_dsc: *mut lv_draw_label_dsc_t,
        txt: *const cty::c_char,
        align: lv_label_align_t,
    );
}
extern "C" {
    pub fn lv_canvas_draw_img(
        canvas: *mut lv_obj_t,
        x: lv_coord_t,
        y: lv_coord_t,
        src: *const cty::c_void,
        img_draw_dsc: *const lv_draw_img_dsc_t,
    );
}
extern "C" {
    pub fn lv_canvas_draw_line(
        canvas: *mut lv_obj_t,
        points: *const lv_point_t,
        point_cnt: u32,
        line_draw_dsc: *const lv_draw_line_dsc_t,
    );
}
extern "C" {
    pub fn lv_canvas_draw_polygon(
        canvas: *mut lv_obj_t,
        points: *const lv_point_t,
        point_cnt: u32,
        poly_draw_dsc: *const lv_draw_rect_dsc_t,
    );
}
extern "C" {
    pub fn lv_canvas_draw_arc(
        canvas: *mut lv_obj_t,
        x: lv_coord_t,
        y: lv_coord_t,
        r: lv_coord_t,
        start_angle: i32,
        end_angle: i32,
        arc_draw_dsc: *const lv_draw_line_dsc_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_win_ext_t {
    pub page: *mut lv_obj_t,
    pub header: *mut lv_obj_t,
    pub title_txt: *mut cty::c_char,
    pub btn_w: lv_coord_t,
    pub title_txt_align: u8,
}
pub const LV_WIN_PART_BG: cty::c_int = 0;
pub const _LV_WIN_PART_VIRTUAL_LAST: cty::c_int = 1;
pub const LV_WIN_PART_HEADER: cty::c_int = 64;
pub const LV_WIN_PART_CONTENT_SCROLLABLE: cty::c_int = 65;
pub const LV_WIN_PART_SCROLLBAR: cty::c_int = 66;
pub const _LV_WIN_PART_REAL_LAST: cty::c_int = 67;
pub type _bindgen_ty_78 = cty::c_int;
extern "C" {
    pub fn lv_win_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_win_clean(win: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_win_add_btn_right(win: *mut lv_obj_t, img_src: *const cty::c_void) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_win_add_btn_left(win: *mut lv_obj_t, img_src: *const cty::c_void) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_win_close_event_cb(btn: *mut lv_obj_t, event: lv_event_t);
}
extern "C" {
    pub fn lv_win_set_title(win: *mut lv_obj_t, title: *const cty::c_char);
}
extern "C" {
    pub fn lv_win_set_header_height(win: *mut lv_obj_t, size: lv_coord_t);
}
extern "C" {
    pub fn lv_win_set_btn_width(win: *mut lv_obj_t, width: lv_coord_t);
}
extern "C" {
    pub fn lv_win_set_content_size(win: *mut lv_obj_t, w: lv_coord_t, h: lv_coord_t);
}
extern "C" {
    pub fn lv_win_set_layout(win: *mut lv_obj_t, layout: lv_layout_t);
}
extern "C" {
    pub fn lv_win_set_scrollbar_mode(win: *mut lv_obj_t, sb_mode: lv_scrollbar_mode_t);
}
extern "C" {
    pub fn lv_win_set_anim_time(win: *mut lv_obj_t, anim_time: u16);
}
extern "C" {
    pub fn lv_win_set_drag(win: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_win_title_set_alignment(win: *mut lv_obj_t, alignment: u8);
}
extern "C" {
    pub fn lv_win_get_title(win: *const lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    pub fn lv_win_get_content(win: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_win_get_header_height(win: *const lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_win_get_btn_width(win: *mut lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_win_get_from_btn(ctrl_btn: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_win_get_layout(win: *mut lv_obj_t) -> lv_layout_t;
}
extern "C" {
    pub fn lv_win_get_sb_mode(win: *mut lv_obj_t) -> lv_scrollbar_mode_t;
}
extern "C" {
    pub fn lv_win_get_anim_time(win: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_win_get_width(win: *mut lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_win_title_get_alignment(win: *mut lv_obj_t) -> u8;
}
extern "C" {
    pub fn lv_win_focus(win: *mut lv_obj_t, obj: *mut lv_obj_t, anim_en: lv_anim_enable_t);
}
pub const LV_TABVIEW_TAB_POS_NONE: cty::c_int = 0;
pub const LV_TABVIEW_TAB_POS_TOP: cty::c_int = 1;
pub const LV_TABVIEW_TAB_POS_BOTTOM: cty::c_int = 2;
pub const LV_TABVIEW_TAB_POS_LEFT: cty::c_int = 3;
pub const LV_TABVIEW_TAB_POS_RIGHT: cty::c_int = 4;
pub type _bindgen_ty_79 = cty::c_int;
pub type lv_tabview_btns_pos_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_tabview_ext_t {
    pub btns: *mut lv_obj_t,
    pub indic: *mut lv_obj_t,
    pub content: *mut lv_obj_t,
    pub tab_name_ptr: *mut *const cty::c_char,
    pub point_last: lv_point_t,
    pub tab_cur: u16,
    pub tab_cnt: u16,
    pub anim_time: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 5usize],
}
impl lv_tabview_ext_t {
    #[inline]
    pub fn btns_pos(&self) -> lv_tabview_btns_pos_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_btns_pos(&mut self, val: lv_tabview_btns_pos_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(btns_pos: lv_tabview_btns_pos_t) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let btns_pos: u8 = unsafe { ::core::mem::transmute(btns_pos) };
            btns_pos as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_TABVIEW_PART_BG: cty::c_int = 0;
pub const _LV_TABVIEW_PART_VIRTUAL_LAST: cty::c_int = 1;
pub const LV_TABVIEW_PART_BG_SCROLLABLE: cty::c_int = 64;
pub const LV_TABVIEW_PART_TAB_BG: cty::c_int = 65;
pub const LV_TABVIEW_PART_TAB_BTN: cty::c_int = 66;
pub const LV_TABVIEW_PART_INDIC: cty::c_int = 67;
pub const _LV_TABVIEW_PART_REAL_LAST: cty::c_int = 68;
pub type _bindgen_ty_80 = cty::c_int;
pub type lv_tabview_part_t = u8;
extern "C" {
    pub fn lv_tabview_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_tabview_add_tab(tabview: *mut lv_obj_t, name: *const cty::c_char) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_tabview_clean_tab(tab: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_tabview_set_tab_act(tabview: *mut lv_obj_t, id: u16, anim: lv_anim_enable_t);
}
extern "C" {
    pub fn lv_tabview_set_tab_name(tabview: *mut lv_obj_t, id: u16, name: *mut cty::c_char);
}
extern "C" {
    pub fn lv_tabview_set_anim_time(tabview: *mut lv_obj_t, anim_time: u16);
}
extern "C" {
    pub fn lv_tabview_set_btns_pos(tabview: *mut lv_obj_t, btns_pos: lv_tabview_btns_pos_t);
}
extern "C" {
    pub fn lv_tabview_get_tab_act(tabview: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_tabview_get_tab_count(tabview: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_tabview_get_tab(tabview: *const lv_obj_t, id: u16) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_tabview_get_anim_time(tabview: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_tabview_get_btns_pos(tabview: *const lv_obj_t) -> lv_tabview_btns_pos_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_tileview_ext_t {
    pub page: lv_page_ext_t,
    pub valid_pos: *const lv_point_t,
    pub valid_pos_cnt: u16,
    pub anim_time: u16,
    pub act_id: lv_point_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl lv_tileview_ext_t {
    #[inline]
    pub fn drag_top_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_top_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_bottom_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_bottom_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_left_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_left_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn drag_right_en(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_drag_right_en(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        drag_top_en: u8,
        drag_bottom_en: u8,
        drag_left_en: u8,
        drag_right_en: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let drag_top_en: u8 = unsafe { ::core::mem::transmute(drag_top_en) };
            drag_top_en as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let drag_bottom_en: u8 = unsafe { ::core::mem::transmute(drag_bottom_en) };
            drag_bottom_en as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let drag_left_en: u8 = unsafe { ::core::mem::transmute(drag_left_en) };
            drag_left_en as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let drag_right_en: u8 = unsafe { ::core::mem::transmute(drag_right_en) };
            drag_right_en as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_TILEVIEW_PART_BG: cty::c_int = 0;
pub const LV_TILEVIEW_PART_SCROLLBAR: cty::c_int = 1;
pub const LV_TILEVIEW_PART_EDGE_FLASH: cty::c_int = 2;
pub const _LV_TILEVIEW_PART_VIRTUAL_LAST: cty::c_int = 3;
pub const _LV_TILEVIEW_PART_REAL_LAST: cty::c_int = 65;
pub type _bindgen_ty_81 = cty::c_int;
extern "C" {
    pub fn lv_tileview_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_tileview_add_element(tileview: *mut lv_obj_t, element: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_tileview_set_valid_positions(
        tileview: *mut lv_obj_t,
        valid_pos: *const lv_point_t,
        valid_pos_cnt: u16,
    );
}
extern "C" {
    pub fn lv_tileview_set_tile_act(
        tileview: *mut lv_obj_t,
        x: lv_coord_t,
        y: lv_coord_t,
        anim: lv_anim_enable_t,
    );
}
extern "C" {
    pub fn lv_tileview_get_tile_act(
        tileview: *mut lv_obj_t,
        x: *mut lv_coord_t,
        y: *mut lv_coord_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_msgbox_ext_t {
    pub bg: lv_cont_ext_t,
    pub text: *mut lv_obj_t,
    pub btnm: *mut lv_obj_t,
    pub anim_time: u16,
}
pub const LV_MSGBOX_PART_BG: cty::c_int = 0;
pub const LV_MSGBOX_PART_BTN_BG: cty::c_int = 64;
pub const LV_MSGBOX_PART_BTN: cty::c_int = 65;
pub type _bindgen_ty_82 = cty::c_int;
pub type lv_msgbox_style_t = u8;
extern "C" {
    pub fn lv_msgbox_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_msgbox_add_btns(mbox: *mut lv_obj_t, btn_mapaction: *mut *const cty::c_char);
}
extern "C" {
    pub fn lv_msgbox_set_text(mbox: *mut lv_obj_t, txt: *const cty::c_char);
}
extern "C" {
    pub fn lv_msgbox_set_text_fmt(mbox: *mut lv_obj_t, fmt: *const cty::c_char, ...);
}
extern "C" {
    pub fn lv_msgbox_set_anim_time(mbox: *mut lv_obj_t, anim_time: u16);
}
extern "C" {
    pub fn lv_msgbox_start_auto_close(mbox: *mut lv_obj_t, delay: u16);
}
extern "C" {
    pub fn lv_msgbox_stop_auto_close(mbox: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_msgbox_set_recolor(mbox: *mut lv_obj_t, en: bool);
}
extern "C" {
    pub fn lv_msgbox_get_text(mbox: *const lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    pub fn lv_msgbox_get_active_btn(mbox: *mut lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_msgbox_get_active_btn_text(mbox: *mut lv_obj_t) -> *const cty::c_char;
}
extern "C" {
    pub fn lv_msgbox_get_anim_time(mbox: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_msgbox_get_recolor(mbox: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_msgbox_get_btnmatrix(mbox: *mut lv_obj_t) -> *mut lv_obj_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_objmask_mask_t {
    pub param: *mut cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_objmask_ext_t {
    pub cont: lv_cont_ext_t,
    pub mask_ll: lv_ll_t,
}
pub const LV_OBJMASK_PART_MAIN: cty::c_int = 0;
pub type _bindgen_ty_83 = cty::c_int;
pub type lv_objmask_part_t = u8;
extern "C" {
    pub fn lv_objmask_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_objmask_add_mask(
        objmask: *mut lv_obj_t,
        param: *mut cty::c_void,
    ) -> *mut lv_objmask_mask_t;
}
extern "C" {
    pub fn lv_objmask_update_mask(
        objmask: *mut lv_obj_t,
        mask: *mut lv_objmask_mask_t,
        param: *mut cty::c_void,
    );
}
extern "C" {
    pub fn lv_objmask_remove_mask(objmask: *mut lv_obj_t, mask: *mut lv_objmask_mask_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_linemeter_ext_t {
    pub scale_angle: u16,
    pub angle_ofs: u16,
    pub line_cnt: u16,
    pub cur_value: i32,
    pub min_value: i32,
    pub max_value: i32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl lv_linemeter_ext_t {
    #[inline]
    pub fn mirrored(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mirrored(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(mirrored: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mirrored: u8 = unsafe { ::core::mem::transmute(mirrored) };
            mirrored as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_LINEMETER_PART_MAIN: cty::c_int = 0;
pub const _LV_LINEMETER_PART_VIRTUAL_LAST: cty::c_int = 1;
pub const _LV_LINEMETER_PART_REAL_LAST: cty::c_int = 64;
pub type _bindgen_ty_84 = cty::c_int;
pub type lv_linemeter_part_t = u8;
extern "C" {
    pub fn lv_linemeter_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_linemeter_set_value(lmeter: *mut lv_obj_t, value: i32);
}
extern "C" {
    pub fn lv_linemeter_set_range(lmeter: *mut lv_obj_t, min: i32, max: i32);
}
extern "C" {
    pub fn lv_linemeter_set_scale(lmeter: *mut lv_obj_t, angle: u16, line_cnt: u16);
}
extern "C" {
    pub fn lv_linemeter_set_angle_offset(lmeter: *mut lv_obj_t, angle: u16);
}
extern "C" {
    pub fn lv_linemeter_set_mirror(lmeter: *mut lv_obj_t, mirror: bool);
}
extern "C" {
    pub fn lv_linemeter_get_value(lmeter: *const lv_obj_t) -> i32;
}
extern "C" {
    pub fn lv_linemeter_get_min_value(lmeter: *const lv_obj_t) -> i32;
}
extern "C" {
    pub fn lv_linemeter_get_max_value(lmeter: *const lv_obj_t) -> i32;
}
extern "C" {
    pub fn lv_linemeter_get_line_count(lmeter: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_linemeter_get_scale_angle(lmeter: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_linemeter_get_angle_offset(lmeter: *mut lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_linemeter_draw_scale(lmeter: *mut lv_obj_t, clip_area: *const lv_area_t, part: u8);
}
extern "C" {
    pub fn lv_linemeter_get_mirror(lmeter: *mut lv_obj_t) -> bool;
}
pub type lv_gauge_format_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        gauge: *mut lv_obj_t,
        buf: *mut cty::c_char,
        bufsize: cty::c_int,
        value: i32,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_gauge_ext_t {
    pub lmeter: lv_linemeter_ext_t,
    pub values: *mut i32,
    pub needle_colors: *const lv_color_t,
    pub needle_img: *const cty::c_void,
    pub needle_img_pivot: lv_point_t,
    pub style_needle: lv_style_list_t,
    pub style_strong: lv_style_list_t,
    pub needle_count: u8,
    pub label_count: u8,
    pub format_cb: lv_gauge_format_cb_t,
}
pub const LV_GAUGE_PART_MAIN: cty::c_int = 0;
pub const LV_GAUGE_PART_MAJOR: cty::c_int = 1;
pub const LV_GAUGE_PART_NEEDLE: cty::c_int = 2;
pub const _LV_GAUGE_PART_VIRTUAL_LAST: cty::c_int = 1;
pub const _LV_GAUGE_PART_REAL_LAST: cty::c_int = 64;
pub type _bindgen_ty_85 = cty::c_int;
pub type lv_gauge_style_t = u8;
extern "C" {
    pub fn lv_gauge_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_gauge_set_needle_count(
        gauge: *mut lv_obj_t,
        needle_cnt: u8,
        colors: *const lv_color_t,
    );
}
extern "C" {
    pub fn lv_gauge_set_value(gauge: *mut lv_obj_t, needle_id: u8, value: i32);
}
extern "C" {
    pub fn lv_gauge_set_scale(gauge: *mut lv_obj_t, angle: u16, line_cnt: u8, label_cnt: u8);
}
extern "C" {
    pub fn lv_gauge_set_needle_img(
        gauge: *mut lv_obj_t,
        img: *const cty::c_void,
        pivot_x: lv_coord_t,
        pivot_y: lv_coord_t,
    );
}
extern "C" {
    pub fn lv_gauge_set_formatter_cb(gauge: *mut lv_obj_t, format_cb: lv_gauge_format_cb_t);
}
extern "C" {
    pub fn lv_gauge_get_value(gauge: *const lv_obj_t, needle: u8) -> i32;
}
extern "C" {
    pub fn lv_gauge_get_needle_count(gauge: *const lv_obj_t) -> u8;
}
extern "C" {
    pub fn lv_gauge_get_label_count(gauge: *const lv_obj_t) -> u8;
}
extern "C" {
    pub fn lv_gauge_get_needle_img(gauge: *mut lv_obj_t) -> *const cty::c_void;
}
extern "C" {
    pub fn lv_gauge_get_needle_img_pivot_x(gauge: *mut lv_obj_t) -> lv_coord_t;
}
extern "C" {
    pub fn lv_gauge_get_needle_img_pivot_y(gauge: *mut lv_obj_t) -> lv_coord_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_switch_ext_t {
    pub bar: lv_bar_ext_t,
    pub style_knob: lv_style_list_t,
}
pub const LV_SWITCH_PART_BG: cty::c_int = 0;
pub const LV_SWITCH_PART_INDIC: cty::c_int = 1;
pub const LV_SWITCH_PART_KNOB: cty::c_int = 2;
pub const _LV_SWITCH_PART_VIRTUAL_LAST: cty::c_int = 3;
pub type _bindgen_ty_86 = cty::c_int;
pub type lv_switch_part_t = u8;
extern "C" {
    pub fn lv_switch_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_switch_on(sw: *mut lv_obj_t, anim: lv_anim_enable_t);
}
extern "C" {
    pub fn lv_switch_off(sw: *mut lv_obj_t, anim: lv_anim_enable_t);
}
extern "C" {
    pub fn lv_switch_toggle(sw: *mut lv_obj_t, anim: lv_anim_enable_t) -> bool;
}
pub const LV_ARC_TYPE_NORMAL: cty::c_int = 0;
pub const LV_ARC_TYPE_SYMMETRIC: cty::c_int = 1;
pub const LV_ARC_TYPE_REVERSE: cty::c_int = 2;
pub type _bindgen_ty_87 = cty::c_int;
pub type lv_arc_type_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_arc_ext_t {
    pub rotation_angle: u16,
    pub arc_angle_start: u16,
    pub arc_angle_end: u16,
    pub bg_angle_start: u16,
    pub bg_angle_end: u16,
    pub style_arc: lv_style_list_t,
    pub style_knob: lv_style_list_t,
    pub cur_value: i16,
    pub min_value: i16,
    pub max_value: i16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub chg_rate: u16,
    pub last_tick: u32,
    pub last_angle: i16,
}
impl lv_arc_ext_t {
    #[inline]
    pub fn dragging(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_dragging(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_type(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn adjustable(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_adjustable(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn min_close(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_min_close(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dragging: u16,
        type_: u16,
        adjustable: u16,
        min_close: u16,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dragging: u16 = unsafe { ::core::mem::transmute(dragging) };
            dragging as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let type_: u16 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let adjustable: u16 = unsafe { ::core::mem::transmute(adjustable) };
            adjustable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let min_close: u16 = unsafe { ::core::mem::transmute(min_close) };
            min_close as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_ARC_PART_BG: cty::c_int = 0;
pub const LV_ARC_PART_INDIC: cty::c_int = 1;
pub const LV_ARC_PART_KNOB: cty::c_int = 2;
pub const _LV_ARC_PART_VIRTUAL_LAST: cty::c_int = 3;
pub const _LV_ARC_PART_REAL_LAST: cty::c_int = 64;
pub type _bindgen_ty_88 = cty::c_int;
pub type lv_arc_part_t = u8;
extern "C" {
    pub fn lv_arc_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_arc_set_start_angle(arc: *mut lv_obj_t, start: u16);
}
extern "C" {
    pub fn lv_arc_set_end_angle(arc: *mut lv_obj_t, end: u16);
}
extern "C" {
    pub fn lv_arc_set_angles(arc: *mut lv_obj_t, start: u16, end: u16);
}
extern "C" {
    pub fn lv_arc_set_bg_start_angle(arc: *mut lv_obj_t, start: u16);
}
extern "C" {
    pub fn lv_arc_set_bg_end_angle(arc: *mut lv_obj_t, end: u16);
}
extern "C" {
    pub fn lv_arc_set_bg_angles(arc: *mut lv_obj_t, start: u16, end: u16);
}
extern "C" {
    pub fn lv_arc_set_rotation(arc: *mut lv_obj_t, rotation_angle: u16);
}
extern "C" {
    pub fn lv_arc_set_type(arc: *mut lv_obj_t, type_: lv_arc_type_t);
}
extern "C" {
    pub fn lv_arc_set_value(arc: *mut lv_obj_t, value: i16);
}
extern "C" {
    pub fn lv_arc_set_range(arc: *mut lv_obj_t, min: i16, max: i16);
}
extern "C" {
    pub fn lv_arc_set_chg_rate(arc: *mut lv_obj_t, threshold: u16);
}
extern "C" {
    pub fn lv_arc_set_adjustable(arc: *mut lv_obj_t, adjustable: bool);
}
extern "C" {
    pub fn lv_arc_get_angle_start(arc: *mut lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_arc_get_angle_end(arc: *mut lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_arc_get_bg_angle_start(arc: *mut lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_arc_get_bg_angle_end(arc: *mut lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_arc_get_type(arc: *const lv_obj_t) -> lv_arc_type_t;
}
extern "C" {
    pub fn lv_arc_get_value(arc: *const lv_obj_t) -> i16;
}
extern "C" {
    pub fn lv_arc_get_min_value(arc: *const lv_obj_t) -> i16;
}
extern "C" {
    pub fn lv_arc_get_max_value(arc: *const lv_obj_t) -> i16;
}
extern "C" {
    pub fn lv_arc_is_dragged(arc: *const lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_arc_get_adjustable(arc: *mut lv_obj_t) -> bool;
}
pub const LV_SPINNER_TYPE_SPINNING_ARC: cty::c_int = 0;
pub const LV_SPINNER_TYPE_FILLSPIN_ARC: cty::c_int = 1;
pub const LV_SPINNER_TYPE_CONSTANT_ARC: cty::c_int = 2;
pub type _bindgen_ty_89 = cty::c_int;
pub type lv_spinner_type_t = u8;
pub const LV_SPINNER_DIR_FORWARD: cty::c_int = 0;
pub const LV_SPINNER_DIR_BACKWARD: cty::c_int = 1;
pub type _bindgen_ty_90 = cty::c_int;
pub type lv_spinner_dir_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_spinner_ext_t {
    pub arc: lv_arc_ext_t,
    pub arc_length: lv_anim_value_t,
    pub time: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl lv_spinner_ext_t {
    #[inline]
    pub fn anim_type(&self) -> lv_spinner_type_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_anim_type(&mut self, val: lv_spinner_type_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn anim_dir(&self) -> lv_spinner_dir_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_anim_dir(&mut self, val: lv_spinner_dir_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        anim_type: lv_spinner_type_t,
        anim_dir: lv_spinner_dir_t,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let anim_type: u8 = unsafe { ::core::mem::transmute(anim_type) };
            anim_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let anim_dir: u8 = unsafe { ::core::mem::transmute(anim_dir) };
            anim_dir as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_SPINNER_PART_BG: cty::c_int = 0;
pub const LV_SPINNER_PART_INDIC: cty::c_int = 1;
pub const _LV_SPINNER_PART_VIRTUAL_LAST: cty::c_int = 2;
pub const _LV_SPINNER_PART_REAL_LAST: cty::c_int = 64;
pub type _bindgen_ty_91 = cty::c_int;
pub type lv_spinner_style_t = u8;
extern "C" {
    pub fn lv_spinner_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_spinner_set_arc_length(spinner: *mut lv_obj_t, deg: lv_anim_value_t);
}
extern "C" {
    pub fn lv_spinner_set_spin_time(spinner: *mut lv_obj_t, time: u16);
}
extern "C" {
    pub fn lv_spinner_set_type(spinner: *mut lv_obj_t, type_: lv_spinner_type_t);
}
extern "C" {
    pub fn lv_spinner_set_dir(spinner: *mut lv_obj_t, dir: lv_spinner_dir_t);
}
extern "C" {
    pub fn lv_spinner_get_arc_length(spinner: *const lv_obj_t) -> lv_anim_value_t;
}
extern "C" {
    pub fn lv_spinner_get_spin_time(spinner: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_spinner_get_type(spinner: *mut lv_obj_t) -> lv_spinner_type_t;
}
extern "C" {
    pub fn lv_spinner_get_dir(spinner: *mut lv_obj_t) -> lv_spinner_dir_t;
}
extern "C" {
    pub fn lv_spinner_anim_cb(ptr: *mut cty::c_void, val: lv_anim_value_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_calendar_date_t {
    pub year: u16,
    pub month: i8,
    pub day: i8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_calendar_ext_t {
    pub today: lv_calendar_date_t,
    pub showed_date: lv_calendar_date_t,
    pub highlighted_dates: *mut lv_calendar_date_t,
    pub btn_pressing: i8,
    pub highlighted_dates_num: u16,
    pub pressed_date: lv_calendar_date_t,
    pub day_names: *mut *const cty::c_char,
    pub month_names: *mut *const cty::c_char,
    pub style_header: lv_style_list_t,
    pub style_day_names: lv_style_list_t,
    pub style_date_nums: lv_style_list_t,
}
pub const LV_CALENDAR_PART_BG: cty::c_int = 0;
pub const LV_CALENDAR_PART_HEADER: cty::c_int = 1;
pub const LV_CALENDAR_PART_DAY_NAMES: cty::c_int = 2;
pub const LV_CALENDAR_PART_DATE: cty::c_int = 3;
pub type _bindgen_ty_92 = cty::c_int;
pub type lv_calendar_part_t = u8;
extern "C" {
    pub fn lv_calendar_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_calendar_set_today_date(calendar: *mut lv_obj_t, today: *mut lv_calendar_date_t);
}
extern "C" {
    pub fn lv_calendar_set_showed_date(calendar: *mut lv_obj_t, showed: *mut lv_calendar_date_t);
}
extern "C" {
    pub fn lv_calendar_set_highlighted_dates(
        calendar: *mut lv_obj_t,
        highlighted: *mut lv_calendar_date_t,
        date_num: u16,
    );
}
extern "C" {
    pub fn lv_calendar_set_day_names(calendar: *mut lv_obj_t, day_names: *mut *const cty::c_char);
}
extern "C" {
    pub fn lv_calendar_set_month_names(
        calendar: *mut lv_obj_t,
        month_names: *mut *const cty::c_char,
    );
}
extern "C" {
    pub fn lv_calendar_get_today_date(calendar: *const lv_obj_t) -> *mut lv_calendar_date_t;
}
extern "C" {
    pub fn lv_calendar_get_showed_date(calendar: *const lv_obj_t) -> *mut lv_calendar_date_t;
}
extern "C" {
    pub fn lv_calendar_get_pressed_date(calendar: *const lv_obj_t) -> *mut lv_calendar_date_t;
}
extern "C" {
    pub fn lv_calendar_get_highlighted_dates(calendar: *const lv_obj_t) -> *mut lv_calendar_date_t;
}
extern "C" {
    pub fn lv_calendar_get_highlighted_dates_num(calendar: *const lv_obj_t) -> u16;
}
extern "C" {
    pub fn lv_calendar_get_day_names(calendar: *const lv_obj_t) -> *mut *const cty::c_char;
}
extern "C" {
    pub fn lv_calendar_get_month_names(calendar: *const lv_obj_t) -> *mut *const cty::c_char;
}
extern "C" {
    pub fn lv_calendar_get_day_of_week(year: u32, month: u32, day: u32) -> u8;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lv_spinbox_ext_t {
    pub ta: lv_textarea_ext_t,
    pub value: i32,
    pub range_max: i32,
    pub range_min: i32,
    pub step: i32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
impl lv_spinbox_ext_t {
    #[inline]
    pub fn rollover(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rollover(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn digit_count(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_digit_count(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn dec_point_pos(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_dec_point_pos(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn digit_padding_left(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_digit_padding_left(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rollover: u8,
        digit_count: u16,
        dec_point_pos: u16,
        digit_padding_left: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rollover: u8 = unsafe { ::core::mem::transmute(rollover) };
            rollover as u64
        });
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let digit_count: u16 = unsafe { ::core::mem::transmute(digit_count) };
            digit_count as u64
        });
        __bindgen_bitfield_unit.set(5usize, 4u8, {
            let dec_point_pos: u16 = unsafe { ::core::mem::transmute(dec_point_pos) };
            dec_point_pos as u64
        });
        __bindgen_bitfield_unit.set(9usize, 4u8, {
            let digit_padding_left: u16 = unsafe { ::core::mem::transmute(digit_padding_left) };
            digit_padding_left as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const LV_SPINBOX_PART_BG: cty::c_int = 0;
pub const LV_SPINBOX_PART_CURSOR: cty::c_int = 3;
pub const _LV_SPINBOX_PART_VIRTUAL_LAST: cty::c_int = 5;
pub const _LV_SPINBOX_PART_REAL_LAST: cty::c_int = 65;
pub type _bindgen_ty_93 = cty::c_int;
pub type lv_spinbox_part_t = u8;
extern "C" {
    pub fn lv_spinbox_create(par: *mut lv_obj_t, copy: *const lv_obj_t) -> *mut lv_obj_t;
}
extern "C" {
    pub fn lv_spinbox_set_rollover(spinbox: *mut lv_obj_t, b: bool);
}
extern "C" {
    pub fn lv_spinbox_set_value(spinbox: *mut lv_obj_t, i: i32);
}
extern "C" {
    pub fn lv_spinbox_set_digit_format(
        spinbox: *mut lv_obj_t,
        digit_count: u8,
        separator_position: u8,
    );
}
extern "C" {
    pub fn lv_spinbox_set_step(spinbox: *mut lv_obj_t, step: u32);
}
extern "C" {
    pub fn lv_spinbox_set_range(spinbox: *mut lv_obj_t, range_min: i32, range_max: i32);
}
extern "C" {
    pub fn lv_spinbox_set_padding_left(spinbox: *mut lv_obj_t, padding: u8);
}
extern "C" {
    pub fn lv_spinbox_get_rollover(spinbox: *mut lv_obj_t) -> bool;
}
extern "C" {
    pub fn lv_spinbox_get_value(spinbox: *mut lv_obj_t) -> i32;
}
extern "C" {
    pub fn lv_spinbox_step_next(spinbox: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_spinbox_step_prev(spinbox: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_spinbox_increment(spinbox: *mut lv_obj_t);
}
extern "C" {
    pub fn lv_spinbox_decrement(spinbox: *mut lv_obj_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lv_img_cache_entry_t {
    pub dec_dsc: lv_img_decoder_dsc_t,
    pub life: i32,
}
extern "C" {
    pub fn _lv_img_cache_open(
        src: *const cty::c_void,
        color: lv_color_t,
    ) -> *mut lv_img_cache_entry_t;
}
extern "C" {
    pub fn lv_img_cache_set_size(new_slot_num: u16);
}
extern "C" {
    pub fn lv_img_cache_invalidate_src(src: *const cty::c_void);
}
extern "C" {
    pub fn _LV_COLOR_MAKE(r: u8, g: u8, b: u8) -> lv_color_t;
}
extern "C" {
    pub fn _LV_COLOR_GET_R(color: lv_color_t) -> u16;
}
extern "C" {
    pub fn _LV_COLOR_GET_G(color: lv_color_t) -> u16;
}
extern "C" {
    pub fn _LV_COLOR_GET_B(color: lv_color_t) -> u16;
}
extern "C" {
    pub fn _LV_COLOR_GET_A(color: lv_color_t) -> u16;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
pub type __builtin_va_list = *mut cty::c_char;
